// generated code; do not edit
#include "../source/core/slang-basic.h"
Slang::String get_slang_cpp_prelude()
{
Slang::StringBuilder sb;
sb << 
"#ifndef SLANG_CPP_PRELUDE_H\n"
"#define SLANG_CPP_PRELUDE_H\n"
"\n"
"// Because the signiture of isnan, isfinite, and is isinf changed in C++, we use the macro\n"
"// to use the version in the std namespace. \n"
"// https://stackoverflow.com/questions/39130040/cmath-hides-isnan-in-math-h-in-c14-c11\n"
" \n"
"#ifdef SLANG_LLVM\n"
"#   include \"slang-llvm.h\"\n"
"#else // SLANG_LLVM\n"
"#   if SLANG_GCC_FAMILY && __GNUC__ < 6\n"
"#       include <cmath>\n"
"#       define SLANG_PRELUDE_STD std::\n"
"#   else\n"
"#       include <math.h>\n"
"#       define SLANG_PRELUDE_STD\n"
"#   endif\n"
"\n"
"#   include <assert.h>\n"
"#   include <stdlib.h>\n"
"#   include <string.h>\n"
"#   include <stdint.h>\n"
"#endif // SLANG_LLVM\n"
"\n"
"#if defined(_MSC_VER)\n"
"#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __declspec(dllexport)\n"
"#else\n"
"#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__((__visibility__(\"default\")))\n"
"//#   define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__ ((dllexport)) __attribute__((__visibility__(\"default\")))\n"
"#endif    \n"
"\n"
"#ifdef __cplusplus    \n"
"#   define SLANG_PRELUDE_EXTERN_C extern \"C\"\n"
"#   define SLANG_PRELUDE_EXTERN_C_START extern \"C\" {\n"
"#   define SLANG_PRELUDE_EXTERN_C_END }\n"
"#else\n"
"#   define SLANG_PRELUDE_EXTERN_C \n"
"#   define SLANG_PRELUDE_EXTERN_C_START\n"
"#   define SLANG_PRELUDE_EXTERN_C_END \n"
"#endif    \n"
"\n"
"#define SLANG_PRELUDE_EXPORT SLANG_PRELUDE_EXTERN_C SLANG_PRELUDE_SHARED_LIB_EXPORT\n"
"\n"
"#ifndef SLANG_INFINITY\n"
"#   define SLANG_INFINITY   INFINITY\n"
"#endif\n"
"\n"
"// Detect the compiler type\n"
"\n"
"#ifndef SLANG_COMPILER\n"
"#    define SLANG_COMPILER\n"
"\n"
"/*\n"
"Compiler defines, see http://sourceforge.net/p/predef/wiki/Compilers/\n"
"NOTE that SLANG_VC holds the compiler version - not just 1 or 0\n"
"*/\n"
"#    if defined(_MSC_VER)\n"
"#        if _MSC_VER >= 1900\n"
"#            define SLANG_VC 14\n"
"#        elif _MSC_VER >= 1800\n"
"#            define SLANG_VC 12\n"
"#        elif _MSC_VER >= 1700\n"
"#            define SLANG_VC 11\n"
"#        elif _MSC_VER >= 1600\n"
"#            define SLANG_VC 10\n"
"#        elif _MSC_VER >= 1500\n"
"#            define SLANG_VC 9\n"
"#        else\n"
"#            error \"unknown version of Visual C++ compiler\"\n"
"#        endif\n"
"#    elif defined(__clang__)\n"
"#        define SLANG_CLANG 1\n"
"#    elif defined(__SNC__)\n"
"#        define SLANG_SNC 1\n"
"#    elif defined(__ghs__)\n"
"#        define SLANG_GHS 1\n"
"#    elif defined(__GNUC__) /* note: __clang__, __SNC__, or __ghs__ imply __GNUC__ */\n"
"#        define SLANG_GCC 1\n"
"#    else\n"
"#        error \"unknown compiler\"\n"
"#    endif\n"
"/*\n"
"Any compilers not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#    ifndef SLANG_VC\n"
"#        define SLANG_VC 0\n"
"#    endif\n"
"#    ifndef SLANG_CLANG\n"
"#        define SLANG_CLANG 0\n"
"#    endif\n"
"#    ifndef SLANG_SNC\n"
"#        define SLANG_SNC 0\n"
"#    endif\n"
"#    ifndef SLANG_GHS\n"
"#        define SLANG_GHS 0\n"
"#    endif\n"
"#    ifndef SLANG_GCC\n"
"#        define SLANG_GCC 0\n"
"#    endif\n"
"#endif /* SLANG_COMPILER */\n"
"\n"
"#define SLANG_GCC_FAMILY (SLANG_CLANG || SLANG_SNC || SLANG_GHS || SLANG_GCC)\n"
"\n"
"// GCC Specific\n"
"#if SLANG_GCC_FAMILY\n"
"#\tdefine SLANG_ALIGN_OF(T)\t__alignof__(T)\n"
"// Use this macro instead of offsetof, because gcc produces warning if offsetof is used on a \n"
"// non POD type, even though it produces the correct result\n"
"#   define SLANG_OFFSET_OF(T, ELEMENT) (size_t(&((T*)1)->ELEMENT) - 1)\n"
"#endif // SLANG_GCC_FAMILY\n"
"\n"
"// Microsoft VC specific\n"
"#if SLANG_VC\n"
"#   define SLANG_ALIGN_OF(T) __alignof(T)\n"
"#endif // SLANG_VC\n"
"\n"
"// Default impls\n"
"\n"
"#ifndef SLANG_OFFSET_OF\n"
"#   define SLANG_OFFSET_OF(X, Y) offsetof(X, Y)\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_CPP_TYPES_H\n"
"#define SLANG_PRELUDE_CPP_TYPES_H\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#   ifdef _DEBUG\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) assert(VALUE)\n"
"#   else\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) \n"
"#   endif\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#    define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE {\n"
"#endif\n"
"\n"
"struct TypeInfo\n"
"{\n"
"    size_t typeSize;\n"
"};\n"
"\n"
"template <typename T, size_t SIZE>\n"
"struct FixedArray\n"
"{\n"
"    const T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < SIZE); return m_data[index]; }\n"
"    T& operator[](size_t index) { SLANG_PRELUDE_ASSERT(index < SIZE); return m_data[index]; }\n"
"\n"
"    T m_data[SIZE];\n"
"};\n"
"\n"
"// An array that has no specified size, becomes a 'Array'. This stores the size so it can potentially \n"
"// do bounds checking.  \n"
"template <typename T>\n"
"struct Array\n"
"{\n"
"    const T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    T& operator[](size_t index) { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"#if 0\n"
"template<size_t N>\n"
"struct AnyValue\n"
"{\n"
"    uint8_t data[N];\n"
"};\n"
"template<size_t N, typename T>\n"
"AnyValue<N> packAnyValue(const T& val)\n"
"{\n"
"    AnyValue<N> result;\n"
"    memcpy(&result, &val, sizeof(T));\n"
"    return result;\n"
"}\n"
"template<size_t N, typename T>\n"
"T unpackAnyValue(const AnyValue<N>& val)\n"
"{\n"
"    T result;\n"
"    memcpy(&result, &val, sizeof(T));\n"
"    return result;\n"
"}\n"
"#endif\n"
"\n"
"/* Constant buffers become a pointer to the contained type, so ConstantBuffer<T> becomes T* in C++ code.\n"
"*/\n"
"\n"
"template <typename T, int COUNT>\n"
"struct Vector;\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 1>\n"
"{\n"
"    T x;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 2>\n"
"{\n"
"    T x, y;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 3>\n"
"{\n"
"    T x, y, z;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 4>\n"
"{\n"
"    T x, y, z, w;\n"
"};\n"
"\n"
"\n"
"typedef Vector<float, 2> float2;\n"
"typedef Vector<float, 3> float3;\n"
"typedef Vector<float, 4> float4;\n"
"\n"
"typedef Vector<int32_t, 2> int2;\n"
"typedef Vector<int32_t, 3> int3;\n"
"typedef Vector<int32_t, 4> int4;\n"
"\n"
"typedef Vector<uint32_t, 2> uint2;\n"
"typedef Vector<uint32_t, 3> uint3;\n"
"typedef Vector<uint32_t, 4> uint4;\n"
"\n"
"template <typename T, int ROWS, int COLS>\n"
"struct Matrix\n"
"{\n"
"    Vector<T, COLS> rows[ROWS];\n"
"};\n"
"\n"
"// We can just map `NonUniformResourceIndex` type directly to the index type on CPU, as CPU does not require\n"
"// any special handling around such accesses.\n"
"typedef size_t NonUniformResourceIndex;\n"
"\n"
"// ----------------------------- ResourceType -----------------------------------------\n"
"\n"
"// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-structuredbuffer-getdimensions\n"
"// Missing  Load(_In_  int  Location, _Out_ uint Status);\n"
"\n"
"template <typename T>\n"
"struct RWStructuredBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }  \n"
"    void GetDimensions(uint32_t* outNumStructs, uint32_t* outStride) { *outNumStructs = uint32_t(count); *outStride = uint32_t(sizeof(T)); }\n"
"  \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct StructuredBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE const T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outNumStructs, uint32_t* outStride) { *outNumStructs = uint32_t(count); *outStride = uint32_t(sizeof(T)); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"\n"
"template <typename T>\n"
"struct RWBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outCount) { *outCount = uint32_t(count); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Buffer\n"
"{\n"
"    SLANG_FORCE_INLINE const T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outCount) { *outCount = uint32_t(count); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"// Missing  Load(_In_  int  Location, _Out_ uint Status);\n"
"struct ByteAddressBuffer\n"
"{\n"
"    void GetDimensions(uint32_t* outDim) const { *outDim = uint32_t(sizeInBytes); }\n"
"    uint32_t Load(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 4 <= sizeInBytes && (index & 3) == 0); \n"
"        return data[index >> 2]; \n"
"    }\n"
"    uint2 Load2(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 8 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint2{data[dataIdx], data[dataIdx + 1]}; \n"
"    }\n"
"    uint3 Load3(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 12 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint3{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2]}; \n"
"    }\n"
"    uint4 Load4(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 16 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint4{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2], data[dataIdx + 3]}; \n"
"    }\n"
"    template<typename T>\n"
"    T Load(size_t offset) const\n"
"    {\n"
"        SLANG_PRELUDE_ASSERT(offset + sizeof(T) <= sizeInBytes && (offset & (alignof(T)-1)) == 0); \n"
"        return *(T const*)((char*)data + offset);\n"
"    }\n"
"    \n"
"    const uint32_t* data;\n"
"    size_t sizeInBytes;  //< Must be multiple of 4\n"
"};\n"
"\n"
"// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-rwbyteaddressbuffer\n"
"// Missing support for Atomic operations \n"
"// Missing support for Load with status\n"
"struct RWByteAddressBuffer\n"
"{\n"
"    void GetDimensions(uint32_t* outDim) const { *outDim = uint32_t(sizeInBytes); }\n"
"    \n"
"    uint32_t Load(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 4 <= sizeInBytes && (index & 3) == 0); \n"
"        return data[index >> 2]; \n"
"    }\n"
"    uint2 Load2(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 8 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint2{data[dataIdx], data[dataIdx + 1]}; \n"
"    }\n"
"    uint3 Load3(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 12 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint3{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2]}; \n"
"    }\n"
"    uint4 Load4(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 16 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint4{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2], data[dataIdx + 3]}; \n"
"    }\n"
"    template<typename T>\n"
"    T Load(size_t offset) const\n"
"    {\n"
"        SLANG_PRELUDE_ASSERT(offset + sizeof(T) <= sizeInBytes && (offset & (alignof(T)-1)) == 0); \n"
"        return *(T const*)((char*)data + offset);\n"
"    }\n"
"\n"
"    void Store(size_t index, uint32_t v) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 4 <= sizeInBytes && (index & 3) == 0); \n"
"        data[index >> 2] = v; \n"
"    }\n"
"    void Store2(size_t index, uint2 v) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 8 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"    }\n"
"    void Store3(size_t index, uint3 v) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 12 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"        data[dataIdx + 2] = v.z;\n"
"    }\n"
"    void Store4(size_t index, uint4 v) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 16 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"        data[dataIdx + 2] = v.z;\n"
"        data[dataIdx + 3] = v.w;\n"
"    }\n"
"    template<typename T>\n"
"    void Store(size_t offset, T const& value) const\n"
"    {\n"
"        SLANG_PRELUDE_ASSERT(offset + sizeof(T) <= sizeInBytes && (offset & (alignof(T)-1)) == 0); \n"
"        *(T*)((char*)data + offset) = value;\n"
"    }\n"
"\n"
"    uint32_t* data;\n"
"    size_t sizeInBytes; //< Must be multiple of 4 \n"
"};\n"
"\n"
"struct ISamplerState;\n"
"struct ISamplerComparisonState;\n"
"\n"
"struct SamplerState\n"
"{\n"
"    ISamplerState* state;\n"
"};\n"
"\n"
"struct SamplerComparisonState\n"
"{\n"
"    ISamplerComparisonState* state;\n"
"};\n"
"\n"
"#ifndef SLANG_RESOURCE_SHAPE\n"
"#    define SLANG_RESOURCE_SHAPE\n"
"typedef unsigned int SlangResourceShape;\n"
"enum\n"
"{\n"
"    SLANG_RESOURCE_BASE_SHAPE_MASK = 0x0F,\n"
"\n"
"    SLANG_RESOURCE_NONE = 0x00,\n"
"\n"
"    SLANG_TEXTURE_1D = 0x01,\n"
"    SLANG_TEXTURE_2D = 0x02,\n"
"    SLANG_TEXTURE_3D = 0x03,\n"
"    SLANG_TEXTURE_CUBE = 0x04,\n"
"    SLANG_TEXTURE_BUFFER = 0x05,\n"
"\n"
"    SLANG_STRUCTURED_BUFFER = 0x06,\n"
"    SLANG_BYTE_ADDRESS_BUFFER = 0x07,\n"
"    SLANG_RESOURCE_UNKNOWN = 0x08,\n"
"    SLANG_ACCELERATION_STRUCTURE = 0x09,\n"
"\n"
"    SLANG_RESOURCE_EXT_SHAPE_MASK = 0xF0,\n"
"\n"
"    SLANG_TEXTURE_FEEDBACK_FLAG = 0x10,\n"
"    SLANG_TEXTURE_ARRAY_FLAG = 0x40,\n"
"    SLANG_TEXTURE_MULTISAMPLE_FLAG = 0x80,\n"
"\n"
"    SLANG_TEXTURE_1D_ARRAY = SLANG_TEXTURE_1D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_2D_ARRAY = SLANG_TEXTURE_2D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_CUBE_ARRAY = SLANG_TEXTURE_CUBE | SLANG_TEXTURE_ARRAY_FLAG,\n"
"\n"
"    SLANG_TEXTURE_2D_MULTISAMPLE = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY =\n"
"        SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG | SLANG_TEXTURE_ARRAY_FLAG,\n"
"};\n"
"#endif\n"
"\n"
"// \n"
"struct TextureDimensions\n"
"{\n"
"    void reset()\n"
"    {\n"
"        shape = 0;\n"
"        width = height = depth = 0;\n"
"        numberOfLevels = 0;\n"
"        arrayElementCount = 0;\n"
"    }\n"
"    int getDimSizes(uint32_t outDims[4]) const\n"
"    {\n"
"        const auto baseShape = (shape & SLANG_RESOURCE_BASE_SHAPE_MASK);\n"
"        int count = 0;\n"
"        switch (baseShape)\n"
"        {\n"
"            case SLANG_TEXTURE_1D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_2D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_3D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = depth;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_CUBE:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = 6;\n"
"                break;\n"
"            }\n"
"        }\n"
"\n"
"        if (shape & SLANG_TEXTURE_ARRAY_FLAG)\n"
"        {\n"
"            outDims[count++] = arrayElementCount;\n"
"        }\n"
"        return count;\n"
"    }\n"
"    int getMIPDims(int outDims[3]) const\n"
"    {\n"
"        const auto baseShape = (shape & SLANG_RESOURCE_BASE_SHAPE_MASK);\n"
"        int count = 0;\n"
"        switch (baseShape)\n"
"        {\n"
"            case SLANG_TEXTURE_1D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_CUBE:\n"
"            case SLANG_TEXTURE_2D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_3D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = depth;\n"
"                break;\n"
"            }\n"
"        }\n"
"        return count;\n"
"    }\n"
"    int calcMaxMIPLevels() const\n"
"    {\n"
"        int dims[3];\n"
"        const int dimCount = getMIPDims(dims);\n"
"        for (int count = 1; true; count++)\n"
"        {\n"
"            bool allOne = true;\n"
"            for (int i = 0; i < dimCount; ++i)\n"
"            {\n"
"                if (dims[i] > 1)\n"
"                {\n"
"                    allOne = false;\n"
"                    dims[i] >>= 1;\n"
"                }\n"
"            }\n"
"            if (allOne)\n"
"            {\n"
"                return count;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    uint32_t shape;\n"
"    uint32_t width, height, depth;\n"
"    uint32_t numberOfLevels;\n"
"    uint32_t arrayElementCount;                  ///< For array types, 0 otherwise\n"
"};\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Texture\n"
"\n"
"struct ITexture\n"
"{\n"
"    virtual TextureDimensions GetDimensions(int mipLevel = -1) = 0;\n"
"    virtual void Load(const int32_t* v, void* outData, size_t dataSize) = 0;\n"
"    virtual void Sample(SamplerState samplerState, const float* loc, void* outData, size_t dataSize) = 0;\n"
"    virtual void SampleLevel(SamplerState samplerState, const float* loc, float level, void* outData, size_t dataSize) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture1D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outNumberOfLevels) \n"
"    { \n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels; \n"
"    }\n"
"    \n"
"    void GetDimensions(float* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outNumberOfLevels) \n"
"    { \n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
;
sb << 
"        *outNumberOfLevels = dims.numberOfLevels; \n"
"    }\n"
"    \n"
"    T Load(const int2& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, float loc) const { T out; texture->Sample(samplerState, &loc, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, float loc, float level) { T out; texture->SampleLevel(samplerState, &loc, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float2& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float2& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture3D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outDepth, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int4& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct TextureCube\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture1DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outElements) { auto dims = texture->GetDimensions(); *outWidth = dims.width; *outElements = dims.arrayElementCount; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outElements, uint32_t* outNumberOfLevels) \n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }        \n"
"    void GetDimensions(float* outWidth, float* outElements) { auto dims = texture->GetDimensions(); *outWidth = dims.width; *outElements = dims.arrayElementCount; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outElements, float* outNumberOfLevels) \n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float2& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float2& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    void GetDimensions(uint32_t* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int4& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct TextureCubeArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    void GetDimensions(uint32_t* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Sample(SamplerState samplerState, const float4& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float4& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"/* !!!!!!!!!!!!!!!!!!!!!!!!!!! RWTexture !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */\n"
"\n"
"struct IRWTexture : ITexture\n"
"{\n"
"        /// Get the reference to the element at loc. \n"
"    virtual void* refAt(const uint32_t* loc) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture1D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outNumberOfLevels) { auto dims = texture->GetDimensions(mipLevel); *outWidth = dims.width; *outNumberOfLevels = dims.numberOfLevels; }\n"
"    \n"
"    void GetDimensions(float* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outNumberOfLevels) { auto dims = texture->GetDimensions(mipLevel); *outWidth = dims.width; *outNumberOfLevels = dims.numberOfLevels; }\n"
"    \n"
"    T Load(int32_t loc) const { T out; texture->Load(&loc, &out, sizeof(out)); return out; }\n"
"    T& operator[](uint32_t loc) { return *(T*)texture->refAt(&loc); }\n"
"    IRWTexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int2& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint2& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture3D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outDepth, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint3& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"\n"
"template <typename T>\n"
"struct RWTexture1DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outElements) \n"
"    { \n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outElements) \n"
"    { \n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(int2 loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](uint2 loc) { return *(T*)texture->refAt(&loc.x); }\n"
"\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint3& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"// FeedbackTexture\n"
"\n"
"struct FeedbackType {};\n"
"struct SAMPLER_FEEDBACK_MIN_MIP : FeedbackType {};\n"
"struct SAMPLER_FEEDBACK_MIP_REGION_USED : FeedbackType {};\n"
"\n"
"struct IFeedbackTexture\n"
"{\n"
"    virtual TextureDimensions GetDimensions(int mipLevel = -1) = 0;\n"
"\n"
"    // Note here we pass the optional clamp parameter as a pointer. Passing nullptr means no clamp. \n"
;
sb << 
"    // This was preferred over having two function definitions, and having to differentiate their names\n"
"    virtual void WriteSamplerFeedback(ITexture* tex, SamplerState samp, const float* location, const float* clamp = nullptr) = 0;\n"
"    virtual void WriteSamplerFeedbackBias(ITexture* tex, SamplerState samp, const float* location, float bias, const float* clamp = nullptr) = 0;\n"
"    virtual void WriteSamplerFeedbackGrad(ITexture* tex, SamplerState samp, const float* location, const float* ddx, const float* ddy, const float* clamp = nullptr) = 0;\n"
"    \n"
"    virtual void WriteSamplerFeedbackLevel(ITexture* tex, SamplerState samp, const float* location, float lod) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct FeedbackTexture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2D<S> tex, SamplerState samp, float2 location, float clamp) { texture->WriteSamplerFeedback(tex.texture, samp, &location.x, &clamp); } \n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2D<S> tex, SamplerState samp, float2 location, float bias, float clamp) { texture->WriteSamplerFeedbackBias(tex.texture, samp, &location.x, bias, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2D<S> tex, SamplerState samp, float2 location, float2 ddx, float2 ddy, float clamp) { texture->WriteSamplerFeedbackGrad(tex.texture, samp, &location.x, &ddx.x, &ddy.x, &clamp); }\n"
"\n"
"    // Level\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackLevel(Texture2D<S> tex, SamplerState samp, float2 location, float lod) { texture->WriteSamplerFeedbackLevel(tex.texture, samp, &location.x, lod); }\n"
"    \n"
"    // Without Clamp\n"
"    template <typename S> \n"
"    void WriteSamplerFeedback(Texture2D<S> tex, SamplerState samp, float2 location) { texture->WriteSamplerFeedback(tex.texture, samp, &location.x); }\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackBias(Texture2D<S> tex, SamplerState samp, float2 location, float bias) { texture->WriteSamplerFeedbackBias(tex.texture, samp, &location.x, bias); }\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackGrad(Texture2D<S> tex, SamplerState samp, float2 location, float2 ddx, float2 ddy) { texture->WriteSamplerFeedbackGrad(tex.texture, samp, &location.x, &ddx.x, &ddy.x); }\n"
"    \n"
"    IFeedbackTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct FeedbackTexture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2DArray<S> texArray, SamplerState samp, float3 location, float clamp) { texture->WriteSamplerFeedback(texArray.texture, samp, &location.x, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2DArray<S> texArray, SamplerState samp, float3 location, float bias, float clamp) { texture->WriteSamplerFeedbackBias(texArray.texture, samp, &location.x, bias, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2DArray<S> texArray, SamplerState samp, float3 location, float3 ddx, float3 ddy, float clamp) { texture->WriteSamplerFeedbackGrad(texArray.texture, samp, &location.x, &ddx.x, &ddy.x, &clamp); }\n"
"\n"
"    // Level\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackLevel(Texture2DArray<S> texArray, SamplerState samp, float3 location, float lod) { texture->WriteSamplerFeedbackLevel(texArray.texture, samp, &location.x, lod); }\n"
"\n"
"    // Without Clamp\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2DArray<S> texArray, SamplerState samp, float3 location) { texture->WriteSamplerFeedback(texArray.texture, samp, &location.x); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2DArray<S> texArray, SamplerState samp, float3 location, float bias) { texture->WriteSamplerFeedbackBias(texArray.texture, samp, &location.x, bias); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2DArray<S> texArray, SamplerState samp, float3 location, float3 ddx, float3 ddy) { texture->WriteSamplerFeedbackGrad(texArray.texture, samp, &location.x, &ddx.x, &ddy.x); }\n"
"    \n"
"    IFeedbackTexture* texture;\n"
"};\n"
"\n"
"/* Varying input for Compute */\n"
"\n"
"/* Used when running a single thread */\n"
"struct ComputeThreadVaryingInput\n"
"{\n"
"    uint3 groupID;\n"
"    uint3 groupThreadID;\n"
"};\n"
"\n"
"struct ComputeVaryingInput\n"
"{\n"
"    uint3 startGroupID;     ///< start groupID\n"
"    uint3 endGroupID;       ///< Non inclusive end groupID\n"
"};\n"
"\n"
"// The uniformEntryPointParams and uniformState must be set to structures that match layout that the kernel expects.\n"
"// This can be determined via reflection for example.\n"
"\n"
"typedef void(*ComputeThreadFunc)(ComputeThreadVaryingInput* varyingInput, void* uniformEntryPointParams, void* uniformState);\n"
"typedef void(*ComputeFunc)(ComputeVaryingInput* varyingInput, void* uniformEntryPointParams, void* uniformState);\n"
"\n"
"template<typename TResult, typename TInput>\n"
"TResult slang_bit_cast(TInput val)\n"
"{\n"
"    return *(TResult*)(&val);\n"
"}\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"#ifndef SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"#define SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"\n"
"#if !defined(SLANG_LLVM) && SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"//  If we have visual studio and 64 bit processor, we can assume we have popcnt, and can include x86 intrinsics\n"
"#   include <intrin.h>\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#    define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE {\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_PI\n"
"#   define SLANG_PRELUDE_PI           3.14159265358979323846\n"
"#endif\n"
"\n"
"// ----------------------------- F32 -----------------------------------------\n"
"\n"
"union Union32 \n"
"{\n"
"    uint32_t u;\n"
"    int32_t i;\n"
"    float f;\n"
"};\n"
"\n"
"union Union64\n"
"{\n"
"    uint64_t u;\n"
"    int64_t i;\n"
"    double d;\n"
"};\n"
"\n"
"// Helpers\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary \n"
"float F32_ceil(float f);\n"
"float F32_floor(float f);\n"
"float F32_round(float f);\n"
"float F32_sin(float f);\n"
"float F32_cos(float f);\n"
"float F32_tan(float f);\n"
"float F32_asin(float f);\n"
"float F32_acos(float f);\n"
"float F32_atan(float f);\n"
"float F32_sinh(float f);\n"
"float F32_cosh(float f);\n"
"float F32_tanh(float f);\n"
"float F32_log2(float f);\n"
"float F32_log(float f);\n"
"float F32_log10(float f);\n"
"float F32_exp2(float f);\n"
"float F32_exp(float f);\n"
"float F32_abs(float f);\n"
"float F32_trunc(float f);\n"
"float F32_sqrt(float f);\n"
"\n"
"bool F32_isnan(float f);\n"
"bool F32_isfinite(float f); \n"
"bool F32_isinf(float f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b) { return a > b ? a : b; }\n"
"float F32_pow(float a, float b);\n"
"float F32_fmod(float a, float b);\n"
"float F32_remainder(float a, float b);\n"
"float F32_atan2(float a, float b);\n"
"\n"
"float F32_frexp(float x, float* e);\n"
"float F32_modf(float x, float* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c) { return a * b + c; }\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else\n"
"\n"
"// Unary \n"
"SLANG_FORCE_INLINE float F32_ceil(float f) { return ::ceilf(f); }\n"
"SLANG_FORCE_INLINE float F32_floor(float f) { return ::floorf(f); }\n"
"SLANG_FORCE_INLINE float F32_round(float f) { return ::roundf(f); }\n"
"SLANG_FORCE_INLINE float F32_sin(float f) { return ::sinf(f); }\n"
"SLANG_FORCE_INLINE float F32_cos(float f) { return ::cosf(f); }\n"
"SLANG_FORCE_INLINE float F32_tan(float f) { return ::tanf(f); }\n"
"SLANG_FORCE_INLINE float F32_asin(float f) { return ::asinf(f); }\n"
"SLANG_FORCE_INLINE float F32_acos(float f) { return ::acosf(f); }\n"
"SLANG_FORCE_INLINE float F32_atan(float f) { return ::atanf(f); }\n"
"SLANG_FORCE_INLINE float F32_sinh(float f) { return ::sinhf(f); }\n"
"SLANG_FORCE_INLINE float F32_cosh(float f) { return ::coshf(f); }\n"
"SLANG_FORCE_INLINE float F32_tanh(float f) { return ::tanhf(f); }\n"
"SLANG_FORCE_INLINE float F32_log2(float f) { return ::log2f(f); }\n"
"SLANG_FORCE_INLINE float F32_log(float f) { return ::logf(f); }\n"
"SLANG_FORCE_INLINE float F32_log10(float f) { return ::log10f(f); }\n"
"SLANG_FORCE_INLINE float F32_exp2(float f) { return ::exp2f(f); }\n"
"SLANG_FORCE_INLINE float F32_exp(float f) { return ::expf(f); }\n"
"SLANG_FORCE_INLINE float F32_abs(float f) { return ::fabsf(f); }\n"
"SLANG_FORCE_INLINE float F32_trunc(float f) { return ::truncf(f); }\n"
"SLANG_FORCE_INLINE float F32_sqrt(float f) { return ::sqrtf(f); }\n"
"\n"
"SLANG_FORCE_INLINE bool F32_isnan(float f) { return SLANG_PRELUDE_STD isnan(f); }\n"
"SLANG_FORCE_INLINE bool F32_isfinite(float f) { return SLANG_PRELUDE_STD isfinite(f); }\n"
"SLANG_FORCE_INLINE bool F32_isinf(float f) { return SLANG_PRELUDE_STD isinf(f); }\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b) { return ::fminf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b) { return ::fmaxf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_pow(float a, float b) { return ::powf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_fmod(float a, float b) { return ::fmodf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_remainder(float a, float b) { return ::remainderf(a, b); }\n"
"SLANG_FORCE_INLINE float F32_atan2(float a, float b) { return float(::atan2(a, b)); }\n"
"\n"
"SLANG_FORCE_INLINE float F32_frexp(float x, float* e)\n"
"{\n"
"    int ei;\n"
"    float m = ::frexpf(x, &ei);\n"
"    *e = float(ei);\n"
"    return m;\n"
"}\n"
"SLANG_FORCE_INLINE float F32_modf(float x, float* ip)\n"
"{\n"
"    return ::modff(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c) { return ::fmaf(a, b, c); }\n"
"\n"
"#endif\n"
"\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1 \n"
"\tfloat a = radians * (1.0f /  float(SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F32_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"\treturn (a * float(SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_rsqrt(float f) { return 1.0f / F32_sqrt(f); }\n"
"SLANG_FORCE_INLINE float F32_sign(float f) { return ( f == 0.0f) ? f : (( f < 0.0f) ? -1.0f : 1.0f); } \n"
"SLANG_FORCE_INLINE float F32_frac(float f) { return f - F32_floor(f); }\n"
"\n"
"SLANG_FORCE_INLINE uint32_t F32_asuint(float f) { Union32 u; u.f = f; return u.u; }\n"
"SLANG_FORCE_INLINE int32_t F32_asint(float f) { Union32 u; u.f = f; return u.i; }\n"
"\n"
"// ----------------------------- F64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary \n"
"double F64_ceil(double f);\n"
"double F64_floor(double f);\n"
"double F64_round(double f);\n"
"double F64_sin(double f);\n"
"double F64_cos(double f);\n"
"double F64_tan(double f);\n"
"double F64_asin(double f);\n"
"double F64_acos(double f);\n"
"double F64_atan(double f);\n"
"double F64_sinh(double f);\n"
"double F64_cosh(double f);\n"
"double F64_tanh(double f);\n"
"double F64_log2(double f);\n"
"double F64_log(double f);\n"
"double F64_log10(float f);\n"
"double F64_exp2(double f);\n"
"double F64_exp(double f);\n"
"double F64_abs(double f);\n"
"double F64_trunc(double f);\n"
"double F64_sqrt(double f);\n"
"\n"
"bool F64_isnan(double f);\n"
"bool F64_isfinite(double f);\n"
"bool F64_isinf(double f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b) { return a > b ? a : b; }\n"
"double F64_pow(double a, double b);\n"
"double F64_fmod(double a, double b);\n"
"double F64_remainder(double a, double b);\n"
"double F64_atan2(double a, double b);\n"
"\n"
"double F64_frexp(double x, double* e);\n"
"\n"
"double F64_modf(double x, double* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c) { return a * b + c; }\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"// Unary \n"
"SLANG_FORCE_INLINE double F64_ceil(double f) { return ::ceil(f); }\n"
"SLANG_FORCE_INLINE double F64_floor(double f) { return ::floor(f); }\n"
"SLANG_FORCE_INLINE double F64_round(double f) { return ::round(f); }\n"
"SLANG_FORCE_INLINE double F64_sin(double f) { return ::sin(f); }\n"
"SLANG_FORCE_INLINE double F64_cos(double f) { return ::cos(f); }\n"
"SLANG_FORCE_INLINE double F64_tan(double f) { return ::tan(f); }\n"
"SLANG_FORCE_INLINE double F64_asin(double f) { return ::asin(f); }\n"
"SLANG_FORCE_INLINE double F64_acos(double f) { return ::acos(f); }\n"
"SLANG_FORCE_INLINE double F64_atan(double f) { return ::atan(f); }\n"
"SLANG_FORCE_INLINE double F64_sinh(double f) { return ::sinh(f); }\n"
"SLANG_FORCE_INLINE double F64_cosh(double f) { return ::cosh(f); }\n"
"SLANG_FORCE_INLINE double F64_tanh(double f) { return ::tanh(f); }\n"
"SLANG_FORCE_INLINE double F64_log2(double f) { return ::log2(f); }\n"
"SLANG_FORCE_INLINE double F64_log(double f) { return ::log(f); }\n"
"SLANG_FORCE_INLINE double F64_log10(float f) { return ::log10(f); }\n"
"SLANG_FORCE_INLINE double F64_exp2(double f) { return ::exp2(f); }\n"
"SLANG_FORCE_INLINE double F64_exp(double f) { return ::exp(f); }\n"
"SLANG_FORCE_INLINE double F64_abs(double f) { return ::fabs(f); }\n"
"SLANG_FORCE_INLINE double F64_trunc(double f) { return ::trunc(f); }\n"
"SLANG_FORCE_INLINE double F64_sqrt(double f) { return ::sqrt(f); }\n"
"\n"
"\n"
"SLANG_FORCE_INLINE bool F64_isnan(double f) { return SLANG_PRELUDE_STD isnan(f); }\n"
"SLANG_FORCE_INLINE bool F64_isfinite(double f) { return SLANG_PRELUDE_STD isfinite(f); }\n"
"SLANG_FORCE_INLINE bool F64_isinf(double f) { return SLANG_PRELUDE_STD isinf(f); }\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b) { return ::fmin(a, b); }\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b) { return ::fmax(a, b); }\n"
"SLANG_FORCE_INLINE double F64_pow(double a, double b) { return ::pow(a, b); }\n"
"SLANG_FORCE_INLINE double F64_fmod(double a, double b) { return ::fmod(a, b); }\n"
"SLANG_FORCE_INLINE double F64_remainder(double a, double b) { return ::remainder(a, b); }\n"
"SLANG_FORCE_INLINE double F64_atan2(double a, double b) { return ::atan2(a, b); }\n"
"\n"
"SLANG_FORCE_INLINE double F64_frexp(double x, double* e)\n"
"{\n"
"    int ei;\n"
"    double m = ::frexp(x, &ei);\n"
"    *e = float(ei);\n"
"    return m;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_modf(double x, double* ip)\n"
"{\n"
"    return ::modf(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c) { return ::fma(a, b, c); }\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"SLANG_FORCE_INLINE double F64_rsqrt(double f) { return 1.0 / F64_sqrt(f); }\n"
"SLANG_FORCE_INLINE double F64_sign(double f) { return (f == 0.0) ? f : ((f < 0.0) ? -1.0 : 1.0); }\n"
"SLANG_FORCE_INLINE double F64_frac(double f) { return f - F64_floor(f); }\n"
"\n"
"SLANG_FORCE_INLINE void F64_asuint(double d, uint32_t* low, uint32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = uint32_t(u.u);\n"
"    *hi = uint32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE void F64_asint(double d, int32_t* low, int32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = int32_t(u.u);\n"
"    *hi = int32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1 \n"
"\tdouble a = radians * (1.0f /  (SLANG_PRELUDE_PI * 2));\n"
;
sb << 
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F64_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"\treturn (a * (SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"// ----------------------------- I32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_abs(int32_t f) { return (f < 0) ? -f : f; }\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_min(int32_t a, int32_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE int32_t I32_max(int32_t a, int32_t b) { return a > b ? a : b; }\n"
"\n"
"SLANG_FORCE_INLINE float I32_asfloat(int32_t x) { Union32 u; u.i = x; return u.f; }\n"
"SLANG_FORCE_INLINE uint32_t I32_asuint(int32_t x) { return uint32_t(x); }\n"
"SLANG_FORCE_INLINE double I32_asdouble(int32_t low, int32_t hi )\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | uint32_t(low);\n"
"    return u.d;\n"
"}\n"
"\n"
"// ----------------------------- U32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_abs(uint32_t f) { return f; }\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_min(uint32_t a, uint32_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE uint32_t U32_max(uint32_t a, uint32_t b) { return a > b ? a : b; }\n"
"\n"
"SLANG_FORCE_INLINE float U32_asfloat(uint32_t x) { Union32 u; u.u = x; return u.f; }\n"
"SLANG_FORCE_INLINE uint32_t U32_asint(int32_t x) { return uint32_t(x); } \n"
"\n"
"SLANG_FORCE_INLINE double U32_asdouble(uint32_t low, uint32_t hi)\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | low;\n"
"    return u.d;\n"
"}\n"
"\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_countbits(uint32_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    return __builtin_popcount(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return __popcnt(v);\n"
"#else     \n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- U64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_abs(uint64_t f) { return f; }\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_min(uint64_t a, uint64_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE uint64_t U64_max(uint64_t a, uint64_t b) { return a > b ? a : b; }\n"
"\n"
"// TODO(JS): We don't define countbits for 64bit in stdlib currently.\n"
"// It's not clear from documentation if it should return 32 or 64 bits, if it exists. \n"
"// 32 bits can always hold the result, and will be implicitly promoted. \n"
"SLANG_FORCE_INLINE uint32_t U64_countbits(uint64_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)   \n"
"    return uint32_t(__builtin_popcountl(v));\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return uint32_t(__popcnt64(v));\n"
"#else     \n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_abs(int64_t f) { return (f < 0) ? -f : f; }\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_min(int64_t a, int64_t b) { return a < b ? a : b; }\n"
"SLANG_FORCE_INLINE int64_t I64_max(int64_t a, int64_t b) { return a > b ? a : b; }\n"
"\n"
"\n"
"// ----------------------------- Interlocked ---------------------------------\n"
"\n"
"#if SLANG_LLVM\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"#   ifdef _WIN32\n"
"#       include <intrin.h>\n"
"#   endif\n"
"\n"
"void InterlockedAdd(uint32_t* dest, uint32_t value, uint32_t* oldValue)\n"
"{\n"
"#   ifdef _WIN32\n"
"    *oldValue = _InterlockedExchangeAdd((long*)dest, (long)value);\n"
"#   else\n"
"    *oldValue = __sync_fetch_and_add(dest, value);\n"
"#   endif\n"
"}\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"} \n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"\n"
"// TODO(JS): Hack! Output C++ code from slang can copy uninitialized variables. \n"
"#if defined(_MSC_VER)\n"
"#   pragma warning(disable : 4700)\n"
"#endif\n"
"\n"
"#ifndef SLANG_UNROLL\n"
"#   define SLANG_UNROLL\n"
"#endif\n"
"\n"
"#endif\n"
;
return sb.ProduceString();
}
