// generated code; do not edit
#include "../source/core/slang-basic.h"
Slang::String get_slang_cpp_host_prelude()
{
Slang::StringBuilder sb;
sb << 
"#ifndef SLANG_CPP_HOST_PRELUDE_H\n"
"#define SLANG_CPP_HOST_PRELUDE_H\n"
"\n"
"#include <cstdio>\n"
"#include <cmath>\n"
"#include <cstring>\n"
"\n"
"// slang-rt.h\n"
"#ifndef SLANG_RT_H\n"
"#define SLANG_RT_H\n"
"\n"
"#ifndef SLANG_CORE_STRING_H\n"
"#define SLANG_CORE_STRING_H\n"
"\n"
"#include <string.h>\n"
"#include <cstdlib>\n"
"#include <stdio.h>\n"
"\n"
"#ifndef SLANG_CORE_SMART_POINTER_H\n"
"#define SLANG_CORE_SMART_POINTER_H\n"
"\n"
"#ifndef SLANG_CORE_COMMON_H\n"
"#define SLANG_CORE_COMMON_H\n"
"\n"
"#ifndef SLANG_H\n"
"#define SLANG_H\n"
"\n"
"/** \\file slang.h\n"
"\n"
"The Slang API provides services to compile, reflect, and specialize code\n"
"written in the Slang shading language.\n"
"*/\n"
"\n"
"/*\n"
"The following section attempts to detect the compiler and version in use.\n"
"\n"
"If an application defines `SLANG_COMPILER` before including this header,\n"
"they take responsibility for setting any compiler-dependent macros\n"
"used later in the file.\n"
"\n"
"Most applications should not need to touch this section.\n"
"*/\n"
"#ifndef SLANG_COMPILER\n"
"#    define SLANG_COMPILER\n"
"\n"
"/*\n"
"Compiler defines, see http://sourceforge.net/p/predef/wiki/Compilers/\n"
"NOTE that SLANG_VC holds the compiler version - not just 1 or 0\n"
"*/\n"
"#    if defined(_MSC_VER)\n"
"#        if _MSC_VER >= 1900\n"
"#            define SLANG_VC 14\n"
"#        elif _MSC_VER >= 1800\n"
"#            define SLANG_VC 12\n"
"#        elif _MSC_VER >= 1700\n"
"#            define SLANG_VC 11\n"
"#        elif _MSC_VER >= 1600\n"
"#            define SLANG_VC 10\n"
"#        elif _MSC_VER >= 1500\n"
"#            define SLANG_VC 9\n"
"#        else\n"
"#            error \"unknown version of Visual C++ compiler\"\n"
"#        endif\n"
"#    elif defined(__clang__)\n"
"#        define SLANG_CLANG 1\n"
"#    elif defined(__SNC__)\n"
"#        define SLANG_SNC 1\n"
"#    elif defined(__ghs__)\n"
"#        define SLANG_GHS 1\n"
"#    elif defined(__GNUC__) /* note: __clang__, __SNC__, or __ghs__ imply __GNUC__ */\n"
"#        define SLANG_GCC 1\n"
"#    else\n"
"#        error \"unknown compiler\"\n"
"#    endif\n"
"/*\n"
"Any compilers not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#    ifndef SLANG_VC\n"
"#        define SLANG_VC 0\n"
"#    endif\n"
"#    ifndef SLANG_CLANG\n"
"#        define SLANG_CLANG 0\n"
"#    endif\n"
"#    ifndef SLANG_SNC\n"
"#        define SLANG_SNC 0\n"
"#    endif\n"
"#    ifndef SLANG_GHS\n"
"#        define SLANG_GHS 0\n"
"#    endif\n"
"#    ifndef SLANG_GCC\n"
"#        define SLANG_GCC 0\n"
"#    endif\n"
"#endif /* SLANG_COMPILER */\n"
"\n"
"/*\n"
"The following section attempts to detect the target platform being compiled for.\n"
"\n"
"If an application defines `SLANG_PLATFORM` before including this header,\n"
"they take responsibility for setting any compiler-dependent macros\n"
"used later in the file.\n"
"\n"
"Most applications should not need to touch this section.\n"
"*/\n"
"#ifndef SLANG_PLATFORM\n"
"#    define SLANG_PLATFORM\n"
"/**\n"
"Operating system defines, see http://sourceforge.net/p/predef/wiki/OperatingSystems/\n"
"*/\n"
"#    if defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_PARTITION_APP\n"
"#        define SLANG_WINRT 1 /* Windows Runtime, either on Windows RT or Windows 8 */\n"
"#    elif defined(XBOXONE)\n"
"#        define SLANG_XBOXONE 1\n"
"#    elif defined(_WIN64) /* note: XBOXONE implies _WIN64 */\n"
"#        define SLANG_WIN64 1\n"
"#    elif defined(_M_PPC)\n"
"#        define SLANG_X360 1\n"
"#    elif defined(_WIN32) /* note: _M_PPC implies _WIN32 */\n"
"#        define SLANG_WIN32 1\n"
"#    elif defined(__ANDROID__)\n"
"#        define SLANG_ANDROID 1\n"
"#    elif defined(__linux__) || defined(__CYGWIN__) /* note: __ANDROID__ implies __linux__ */\n"
"#        define SLANG_LINUX 1\n"
"#    elif defined(__APPLE__)\n"
"#        include \"TargetConditionals.h\"\n"
"#        if TARGET_OS_MAC\n"
"#            define SLANG_OSX 1\n"
"#        else\n"
"#            define SLANG_IOS 1\n"
"#        endif\n"
"#    elif defined(__CELLOS_LV2__)\n"
"#        define SLANG_PS3 1\n"
"#    elif defined(__ORBIS__)\n"
"#        define SLANG_PS4 1\n"
"#    elif defined(__SNC__) && defined(__arm__)\n"
"#        define SLANG_PSP2 1\n"
"#    elif defined(__ghs__)\n"
"#        define SLANG_WIIU 1\n"
"#    else\n"
"#        error \"unknown target platform\"\n"
"#    endif\n"
"/*\n"
"Any platforms not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#    ifndef SLANG_WINRT\n"
"#        define SLANG_WINRT 0\n"
"#    endif\n"
"#    ifndef SLANG_XBOXONE\n"
"#        define SLANG_XBOXONE 0\n"
"#    endif\n"
"#    ifndef SLANG_WIN64\n"
"#        define SLANG_WIN64 0\n"
"#    endif\n"
"#    ifndef SLANG_X360\n"
"#        define SLANG_X360 0\n"
"#    endif\n"
"#    ifndef SLANG_WIN32\n"
"#        define SLANG_WIN32 0\n"
"#    endif\n"
"#    ifndef SLANG_ANDROID\n"
"#        define SLANG_ANDROID 0\n"
"#    endif\n"
"#    ifndef SLANG_LINUX\n"
"#        define SLANG_LINUX 0\n"
"#    endif\n"
"#    ifndef SLANG_IOS\n"
"#        define SLANG_IOS 0\n"
"#    endif\n"
"#    ifndef SLANG_OSX\n"
"#        define SLANG_OSX 0\n"
"#    endif\n"
"#    ifndef SLANG_PS3\n"
"#        define SLANG_PS3 0\n"
"#    endif\n"
"#    ifndef SLANG_PS4\n"
"#        define SLANG_PS4 0\n"
"#    endif\n"
"#    ifndef SLANG_PSP2\n"
"#        define SLANG_PSP2 0\n"
"#    endif\n"
"#    ifndef SLANG_WIIU\n"
"#        define SLANG_WIIU 0\n"
"#    endif\n"
"#endif /* SLANG_PLATFORM */\n"
"\n"
"/* Shorthands for \"families\" of compilers/platforms */\n"
"#define SLANG_GCC_FAMILY (SLANG_CLANG || SLANG_SNC || SLANG_GHS || SLANG_GCC)\n"
"#define SLANG_WINDOWS_FAMILY (SLANG_WINRT || SLANG_WIN32 || SLANG_WIN64)\n"
"#define SLANG_MICROSOFT_FAMILY (SLANG_XBOXONE || SLANG_X360 || SLANG_WINDOWS_FAMILY)\n"
"#define SLANG_LINUX_FAMILY (SLANG_LINUX || SLANG_ANDROID)\n"
"#define SLANG_APPLE_FAMILY (SLANG_IOS || SLANG_OSX)                  /* equivalent to #if __APPLE__ */\n"
"#define SLANG_UNIX_FAMILY (SLANG_LINUX_FAMILY || SLANG_APPLE_FAMILY) /* shortcut for unix/posix platforms */\n"
"\n"
"/* Macro for declaring if a method is no throw. Should be set before the return parameter. */\n"
"#ifndef SLANG_NO_THROW\n"
"#   if SLANG_WINDOWS_FAMILY && !defined(SLANG_DISABLE_EXCEPTIONS)\n"
"#       define SLANG_NO_THROW __declspec(nothrow)\n"
"#   endif\n"
"#endif\n"
"#ifndef SLANG_NO_THROW\n"
"#   define SLANG_NO_THROW\n"
"#endif\n"
"\n"
"/* The `SLANG_STDCALL` and `SLANG_MCALL` defines are used to set the calling\n"
"convention for interface methods.\n"
"*/\n"
"#ifndef SLANG_STDCALL\n"
"#   if SLANG_MICROSOFT_FAMILY\n"
"#       define SLANG_STDCALL __stdcall\n"
"#   else\n"
"#       define SLANG_STDCALL\n"
"#   endif\n"
"#endif\n"
"#ifndef SLANG_MCALL\n"
"#   define SLANG_MCALL SLANG_STDCALL\n"
"#endif\n"
"\n"
"\n"
"#if !defined(SLANG_STATIC) && !defined(SLANG_STATIC)\n"
"    #define SLANG_DYNAMIC\n"
"#endif\n"
"\n"
"#if defined(_MSC_VER)\n"
"#   define SLANG_DLL_EXPORT __declspec(dllexport)\n"
"#else\n"
"#   if 0 && __GNUC__ >= 4\n"
"// Didn't work on latest gcc on linux.. so disable for now\n"
"// https://gcc.gnu.org/wiki/Visibility\n"
"#       define SLANG_DLL_EXPORT __attribute__ ((dllexport))\n"
"#   else\n"
"#       define SLANG_DLL_EXPORT __attribute__((__visibility__(\"default\")))\n"
"#   endif\n"
"#endif\n"
"\n"
"#if defined(SLANG_DYNAMIC)\n"
"#   if defined(_MSC_VER)\n"
"#       ifdef SLANG_DYNAMIC_EXPORT\n"
"#           define SLANG_API SLANG_DLL_EXPORT\n"
"#       else\n"
"#           define SLANG_API __declspec(dllimport)\n"
"#       endif\n"
"#   else\n"
"        // TODO: need to consider compiler capabilities\n"
"//#     ifdef SLANG_DYNAMIC_EXPORT\n"
"#       define SLANG_API SLANG_DLL_EXPORT \n"
"//#     endif\n"
"#   endif\n"
"#endif\n"
"\n"
"#ifndef SLANG_API\n"
"#   define SLANG_API\n"
"#endif\n"
"\n"
"// GCC Specific\n"
"#if SLANG_GCC_FAMILY\n"
"// This doesn't work on clang - because the typedef is seen as multiply defined, use the line numbered version defined later\n"
"#\tif !defined(__clang__) && (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)) || defined(__ORBIS__))\n"
"#\t\tdefine SLANG_COMPILE_TIME_ASSERT(exp) typedef char SlangCompileTimeAssert_Dummy[(exp) ? 1 : -1] __attribute__((unused))\n"
"#\tendif\n"
"\n"
"#\tdefine SLANG_NO_INLINE __attribute__((noinline))\n"
"#\tdefine SLANG_FORCE_INLINE inline __attribute__((always_inline))\n"
"#   define SLANG_BREAKPOINT(id) __builtin_trap();\n"
"#\tdefine SLANG_ALIGN_OF(T)\t__alignof__(T)\n"
"\n"
"// Use this macro instead of offsetof, because gcc produces warning if offsetof is used on a \n"
"// non POD type, even though it produces the correct result\n"
"#   define SLANG_OFFSET_OF(T, ELEMENT) (size_t(&((T*)1)->ELEMENT) - 1)\n"
"#endif // SLANG_GCC_FAMILY\n"
"\n"
"// Microsoft VC specific\n"
"#if SLANG_MICROSOFT_FAMILY\n"
"#\tdefine SLANG_NO_INLINE __declspec(noinline)\n"
"#\tdefine SLANG_FORCE_INLINE __forceinline\n"
"#\tdefine SLANG_BREAKPOINT(id) __debugbreak();\n"
"#\tdefine SLANG_ALIGN_OF(T) __alignof(T)\n"
"\n"
"#   define SLANG_INT64(x) (x##i64)\n"
"#   define SLANG_UINT64(x) (x##ui64)\n"
"#endif // SLANG_MICROSOFT_FAMILY\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#\tdefine SLANG_FORCE_INLINE inline\n"
"#endif\n"
"#ifndef SLANG_NO_INLINE\n"
"#\tdefine SLANG_NO_INLINE\n"
"#endif\n"
"\n"
"#ifndef SLANG_COMPILE_TIME_ASSERT\n"
"#\tdefine SLANG_COMPILE_TIME_ASSERT(exp) typedef char SLANG_CONCAT(SlangCompileTimeAssert,__LINE__)[(exp) ? 1 : -1]\n"
"#endif\n"
"\n"
"#ifndef SLANG_OFFSET_OF\n"
"#\tdefine SLANG_OFFSET_OF(X, Y) offsetof(X, Y)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BREAKPOINT\n"
"// Make it crash with a write to 0!\n"
"#   define SLANG_BREAKPOINT(id) (*((int*)0) = int(id));\n"
"#endif\n"
"\n"
"// Use for getting the amount of members of a standard C array.\n"
"#define SLANG_COUNT_OF(x) (sizeof(x)/sizeof(x[0]))\n"
"/// SLANG_INLINE exists to have a way to inline consistent with SLANG_ALWAYS_INLINE\n"
"#define SLANG_INLINE inline\n"
"\n"
"// If explicilty disabled and not set, set to not available\n"
"#if !defined(SLANG_HAS_EXCEPTIONS) && defined(SLANG_DISABLE_EXCEPTIONS)\n"
"#   define SLANG_HAS_EXCEPTIONS 0\n"
"#endif\n"
"\n"
"// If not set, the default is exceptions are available\n"
"#ifndef SLANG_HAS_EXCEPTIONS\n"
"#   define SLANG_HAS_EXCEPTIONS 1\n"
"#endif\n"
"\n"
"// Other defines\n"
"#define SLANG_STRINGIZE_HELPER(X) #X\n"
"#define SLANG_STRINGIZE(X) SLANG_STRINGIZE_HELPER(X)\n"
"\n"
"#define SLANG_CONCAT_HELPER(X, Y) X##Y\n"
"#define SLANG_CONCAT(X, Y) SLANG_CONCAT_HELPER(X, Y)\n"
"\n"
"#ifndef SLANG_UNUSED\n"
"#\tdefine SLANG_UNUSED(v) (void)v;\n"
"#endif\n"
"\n"
"// Used for doing constant literals\n"
"#ifndef SLANG_INT64\n"
"#\tdefine SLANG_INT64(x) (x##ll)\n"
"#endif\n"
"#ifndef SLANG_UINT64\n"
"#\tdefine SLANG_UINT64(x) (x##ull)\n"
"#endif\n"
"\n"
"\n"
"#ifdef __cplusplus\n"
"#   define SLANG_EXTERN_C extern \"C\"\n"
"#else\n"
"#   define SLANG_EXTERN_C\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"// C++ specific macros\n"
"// Clang\n"
"#if SLANG_CLANG\n"
"#    if (__clang_major__*10 + __clang_minor__) >= 33\n"
"#       define SLANG_HAS_MOVE_SEMANTICS 1\n"
"#       define SLANG_HAS_ENUM_CLASS 1\n"
"#       define SLANG_OVERRIDE override\n"
"#    endif\n"
"\n"
"// Gcc\n"
"#elif SLANG_GCC_FAMILY\n"
"// Check for C++11\n"
"#\t\tif (__cplusplus >= 201103L)\n"
"#\t\t\tif (__GNUC__ * 100 + __GNUC_MINOR__) >= 405\n"
"#\t\t\t\tdefine SLANG_HAS_MOVE_SEMANTICS 1\n"
"#\t\t\tendif\n"
"#\t\t\tif (__GNUC__ * 100 + __GNUC_MINOR__) >= 406\n"
"#\t\t\t\tdefine SLANG_HAS_ENUM_CLASS 1\n"
"#\t\t\tendif\n"
"#\t\t\tif (__GNUC__ * 100 + __GNUC_MINOR__) >= 407\n"
"#\t\t\t\tdefine SLANG_OVERRIDE override\n"
"#\t\t\tendif\n"
"#\t\tendif\n"
"\n"
"// TODO(JS): Not used in previous code. Left here as may be useful on some other version. \n"
"// #define SLANG_RETURN_NEVER __attribute__((__noreturn__))\n"
"\n"
"#       define SLANG_RETURN_NEVER [[noreturn]]\n"
"\n"
"#\tendif // SLANG_GCC_FAMILY\n"
"\n"
"// Visual Studio\n"
"\n"
"#\tif SLANG_VC\n"
"// C4481: nonstandard extension used: override specifier 'override'\n"
"#\t\tif _MSC_VER < 1700\n"
"#\t\t\tpragma warning(disable : 4481)\n"
"#\t\tendif\n"
"#\t\tdefine SLANG_OVERRIDE\toverride\n"
"#\t\tif _MSC_VER >= 1600\n"
"#\t\t\tdefine SLANG_HAS_MOVE_SEMANTICS 1\n"
"#\t\tendif\n"
"#\t    if _MSC_VER >= 1700\n"
"#\t\t    define SLANG_HAS_ENUM_CLASS 1\n"
"#       endif\n"
"\n"
"#   define SLANG_RETURN_NEVER __declspec(noreturn)\n"
"\n"
"#   endif // SLANG_VC\n"
"\n"
"// Set non set\n"
"#   ifndef SLANG_OVERRIDE\n"
"#\t    define SLANG_OVERRIDE\n"
"#   endif\n"
"#   ifndef SLANG_HAS_ENUM_CLASS\n"
"#\t    define SLANG_HAS_ENUM_CLASS 0\n"
"#   endif\n"
"#   ifndef SLANG_HAS_MOVE_SEMANTICS\n"
"#\t    define SLANG_HAS_MOVE_SEMANTICS 0\n"
"#   endif\n"
"\n"
"#endif // __cplusplus\n"
"\n"
"#ifndef SLANG_RETURN_NEVER\n"
"#   define SLANG_RETURN_NEVER /* empty */\n"
"#endif // SLANG_RETURN_NEVER\n"
"\n"
"/* Macros for detecting processor */\n"
"#if defined(_M_ARM) || defined(__ARM_EABI__)\n"
"// This is special case for nVidia tegra\n"
"#   define SLANG_PROCESSOR_ARM 1\n"
"#elif defined(__i386__) || defined(_M_IX86)\n"
"#   define SLANG_PROCESSOR_X86 1\n"
"#elif defined(_M_AMD64) || defined(_M_X64) || defined(__amd64) || defined(__x86_64)\n"
"#   define SLANG_PROCESSOR_X86_64 1\n"
"#elif defined(_PPC_) || defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC)\n"
"#   if defined(__powerpc64__) || defined(__ppc64__) || defined(__PPC64__) || defined(__64BIT__) || defined(_LP64) || defined(__LP64__)\n"
"#       define SLANG_PROCESSOR_POWER_PC_64 1\n"
"#   else\n"
"#       define SLANG_PROCESSOR_POWER_PC 1\n"
"#   endif\n"
"#elif defined(__arm__)\n"
"#   define SLANG_PROCESSOR_ARM 1\n"
"#elif defined(_M_ARM64) || defined(__aarch64__)\n"
"#   define SLANG_PROCESSOR_ARM_64 1\n"
"#endif \n"
"\n"
"#ifndef SLANG_PROCESSOR_ARM\n"
"#   define SLANG_PROCESSOR_ARM 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_ARM_64\n"
"#   define SLANG_PROCESSOR_ARM_64 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_X86\n"
"#   define SLANG_PROCESSOR_X86 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_X86_64\n"
"#   define SLANG_PROCESSOR_X86_64 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_POWER_PC\n"
"#   define SLANG_PROCESSOR_POWER_PC 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_POWER_PC_64\n"
"#   define SLANG_PROCESSOR_POWER_PC_64 0\n"
"#endif\n"
"\n"
"// Processor families\n"
"\n"
"#define SLANG_PROCESSOR_FAMILY_X86 (SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_X86)\n"
"#define SLANG_PROCESSOR_FAMILY_ARM (SLANG_PROCESSOR_ARM | SLANG_PROCESSOR_ARM_64)\n"
"#define SLANG_PROCESSOR_FAMILY_POWER_PC (SLANG_PROCESSOR_POWER_PC_64 | SLANG_PROCESSOR_POWER_PC)\n"
"\n"
"// Pointer size\n"
"#define SLANG_PTR_IS_64 (SLANG_PROCESSOR_ARM_64 | SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_POWER_PC_64)\n"
"#define SLANG_PTR_IS_32 (SLANG_PTR_IS_64 ^ 1)\n"
"\n"
"// Processor features\n"
"#if SLANG_PROCESSOR_FAMILY_X86\n"
"#   define SLANG_LITTLE_ENDIAN 1\n"
"#   define SLANG_UNALIGNED_ACCESS 1\n"
"#elif SLANG_PROCESSOR_FAMILY_ARM\n"
"#   if defined(__ARMEB__)\n"
"#       define SLANG_BIG_ENDIAN 1\n"
"#   else\n"
"#       define SLANG_LITTLE_ENDIAN 1\n"
"#   endif\n"
"#elif SLANG_PROCESSOR_FAMILY_POWER_PC\n"
"#       define SLANG_BIG_ENDIAN 1\n"
"#endif\n"
"\n"
"#ifndef SLANG_LITTLE_ENDIAN\n"
"#   define SLANG_LITTLE_ENDIAN 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_BIG_ENDIAN\n"
"#   define SLANG_BIG_ENDIAN 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_UNALIGNED_ACCESS\n"
"#   define SLANG_UNALIGNED_ACCESS 0\n"
"#endif\n"
"\n"
"// One endianess must be set\n"
"#if ((SLANG_BIG_ENDIAN | SLANG_LITTLE_ENDIAN) == 0)\n"
"#   error \"Couldn't determine endianess\"\n"
"#endif\n"
"\n"
"#ifndef  SLANG_NO_INTTYPES\n"
"#include <inttypes.h>\n"
"#endif // ! SLANG_NO_INTTYPES\n"
"\n"
"#ifndef  SLANG_NO_STDDEF\n"
"#include <stddef.h>\n"
"#endif // ! SLANG_NO_STDDEF\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\"\n"
"{\n"
"#endif\n"
"    /*!\n"
"    @mainpage Introduction\n"
"\n"
"    API Reference: slang.h\n"
"\n"
"    @file slang.h\n"
"    */\n"
"\n"
"    typedef uint32_t    SlangUInt32;\n"
"    typedef int32_t     SlangInt32;\n"
"\n"
"    // Use SLANG_PTR_ macros to determine SlangInt/SlangUInt types.\n"
"    // This is used over say using size_t/ptrdiff_t/intptr_t/uintptr_t, because on some targets, these types are distinct from\n"
"    // their uint_t/int_t equivalents and so produce ambiguity with function overloading.\n"
"    //\n"
"    // SlangSizeT is helpful as on some compilers size_t is distinct from a regular integer type and so overloading doesn't work.\n"
"    // Casting to SlangSizeT works around this.\n"
"#if SLANG_PTR_IS_64\n"
"    typedef int64_t    SlangInt;\n"
"    typedef uint64_t   SlangUInt;\n"
"\n"
"    typedef uint64_t   SlangSizeT;\n"
"#else\n"
"    typedef int32_t    SlangInt;\n"
"    typedef uint32_t   SlangUInt;\n"
"\n"
"    typedef uint32_t   SlangSizeT;\n"
"#endif\n"
"\n"
"    typedef bool SlangBool;\n"
"\n"
"    \n"
"    /*!\n"
"    @brief Severity of a diagnostic generated by the compiler.\n"
"    Values come from the enum below, with higher values representing more severe\n"
"    conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation\n"
"    failure.\n"
"    */\n"
"    typedef int SlangSeverity;\n"
"    enum\n"
"    {\n"
"        SLANG_SEVERITY_NOTE = 0,    /**< An informative message. */\n"
"        SLANG_SEVERITY_WARNING,     /**< A warning, which indicates a possible proble. */\n"
"        SLANG_SEVERITY_ERROR,       /**< An error, indicating that compilation failed. */\n"
"        SLANG_SEVERITY_FATAL,       /**< An unrecoverable error, which forced compilation to abort. */\n"
"        SLANG_SEVERITY_INTERNAL,    /**< An internal error, indicating a logic error in the compiler. */\n"
"    };\n"
"\n"
"    typedef int SlangBindableResourceType;\n"
"    enum\n"
"    {\n"
"        SLANG_NON_BINDABLE = 0,\n"
"        SLANG_TEXTURE,\n"
"        SLANG_SAMPLER,\n"
"        SLANG_UNIFORM_BUFFER,\n"
"        SLANG_STORAGE_BUFFER,\n"
"    };\n"
"\n"
"    typedef int SlangCompileTarget;\n"
"    enum\n"
"    {\n"
"        SLANG_TARGET_UNKNOWN,\n"
"        SLANG_TARGET_NONE,\n"
"        SLANG_GLSL,\n"
"        SLANG_GLSL_VULKAN,          //< deprecated: just use `SLANG_GLSL`\n"
"        SLANG_GLSL_VULKAN_ONE_DESC, //< deprecated\n"
"        SLANG_HLSL,\n"
"        SLANG_SPIRV,\n"
"        SLANG_SPIRV_ASM,\n"
"        SLANG_DXBC,\n"
"        SLANG_DXBC_ASM,\n"
"        SLANG_DXIL,\n"
"        SLANG_DXIL_ASM,\n"
"        SLANG_C_SOURCE,             ///< The C language\n"
"        SLANG_CPP_SOURCE,           ///< C++ code for shader kernels.\n"
"        SLANG_HOST_EXECUTABLE,           ///<  Standalone binary executable (for hosting CPU/OS)\n"
"        SLANG_SHADER_SHARED_LIBRARY,     ///< A shared library/Dll for shader kernels (for hosting CPU/OS)\n"
"        SLANG_SHADER_HOST_CALLABLE,      ///< A CPU target that makes the compiled shader code available to be run immediately\n"
"        SLANG_CUDA_SOURCE,          ///< Cuda source\n"
"        SLANG_PTX,                  ///< PTX\n"
"        SLANG_OBJECT_CODE,          ///< Object code that can be used for later linking\n"
"        SLANG_HOST_CPP_SOURCE,      ///< C++ code for host library or executable.\n"
"        SLANG_TARGET_COUNT_OF,\n"
"    };\n"
"\n"
;
sb << 
"    /* A \"container format\" describes the way that the outputs\n"
"    for multiple files, entry points, targets, etc. should be\n"
"    combined into a single artifact for output. */\n"
"    typedef int SlangContainerFormat;\n"
"    enum\n"
"    {\n"
"        /* Don't generate a container. */\n"
"        SLANG_CONTAINER_FORMAT_NONE,\n"
"\n"
"        /* Generate a container in the `.slang-module` format,\n"
"        which includes reflection information, compiled kernels, etc. */\n"
"        SLANG_CONTAINER_FORMAT_SLANG_MODULE,\n"
"    };\n"
"\n"
"    typedef int SlangPassThroughIntegral;\n"
"    enum SlangPassThrough : SlangPassThroughIntegral\n"
"    {\n"
"        SLANG_PASS_THROUGH_NONE,\n"
"        SLANG_PASS_THROUGH_FXC,\n"
"        SLANG_PASS_THROUGH_DXC,\n"
"        SLANG_PASS_THROUGH_GLSLANG,\n"
"        SLANG_PASS_THROUGH_CLANG,                   ///< Clang C/C++ compiler \n"
"        SLANG_PASS_THROUGH_VISUAL_STUDIO,           ///< Visual studio C/C++ compiler\n"
"        SLANG_PASS_THROUGH_GCC,                     ///< GCC C/C++ compiler\n"
"        SLANG_PASS_THROUGH_GENERIC_C_CPP,           ///< Generic C or C++ compiler, which is decided by the source type\n"
"        SLANG_PASS_THROUGH_NVRTC,                   ///< NVRTC Cuda compiler\n"
"        SLANG_PASS_THROUGH_LLVM,                    ///< LLVM 'compiler' - includes LLVM and Clang\n"
"        SLANG_PASS_THROUGH_COUNT_OF,\n"
"    };\n"
"\n"
"    /* Defines an archive type used to holds a 'file system' type structure. */\n"
"    typedef int SlangArchiveTypeIntegral;\n"
"    enum SlangArchiveType : SlangArchiveTypeIntegral\n"
"    {\n"
"        SLANG_ARCHIVE_TYPE_UNDEFINED,\n"
"        SLANG_ARCHIVE_TYPE_ZIP,\n"
"        SLANG_ARCHIVE_TYPE_RIFF,                ///< Riff container with no compression\n"
"        SLANG_ARCHIVE_TYPE_RIFF_DEFLATE,\n"
"        SLANG_ARCHIVE_TYPE_RIFF_LZ4,\n"
"        SLANG_ARCHIVE_TYPE_COUNT_OF,\n"
"    };\n"
"\n"
"    /*!\n"
"    Flags to control compilation behavior.\n"
"    */\n"
"    typedef unsigned int SlangCompileFlags;\n"
"    enum\n"
"    {\n"
"        /* Do as little mangling of names as possible, to try to preserve original names */\n"
"        SLANG_COMPILE_FLAG_NO_MANGLING          = 1 << 3,\n"
"\n"
"        /* Skip code generation step, just check the code and generate layout */\n"
"        SLANG_COMPILE_FLAG_NO_CODEGEN           = 1 << 4,\n"
"\n"
"        /* Obfuscate shader names on release products */\n"
"        SLANG_COMPILE_FLAG_OBFUSCATE = 1 << 5,\n"
"\n"
"        /* Deprecated flags: kept around to allow existing applications to\n"
"        compile. Note that the relevant features will still be left in\n"
"        their default state. */\n"
"        SLANG_COMPILE_FLAG_NO_CHECKING          = 0,\n"
"        SLANG_COMPILE_FLAG_SPLIT_MIXED_TYPES    = 0,\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Flags to control code generation behavior of a compilation target */\n"
"    typedef unsigned int SlangTargetFlags;\n"
"    enum\n"
"    {\n"
"        /* When compiling for a D3D Shader Model 5.1 or higher target, allocate\n"
"           distinct register spaces for parameter blocks.\n"
"\n"
"           @deprecated This behavior is now enabled unconditionally.\n"
"        */\n"
"        SLANG_TARGET_FLAG_PARAMETER_BLOCKS_USE_REGISTER_SPACES = 1 << 4,\n"
"\n"
"        /* When set, will generate target code that contains all entrypoints defined\n"
"           in the input source or specified via the `spAddEntryPoint` function in a\n"
"           single output module (library/source file).\n"
"        */\n"
"        SLANG_TARGET_FLAG_GENERATE_WHOLE_PROGRAM = 1 << 8,\n"
"\n"
"        /* When set, will dump out the IR between intermediate compilation steps.*/\n"
"        SLANG_TARGET_FLAG_DUMP_IR = 1 << 9,\n"
"\n"
"        /* When set, will generate SPIRV directly instead of going through glslang. */\n"
"        SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY = 1 << 10,\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Options to control floating-point precision guarantees for a target.\n"
"    */\n"
"    typedef unsigned int SlangFloatingPointMode;\n"
"    enum\n"
"    {\n"
"        SLANG_FLOATING_POINT_MODE_DEFAULT = 0,\n"
"        SLANG_FLOATING_POINT_MODE_FAST,\n"
"        SLANG_FLOATING_POINT_MODE_PRECISE,\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Options to control emission of `#line` directives\n"
"    */\n"
"    typedef unsigned int SlangLineDirectiveMode;\n"
"    enum\n"
"    {\n"
"        SLANG_LINE_DIRECTIVE_MODE_DEFAULT = 0,  /**< Default behavior: pick behavior base on target. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_NONE,         /**< Don't emit line directives at all. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_STANDARD,     /**< Emit standard C-style `#line` directives. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_GLSL,         /**< Emit GLSL-style directives with file *number* instead of name */\n"
"    };\n"
"\n"
"    typedef int SlangSourceLanguageIntegral;\n"
"    enum SlangSourceLanguage : SlangSourceLanguageIntegral\n"
"    {\n"
"        SLANG_SOURCE_LANGUAGE_UNKNOWN,\n"
"        SLANG_SOURCE_LANGUAGE_SLANG,\n"
"        SLANG_SOURCE_LANGUAGE_HLSL,\n"
"        SLANG_SOURCE_LANGUAGE_GLSL,\n"
"        SLANG_SOURCE_LANGUAGE_C,\n"
"        SLANG_SOURCE_LANGUAGE_CPP,\n"
"        SLANG_SOURCE_LANGUAGE_CUDA,\n"
"        SLANG_SOURCE_LANGUAGE_COUNT_OF,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangProfileID;\n"
"    enum\n"
"    {\n"
"        SLANG_PROFILE_UNKNOWN,\n"
"    };\n"
"\n"
"    typedef SlangInt32 SlangCapabilityID;\n"
"    enum\n"
"    {\n"
"        SLANG_CAPABILITY_UNKNOWN = 0,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangMatrixLayoutMode;\n"
"    enum\n"
"    {\n"
"        SLANG_MATRIX_LAYOUT_MODE_UNKNOWN = 0,\n"
"        SLANG_MATRIX_LAYOUT_ROW_MAJOR,\n"
"        SLANG_MATRIX_LAYOUT_COLUMN_MAJOR,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangStage;\n"
"    enum\n"
"    {\n"
"        SLANG_STAGE_NONE,\n"
"        SLANG_STAGE_VERTEX,\n"
"        SLANG_STAGE_HULL,\n"
"        SLANG_STAGE_DOMAIN,\n"
"        SLANG_STAGE_GEOMETRY,\n"
"        SLANG_STAGE_FRAGMENT,\n"
"        SLANG_STAGE_COMPUTE,\n"
"        SLANG_STAGE_RAY_GENERATION,\n"
"        SLANG_STAGE_INTERSECTION,\n"
"        SLANG_STAGE_ANY_HIT,\n"
"        SLANG_STAGE_CLOSEST_HIT,\n"
"        SLANG_STAGE_MISS,\n"
"        SLANG_STAGE_CALLABLE,\n"
"        SLANG_STAGE_MESH,\n"
"        SLANG_STAGE_AMPLIFICATION,\n"
"\n"
"        // alias:\n"
"        SLANG_STAGE_PIXEL = SLANG_STAGE_FRAGMENT,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangDebugInfoLevel;\n"
"    enum\n"
"    {\n"
"        SLANG_DEBUG_INFO_LEVEL_NONE = 0,    /**< Don't emit debug information at all. */\n"
"        SLANG_DEBUG_INFO_LEVEL_MINIMAL,     /**< Emit as little debug information as possible, while still supporting stack trackes. */\n"
"        SLANG_DEBUG_INFO_LEVEL_STANDARD,    /**< Emit whatever is the standard level of debug information for each target. */\n"
"        SLANG_DEBUG_INFO_LEVEL_MAXIMAL,     /**< Emit as much debug infromation as possible for each target. */\n"
"        \n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangOptimizationLevel;\n"
"    enum\n"
"    {\n"
"        SLANG_OPTIMIZATION_LEVEL_NONE = 0,  /**< Don't optimize at all. */\n"
"        SLANG_OPTIMIZATION_LEVEL_DEFAULT,   /**< Default optimization level: balance code quality and compilation time. */\n"
"        SLANG_OPTIMIZATION_LEVEL_HIGH,      /**< Optimize aggressively. */\n"
"        SLANG_OPTIMIZATION_LEVEL_MAXIMAL,   /**< Include optimizations that may take a very long time, or may involve severe space-vs-speed tradeoffs */\n"
"    };\n"
"\n"
"    /** A result code for a Slang API operation.\n"
"\n"
"    This type is generally compatible with the Windows API `HRESULT` type. In particular, negative values indicate\n"
"    failure results, while zero or positive results indicate success.\n"
"\n"
"    In general, Slang APIs always return a zero result on success, unless documented otherwise. Strictly speaking\n"
"    a negative value indicates an error, a positive (or 0) value indicates success. This can be tested for with the macros\n"
"    SLANG_SUCCEEDED(x) or SLANG_FAILED(x).\n"
"\n"
"    It can represent if the call was successful or not. It can also specify in an extensible manner what facility\n"
"    produced the result (as the integral 'facility') as well as what caused it (as an integral 'code').\n"
"    Under the covers SlangResult is represented as a int32_t.\n"
"\n"
"    SlangResult is designed to be compatible with COM HRESULT.\n"
"\n"
"    It's layout in bits is as follows\n"
"\n"
"    Severity | Facility | Code\n"
"    ---------|----------|-----\n"
"    31       |    30-16 | 15-0\n"
"\n"
"    Severity - 1 fail, 0 is success - as SlangResult is signed 32 bits, means negative number indicates failure.\n"
"    Facility is where the error originated from. Code is the code specific to the facility.\n"
"\n"
"    Result codes have the following styles,\n"
"    1) SLANG_name\n"
"    2) SLANG_s_f_name\n"
"    3) SLANG_s_name\n"
"\n"
"    where s is S for success, E for error\n"
"    f is the short version of the facility name\n"
"\n"
"    Style 1 is reserved for SLANG_OK and SLANG_FAIL as they are so commonly used.\n"
"\n"
"    It is acceptable to expand 'f' to a longer name to differentiate a name or drop if unique without it.\n"
"    ie for a facility 'DRIVER' it might make sense to have an error of the form SLANG_E_DRIVER_OUT_OF_MEMORY\n"
"    */\n"
"\n"
"    typedef int32_t SlangResult;\n"
"\n"
"    //! Use to test if a result was failure. Never use result != SLANG_OK to test for failure, as there may be successful codes != SLANG_OK.\n"
"#define SLANG_FAILED(status) ((status) < 0)\n"
"    //! Use to test if a result succeeded. Never use result == SLANG_OK to test for success, as will detect other successful codes as a failure.\n"
"#define SLANG_SUCCEEDED(status) ((status) >= 0)\n"
"\n"
"    //! Get the facility the result is associated with\n"
"#define SLANG_GET_RESULT_FACILITY(r)    ((int32_t)(((r) >> 16) & 0x7fff))\n"
"    //! Get the result code for the facility\n"
"#define SLANG_GET_RESULT_CODE(r)        ((int32_t)((r) & 0xffff))\n"
"\n"
"#define SLANG_MAKE_ERROR(fac, code)        ((((int32_t)(fac)) << 16) | ((int32_t)(code)) | int32_t(0x80000000))\n"
"#define SLANG_MAKE_SUCCESS(fac, code)    ((((int32_t)(fac)) << 16) | ((int32_t)(code)))\n"
"\n"
"    /*************************** Facilities ************************************/\n"
"\n"
"    //! Facilities compatible with windows COM - only use if known code is compatible\n"
"#define SLANG_FACILITY_WIN_GENERAL      0\n"
"#define SLANG_FACILITY_WIN_INTERFACE    4\n"
"#define SLANG_FACILITY_WIN_API          7\n"
"\n"
"    //! Base facility -> so as to not clash with HRESULT values (values in 0x200 range do not appear used)\n"
"#define SLANG_FACILITY_BASE         0x200\n"
"\n"
"    /*! Facilities numbers must be unique across a project to make the resulting result a unique number.\n"
"    It can be useful to have a consistent short name for a facility, as used in the name prefix */\n"
"#define SLANG_FACILITY_CORE             SLANG_FACILITY_BASE\n"
"    /* Facility for codes, that are not uniquely defined/protected. Can be used to pass back a specific error without requiring system wide facility uniqueness. Codes\n"
"    should never be part of a public API. */\n"
"#define SLANG_FACILITY_INTERNAL         SLANG_FACILITY_BASE + 1\n"
"\n"
"    /// Base for external facilities. Facilities should be unique across modules.\n"
"#define SLANG_FACILITY_EXTERNAL_BASE 0x210\n"
"\n"
"    /* ************************ Win COM compatible Results ******************************/\n"
"    // https://msdn.microsoft.com/en-us/library/windows/desktop/aa378137(v=vs.85).aspx\n"
"\n"
"    //! SLANG_OK indicates success, and is equivalent to SLANG_MAKE_SUCCESS(SLANG_FACILITY_WIN_GENERAL, 0)\n"
"#define SLANG_OK                          0\n"
"    //! SLANG_FAIL is the generic failure code - meaning a serious error occurred and the call couldn't complete\n"
"#define SLANG_FAIL                          SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_GENERAL, 0x4005)\n"
"\n"
"#define SLANG_MAKE_WIN_GENERAL_ERROR(code)  SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_GENERAL, code)\n"
"\n"
"    //! Functionality is not implemented\n"
"#define SLANG_E_NOT_IMPLEMENTED             SLANG_MAKE_WIN_GENERAL_ERROR(0x4001)\n"
"    //! Interface not be found\n"
"#define SLANG_E_NO_INTERFACE                SLANG_MAKE_WIN_GENERAL_ERROR(0x4002)\n"
"    //! Operation was aborted (did not correctly complete)\n"
"#define SLANG_E_ABORT                       SLANG_MAKE_WIN_GENERAL_ERROR(0x4004) \n"
"\n"
"    //! Indicates that a handle passed in as parameter to a method is invalid.\n"
"#define SLANG_E_INVALID_HANDLE              SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 6)\n"
"    //! Indicates that an argument passed in as parameter to a method is invalid.\n"
"#define SLANG_E_INVALID_ARG                 SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 0x57)\n"
"    //! Operation could not complete - ran out of memory\n"
"#define SLANG_E_OUT_OF_MEMORY               SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 0xe)\n"
"\n"
"    /* *************************** other Results **************************************/\n"
"\n"
"#define SLANG_MAKE_CORE_ERROR(code)         SLANG_MAKE_ERROR(SLANG_FACILITY_CORE, code)\n"
"\n"
"    // Supplied buffer is too small to be able to complete\n"
"#define SLANG_E_BUFFER_TOO_SMALL            SLANG_MAKE_CORE_ERROR(1)\n"
"    //! Used to identify a Result that has yet to be initialized.\n"
"    //! It defaults to failure such that if used incorrectly will fail, as similar in concept to using an uninitialized variable.\n"
"#define SLANG_E_UNINITIALIZED               SLANG_MAKE_CORE_ERROR(2)\n"
"    //! Returned from an async method meaning the output is invalid (thus an error), but a result for the request is pending, and will be returned on a subsequent call with the async handle.\n"
"#define SLANG_E_PENDING                     SLANG_MAKE_CORE_ERROR(3)\n"
"    //! Indicates a file/resource could not be opened\n"
"#define SLANG_E_CANNOT_OPEN                 SLANG_MAKE_CORE_ERROR(4)\n"
"    //! Indicates a file/resource could not be found\n"
"#define SLANG_E_NOT_FOUND                   SLANG_MAKE_CORE_ERROR(5)\n"
"    //! An unhandled internal failure (typically from unhandled exception)\n"
"#define SLANG_E_INTERNAL_FAIL               SLANG_MAKE_CORE_ERROR(6)\n"
"    //! Could not complete because some underlying feature (hardware or software) was not available \n"
"#define SLANG_E_NOT_AVAILABLE               SLANG_MAKE_CORE_ERROR(7)\n"
"        //! Could not complete because the operation times out. \n"
"#define SLANG_E_TIME_OUT                    SLANG_MAKE_CORE_ERROR(8)\n"
"\n"
"    /** A \"Universally Unique Identifier\" (UUID)\n"
"\n"
"    The Slang API uses UUIDs to identify interfaces when\n"
"    using `queryInterface`.\n"
"\n"
"    This type is compatible with the `GUID` type defined\n"
"    by the Component Object Model (COM), but Slang is\n"
"    not dependent on COM.\n"
"    */\n"
"    struct SlangUUID\n"
"    {\n"
"        uint32_t data1;\n"
"        uint16_t data2;\n"
"        uint16_t data3;\n"
"        uint8_t  data4[8];\n"
"    };\n"
"\n"
"// Place at the start of an interface with the guid.\n"
"// Guid should be specified as SLANG_COM_INTERFACE(0x00000000, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 })\n"
"// NOTE: it's the typical guid struct definition, without the surrounding {}\n"
"// It is not necessary to use the multiple parameters (we can wrap in parens), but this is simple.\n"
"#define SLANG_COM_INTERFACE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \\\n"
"    public: \\\n"
"    SLANG_FORCE_INLINE static const SlangUUID& getTypeGuid() \\\n"
"    { \\\n"
"        static const SlangUUID guid = { a, b, c, d0, d1, d2, d3, d4, d5, d6, d7 }; \\\n"
"        return guid; \\\n"
"    }\n"
"\n"
"// Sometimes it's useful to associate a guid with a class to identify it. This macro can used for this,\n"
"// and the guid extracted via the getTypeGuid() function defined in the type\n"
"#define SLANG_CLASS_GUID(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \\\n"
"    SLANG_FORCE_INLINE static const SlangUUID& getTypeGuid() \\\n"
"    { \\\n"
"        static const SlangUUID guid = { a, b, c, d0, d1, d2, d3, d4, d5, d6, d7 }; \\\n"
"        return guid; \\\n"
"    }\n"
"\n"
"    /** Base interface for components exchanged through the API.\n"
"\n"
"    This interface definition is compatible with the COM `IUnknown`,\n"
"    and uses the same UUID, but Slang does not require applications\n"
"    to use or initialize COM.\n"
"    */\n"
"    struct ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x00000000, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 })\n"
"\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL queryInterface(SlangUUID const& uuid, void** outObject) = 0;\n"
"        virtual SLANG_NO_THROW uint32_t SLANG_MCALL addRef() = 0;\n"
"        virtual SLANG_NO_THROW uint32_t SLANG_MCALL release() = 0;\n"
"\n"
"        /*\n"
"        Inline methods are provided to allow the above operations to be called\n"
"        using their traditional COM names/signatures:\n"
"        */\n"
"        SlangResult QueryInterface(struct _GUID const& uuid, void** outObject) { return queryInterface(*(SlangUUID const*)&uuid, outObject); }\n"
"        uint32_t AddRef() { return addRef(); }\n"
"        uint32_t Release() { return release(); }\n"
"    };\n"
"    #define SLANG_UUID_ISlangUnknown ISlangUnknown::getTypeGuid()\n"
"\n"
"    /** A \"blob\" of binary data.\n"
"\n"
"    This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces.\n"
"    */\n"
"    struct ISlangBlob : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x8BA5FB08, 0x5195, 0x40e2, { 0xAC, 0x58, 0x0D, 0x98, 0x9C, 0x3A, 0x01, 0x02 })\n"
"\n"
"        virtual SLANG_NO_THROW void const* SLANG_MCALL getBufferPointer() = 0;\n"
"        virtual SLANG_NO_THROW size_t SLANG_MCALL getBufferSize() = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangBlob ISlangBlob::getTypeGuid()\n"
"\n"
"    /** A (real or virtual) file system.\n"
"\n"
;
sb << 
"    Slang can make use of this interface whenever it would otherwise try to load files\n"
"    from disk, allowing applications to hook and/or override filesystem access from\n"
"    the compiler.\n"
"\n"
"    It is the responsibility of \n"
"    the caller of any method that returns a ISlangBlob to release the blob when it is no \n"
"    longer used (using 'release').\n"
"    */\n"
"\n"
"    struct ISlangFileSystem : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x003A09FC, 0x3A4D, 0x4BA0, { 0xAD, 0x60, 0x1F, 0xD8, 0x63, 0xA9, 0x15, 0xAB })\n"
"\n"
"        /** Load a file from `path` and return a blob of its contents\n"
"        @param path The path to load from, as a null-terminated UTF-8 string.\n"
"        @param outBlob A destination pointer to receive the blob of the file contents.\n"
"        @returns A `SlangResult` to indicate success or failure in loading the file.\n"
"\n"
"        NOTE! This is a *binary* load - the blob should contain the exact same bytes\n"
"        as are found in the backing file. \n"
"\n"
"        If load is successful, the implementation should create a blob to hold\n"
"        the file's content, store it to `outBlob`, and return 0.\n"
"        If the load fails, the implementation should return a failure status\n"
"        (any negative value will do).\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadFile(\n"
"            char const*     path,\n"
"            ISlangBlob** outBlob) = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangFileSystem ISlangFileSystem::getTypeGuid()\n"
"\n"
"\n"
"    typedef void(*SlangFuncPtr)(void);\n"
"\n"
"    /** An interface that can be used to encapsulate access to a shared library. An implementation \n"
"    does not have to implement the library as a shared library. \n"
"    */\n"
"    struct ISlangSharedLibrary: public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE( 0x9c9d5bc5, 0xeb61, 0x496f,{ 0x80, 0xd7, 0xd1, 0x47, 0xc4, 0xa2, 0x37, 0x30 })\n"
"\n"
"            /** Get a function by name. If the library is unloaded will only return nullptr. \n"
"            @param name The name of the function \n"
"            @return The function pointer related to the name or nullptr if not found \n"
"            */\n"
"        inline SlangFuncPtr SLANG_MCALL findFuncByName(char const* name)\n"
"        {\n"
"            return reinterpret_cast<SlangFuncPtr>(findSymbolAddressByName(name));\n"
"        }\n"
"            /** Get a symbol by name. If the library is unloaded will only return nullptr. \n"
"            @param name The name of the symbol \n"
"            @return The pointer related to the name or nullptr if not found \n"
"            */\n"
"        virtual SLANG_NO_THROW void* SLANG_MCALL findSymbolAddressByName(char const* name) = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangSharedLibrary ISlangSharedLibrary::getTypeGuid()\n"
"\n"
"    struct ISlangSharedLibraryLoader: public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x6264ab2b, 0xa3e8, 0x4a06, { 0x97, 0xf1, 0x49, 0xbc, 0x2d, 0x2a, 0xb1, 0x4d })\n"
"\n"
"            /** Load a shared library. In typical usage the library name should *not* contain any platform\n"
"            specific elements. For example on windows a dll name should *not* be passed with a '.dll' extension,\n"
"            and similarly on linux a shared library should *not* be passed with the 'lib' prefix and '.so' extension\n"
"            @path path The unadorned filename and/or path for the shared library\n"
"            @ param sharedLibraryOut Holds the shared library if successfully loaded */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadSharedLibrary(\n"
"            const char*     path,\n"
"            ISlangSharedLibrary** sharedLibraryOut) = 0;\n"
"    };\n"
"    #define SLANG_UUID_ISlangSharedLibraryLoader ISlangSharedLibraryLoader::getTypeGuid()\n"
"    \n"
"    /* Type that identifies how a path should be interpreted */\n"
"    typedef unsigned int SlangPathType;\n"
"    enum\n"
"    {\n"
"        SLANG_PATH_TYPE_DIRECTORY,      /**< Path specified specifies a directory. */\n"
"        SLANG_PATH_TYPE_FILE,           /**< Path specified is to a file. */\n"
"    };\n"
"\n"
"    /* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.\n"
"    The name is the name of a file system object (directory/file) in the specified path (ie it is without a path) */\n"
"    typedef void (*FileSystemContentsCallBack)(SlangPathType pathType, const char* name, void* userData);\n"
"\n"
"    /** An extended file system abstraction.\n"
"    \n"
"    Implementing and using this interface over ISlangFileSystem gives much more control over how paths\n"
"    are managed, as well as how it is determined if two files 'are the same'.\n"
"\n"
"    All paths as input char*, or output as ISlangBlobs are always encoded as UTF-8 strings.\n"
"    Blobs that contain strings are always zero terminated.\n"
"    */\n"
"    struct ISlangFileSystemExt : public ISlangFileSystem\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x5fb632d2, 0x979d, 0x4481, { 0x9f, 0xee, 0x66, 0x3c, 0x3f, 0x14, 0x49, 0xe1 })\n"
"\n"
"        /** Get a uniqueIdentity which uniquely identifies an object of the file system.\n"
"           \n"
"        Given a path, returns a 'uniqueIdentity' which ideally is the same value for the same object on the file system.\n"
"\n"
"        The uniqueIdentity is used to compare if two paths are the same - which amongst other things allows Slang to\n"
"        cache source contents internally. It is also used for #pragma once functionality.\n"
"\n"
"        A *requirement* is for any implementation is that two paths can only return the same uniqueIdentity if the\n"
"        contents of the two files are *identical*h. If an implementation breaks this constraint it can produce incorrect compilation.\n"
"        If an implementation cannot *strictly* identify *the same* files, this will only have an effect on #pragma once behavior.\n"
"\n"
"        The string for the uniqueIdentity is held zero terminated in the ISlangBlob of outUniqueIdentity.\n"
"   \n"
"        Note that there are many ways a uniqueIdentity may be generated for a file. For example it could be the\n"
"        'canonical path' - assuming it is available and unambiguous for a file system. Another possible mechanism\n"
"        could be to store the filename combined with the file date time to uniquely identify it.\n"
"     \n"
"        The client must ensure the blob be released when no longer used, otherwise memory will leak.\n"
"\n"
"        NOTE! Ideally this method would be called 'getPathUniqueIdentity' but for historical reasons and\n"
"        backward compatibility it's name remains with 'File' even though an implementation should be made to work\n"
"        with directories too.\n"
"\n"
"        @param path\n"
"        @param outUniqueIdentity\n"
"        @returns A `SlangResult` to indicate success or failure getting the uniqueIdentity.\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getFileUniqueIdentity(\n"
"            const char* path,\n"
"            ISlangBlob** outUniqueIdentity) = 0;\n"
"\n"
"        /** Calculate a path combining the 'fromPath' with 'path'\n"
"\n"
"        The client must ensure the blob be released when no longer used, otherwise memory will leak.\n"
"\n"
"        @param fromPathType How to interpret the from path - as a file or a directory.\n"
"        @param fromPath The from path. \n"
"        @param path Path to be determined relative to the fromPath\n"
"        @param pathOut Holds the string which is the relative path. The string is held in the blob zero terminated.  \n"
"        @returns A `SlangResult` to indicate success or failure in loading the file.\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL calcCombinedPath(\n"
"            SlangPathType fromPathType,\n"
"            const char* fromPath,\n"
"            const char* path,\n"
"            ISlangBlob** pathOut) = 0;          \n"
"            \n"
"        /** Gets the type of path that path is on the file system. \n"
"        @param path\n"
"        @param pathTypeOut\n"
"        @returns SLANG_OK if located and type is known, else an error. SLANG_E_NOT_FOUND if not found.\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getPathType(\n"
"            const char* path, \n"
"            SlangPathType* pathTypeOut) = 0;\n"
"\n"
"        /** Get a simplified path. \n"
"        Given a path, returns a simplified version of that path - typically removing '..' and/or '.'. A simplified\n"
"        path must point to the same object as the original. \n"
"       \n"
"        This method is optional, if not implemented return SLANG_E_NOT_IMPLEMENTED.\n"
"\n"
"        @param path\n"
"        @param outSimplifiedPath\n"
"        @returns SLANG_OK if successfully simplified the path (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getSimplifiedPath(\n"
"            const char* path,\n"
"            ISlangBlob** outSimplifiedPath) = 0;\n"
"\n"
"        /** Get a canonical path identifies an object of the file system.\n"
"\n"
"        Given a path, returns a 'canonicalPath' to the file. This may be a file system 'canonical path' to\n"
"        show where a file was read from. If the file system is say a zip file - it might include the path to the zip\n"
"        container as well as the absolute path to the specific file. The main purpose of the method is to be able\n"
"        to display to uses unambiguously where a file was read from.\n"
"\n"
"        This method is optional, if not implemented return SLANG_E_NOT_IMPLEMENTED.\n"
"\n"
"        @param path\n"
"        @param outCanonicalPath\n"
"        @returns SLANG_OK if successfully canonicalized the path (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getCanonicalPath(\n"
"            const char* path,\n"
"            ISlangBlob** outCanonicalPath) = 0;\n"
"\n"
"        /** Clears any cached information */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL clearCache() = 0;\n"
"\n"
"        /** Enumerate the contents of the path\n"
"        \n"
"        Note that for normal Slang operation it isn't necessary to enumerate contents this can return SLANG_E_NOT_IMPLEMENTED.\n"
"        \n"
"        @param The path to enumerate\n"
"        @param callback This callback is called for each entry in the path. \n"
"        @param userData This is passed to the callback\n"
"        @returns SLANG_OK if successful \n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL enumeratePathContents(\n"
"            const char* path,\n"
"            FileSystemContentsCallBack callback,\n"
"            void* userData) = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_ISlangFileSystemExt ISlangFileSystemExt::getTypeGuid()\n"
"\n"
"    struct ISlangMutableFileSystem : public ISlangFileSystemExt\n"
"    {\n"
"        SLANG_COM_INTERFACE(0xa058675c, 0x1d65, 0x452a, { 0x84, 0x58, 0xcc, 0xde, 0xd1, 0x42, 0x71, 0x5 })\n"
"\n"
"        /** Write the data specified with data and size to the specified path.\n"
"\n"
"        @param path The path for data to be saved to\n"
"        @param data The data to be saved\n"
"        @param size The size of the data\n"
"        @returns SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveFile(\n"
"            const char* path,\n"
"            const void* data,\n"
"            size_t size) = 0;\n"
"\n"
"        /** Remove the entry in the path (directory of file). Will only delete an empty directory, if not empty\n"
"        will return an error.\n"
"\n"
"        @param path The path to remove \n"
"        @returns SLANG_OK if successful \n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL remove(\n"
"            const char* path) = 0;\n"
"\n"
"        /** Create a directory.\n"
"\n"
"        The path to the directory must exist\n"
"\n"
"        @param path To the directory to create. The parent path *must* exist otherwise will return an error.\n"
"        @returns SLANG_OK if successful \n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createDirectory(\n"
"            const char* path) = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_ISlangMutableFileSystem ISlangMutableFileSystem::getTypeGuid()\n"
"\n"
"    /* Identifies different types of writer target*/\n"
"    typedef unsigned int SlangWriterChannel;\n"
"    enum\n"
"    {\n"
"        SLANG_WRITER_CHANNEL_DIAGNOSTIC,\n"
"        SLANG_WRITER_CHANNEL_STD_OUTPUT,\n"
"        SLANG_WRITER_CHANNEL_STD_ERROR,\n"
"        SLANG_WRITER_CHANNEL_COUNT_OF,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangWriterMode;\n"
"    enum \n"
"    {\n"
"        SLANG_WRITER_MODE_TEXT,\n"
"        SLANG_WRITER_MODE_BINARY,\n"
"    };\n"
"\n"
"    /** A stream typically of text, used for outputting diagnostic as well as other information.\n"
"    */\n"
"    struct ISlangWriter : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0xec457f0e, 0x9add, 0x4e6b,{ 0x85, 0x1c, 0xd7, 0xfa, 0x71, 0x6d, 0x15, 0xfd })\n"
"\n"
"            /** Begin an append buffer.\n"
"            NOTE! Only one append buffer can be active at any time.\n"
"            @param maxNumChars The maximum of chars that will be appended\n"
"            @returns The start of the buffer for appending to. */    \n"
"        virtual SLANG_NO_THROW char* SLANG_MCALL beginAppendBuffer(size_t maxNumChars) = 0;\n"
"            /** Ends the append buffer, and is equivalent to a write of the append buffer.\n"
"            NOTE! That an endAppendBuffer is not necessary if there are no characters to write.\n"
"            @param buffer is the start of the data to append and must be identical to last value returned from beginAppendBuffer\n"
"            @param numChars must be a value less than or equal to what was returned from last call to beginAppendBuffer\n"
"            @returns Result, will be SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL endAppendBuffer(char* buffer, size_t numChars) = 0;\n"
"            /** Write text to the writer\n"
"            @param chars The characters to write out\n"
"            @param numChars The amount of characters\n"
"            @returns SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL write(const char* chars, size_t numChars) = 0;\n"
"            /** Flushes any content to the output */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL flush() = 0;\n"
"            /** Determines if the writer stream is to the console, and can be used to alter the output \n"
"            @returns Returns true if is a console writer */\n"
"        virtual SLANG_NO_THROW SlangBool SLANG_MCALL isConsole() = 0;\n"
"            /** Set the mode for the writer to use\n"
"            @param mode The mode to use\n"
"            @returns SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setMode(SlangWriterMode mode) = 0;\n"
"    };\n"
"    \n"
"    #define SLANG_UUID_ISlangWriter ISlangWriter::getTypeGuid()\n"
"\n"
"    namespace slang {\n"
"    struct IGlobalSession;\n"
"    struct ICompileRequest;\n"
"    } // namespace slang\n"
"\n"
"    /*!\n"
"    @brief An instance of the Slang library.\n"
"    */\n"
"    typedef slang::IGlobalSession SlangSession;\n"
"    \n"
"\n"
"    typedef struct SlangProgramLayout SlangProgramLayout;\n"
"\n"
"    /*!\n"
"    @brief A request for one or more compilation actions to be performed.\n"
"    */\n"
"    typedef struct slang::ICompileRequest SlangCompileRequest;\n"
"\n"
"\n"
"    /*!\n"
"    @brief Initialize an instance of the Slang library.\n"
"    */\n"
"    SLANG_API SlangSession* spCreateSession(const char* deprecated = 0);\n"
"\n"
"    /*!\n"
"    @brief Clean up after an instance of the Slang library.\n"
"    */\n"
"    SLANG_API void spDestroySession(\n"
"        SlangSession*   session);\n"
"\n"
"    /** @see slang::IGlobalSession::setSharedLibraryLoader\n"
"    */\n"
"    SLANG_API void spSessionSetSharedLibraryLoader(\n"
"        SlangSession*               session,\n"
"        ISlangSharedLibraryLoader*  loader);\n"
"\n"
"    /** @see slang::IGlobalSession::getSharedLibraryLoader\n"
"    */\n"
"    SLANG_API ISlangSharedLibraryLoader* spSessionGetSharedLibraryLoader(\n"
"        SlangSession*   session);\n"
"\n"
"    /** @see slang::IGlobalSession::checkCompileTargetSupport\n"
"    */\n"
"    SLANG_API SlangResult spSessionCheckCompileTargetSupport(\n"
"        SlangSession*       session,\n"
"        SlangCompileTarget  target);\n"
"\n"
"    /** @see slang::IGlobalSession::checkPassThroughSupport\n"
"    */\n"
"    SLANG_API SlangResult spSessionCheckPassThroughSupport(\n"
"        SlangSession*       session,\n"
"        SlangPassThrough    passThrough\n"
"    );\n"
"\n"
"    /** @see slang::IGlobalSession::addBuiltins\n"
"    */\n"
"    SLANG_API void spAddBuiltins(\n"
"        SlangSession*   session,\n"
"        char const*     sourcePath,\n"
"        char const*     sourceString);\n"
"\n"
"        /*!\n"
"    @brief Callback type used for diagnostic output. \n"
"    */\n"
"    typedef void(*SlangDiagnosticCallback)(\n"
"        char const* message,\n"
"        void*       userData);\n"
"\n"
"    /*!\n"
"    @brief Get the build version 'tag' string. The string is the same as produced via `git describe --tags`\n"
"    for the project. If Slang is built separately from the automated build scripts\n"
"    the contents will by default be 'unknown'. Any string can be set by changing the\n"
"    contents of 'slang-tag-version.h' file and recompiling the project.\n"
"\n"
"    This function will return exactly the same result as the method getBuildTag string on IGlobalSession.\n"
"\n"
"    An advantage of using this function over the method is that doing so does not require the creation of\n"
;
sb << 
"    a session, which can be a fairly costly operation.\n"
"\n"
"    @return The build tag string\n"
"    */\n"
"    SLANG_API const char* spGetBuildTagString();\n"
"\n"
"    /* @see slang::IGlobalSession::createCompileRequest\n"
"    */\n"
"    SLANG_API SlangCompileRequest* spCreateCompileRequest(\n"
"        SlangSession* session);\n"
"\n"
"    /*!\n"
"    @brief Destroy a compile request.\n"
"    Note a request is a COM object and can be destroyed via 'Release'.\n"
"    */\n"
"    SLANG_API void spDestroyCompileRequest(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::setFileSystem */\n"
"    SLANG_API void spSetFileSystem(\n"
"        SlangCompileRequest*    request,\n"
"        ISlangFileSystem*       fileSystem);\n"
"\n"
"    /*! @see slang::ICompileRequest::setCompileFlags */\n"
"    SLANG_API void spSetCompileFlags(\n"
"        SlangCompileRequest*    request,\n"
"        SlangCompileFlags       flags);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDumpIntermediates */\n"
"    SLANG_API void spSetDumpIntermediates(\n"
"        SlangCompileRequest*    request,\n"
"        int                     enable);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDumpIntermediatePrefix */\n"
"    SLANG_API void spSetDumpIntermediatePrefix(\n"
"        SlangCompileRequest*    request,\n"
"        const char* prefix);\n"
"\n"
"    /*! DEPRECATED: use `spSetTargetLineDirectiveMode` instead.\n"
"        @see slang::ICompileRequest::setLineDirectiveMode */\n"
"    SLANG_API void spSetLineDirectiveMode(\n"
"        SlangCompileRequest*    request,\n"
"        SlangLineDirectiveMode  mode);\n"
"        \n"
"    /*! @see slang::ICompileRequest::setTargetLineDirectiveMode */\n"
"    SLANG_API void spSetTargetLineDirectiveMode(\n"
"        SlangCompileRequest*    request,\n"
"        int targetIndex,\n"
"        SlangLineDirectiveMode  mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetLineDirectiveMode */\n"
"    SLANG_API void spSetTargetForceGLSLScalarBufferLayout(\n"
"        SlangCompileRequest*    request,\n"
"        int targetIndex,\n"
"        bool forceScalarLayout);\n"
"\n"
"    /*! @see slang::ICompileRequest::setCodeGenTarget */\n"
"    SLANG_API void spSetCodeGenTarget(\n"
"        SlangCompileRequest*    request,\n"
"        SlangCompileTarget target);\n"
"\n"
"    /*! @see slang::ICompileRequest::addCodeGenTarget */\n"
"    SLANG_API int spAddCodeGenTarget(\n"
"        SlangCompileRequest*    request,\n"
"        SlangCompileTarget      target);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetProfile */\n"
"    SLANG_API void spSetTargetProfile(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        SlangProfileID          profile);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetFlags */\n"
"    SLANG_API void spSetTargetFlags(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        SlangTargetFlags        flags);\n"
"\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetFloatingPointMode */\n"
"    SLANG_API void spSetTargetFloatingPointMode(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        SlangFloatingPointMode  mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTargetCapability */\n"
"    SLANG_API void spAddTargetCapability(\n"
"        slang::ICompileRequest* request,\n"
"        int                     targetIndex,\n"
"        SlangCapabilityID       capability);\n"
"\n"
"    /* DEPRECATED: use `spSetMatrixLayoutMode` instead. */\n"
"    SLANG_API void spSetTargetMatrixLayoutMode(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        SlangMatrixLayoutMode   mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setMatrixLayoutMode */\n"
"    SLANG_API void spSetMatrixLayoutMode(\n"
"        SlangCompileRequest*    request,\n"
"        SlangMatrixLayoutMode   mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDebugInfoLevel */\n"
"    SLANG_API void spSetDebugInfoLevel(\n"
"        SlangCompileRequest*    request,\n"
"        SlangDebugInfoLevel     level);\n"
"\n"
"    /*! @see slang::ICompileRequest::setOptimizationLevel */\n"
"    SLANG_API void spSetOptimizationLevel(\n"
"        SlangCompileRequest*    request,\n"
"        SlangOptimizationLevel  level);\n"
"\n"
"\n"
"    \n"
"    /*! @see slang::ICompileRequest::setOutputContainerFormat */\n"
"    SLANG_API void spSetOutputContainerFormat(\n"
"        SlangCompileRequest*    request,\n"
"        SlangContainerFormat    format);\n"
"\n"
"    /*! @see slang::ICompileRequest::setPassThrough */\n"
"    SLANG_API void spSetPassThrough(\n"
"        SlangCompileRequest*    request,\n"
"        SlangPassThrough        passThrough);\n"
"\n"
"     /*! @see slang::ICompileRequest::setDiagnosticCallback */\n"
"    SLANG_API void spSetDiagnosticCallback(\n"
"        SlangCompileRequest*    request,\n"
"        SlangDiagnosticCallback callback,\n"
"        void const*             userData);\n"
"\n"
"    /*! @see slang::ICompileRequest::setWriter */\n"
"    SLANG_API void spSetWriter(\n"
"        SlangCompileRequest*    request,\n"
"        SlangWriterChannel      channel, \n"
"        ISlangWriter*           writer);\n"
"\n"
"    /*! @see slang::ICompileRequest::getWriter */\n"
"    SLANG_API ISlangWriter* spGetWriter(\n"
"        SlangCompileRequest*    request,\n"
"        SlangWriterChannel      channel);\n"
"\n"
"    /*! @see slang::ICompileRequest::addSearchPath */\n"
"    SLANG_API void spAddSearchPath(\n"
"        SlangCompileRequest*    request,\n"
"        const char*             searchDir);\n"
"\n"
"   /*! @see slang::ICompileRequest::addPreprocessorDefine */\n"
"    SLANG_API void spAddPreprocessorDefine(\n"
"        SlangCompileRequest*    request,\n"
"        const char*             key,\n"
"        const char*             value);\n"
"\n"
"    /*! @see slang::ICompileRequest::processCommandLineArguments */\n"
"    SLANG_API SlangResult spProcessCommandLineArguments(\n"
"        SlangCompileRequest*    request,\n"
"        char const* const*      args,\n"
"        int                     argCount);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnit */\n"
"    SLANG_API int spAddTranslationUnit(\n"
"        SlangCompileRequest*    request,\n"
"        SlangSourceLanguage     language,\n"
"        char const*             name);\n"
"\n"
"    \n"
"    /*! @see slang::ICompileRequest::setDefaultModuleName */\n"
"    SLANG_API void spSetDefaultModuleName(\n"
"        SlangCompileRequest*    request,\n"
"        const char* defaultModuleName);\n"
"\n"
"    /*! @see slang::ICompileRequest::addPreprocessorDefine */\n"
"    SLANG_API void spTranslationUnit_addPreprocessorDefine(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        const char*             key,\n"
"        const char*             value);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceFile */\n"
"    SLANG_API void spAddTranslationUnitSourceFile(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             path);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceString */\n"
"    SLANG_API void spAddTranslationUnitSourceString(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             path,\n"
"        char const*             source);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::addLibraryReference */\n"
"    SLANG_API SlangResult spAddLibraryReference(\n"
"        SlangCompileRequest*    request,\n"
"        const void* libData,\n"
"        size_t libDataSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceStringSpan */\n"
"    SLANG_API void spAddTranslationUnitSourceStringSpan(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             path,\n"
"        char const*             sourceBegin,\n"
"        char const*             sourceEnd);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceBlob */\n"
"    SLANG_API void spAddTranslationUnitSourceBlob(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             path,\n"
"        ISlangBlob*             sourceBlob);\n"
"\n"
"    /*! @see slang::IGlobalSession::findProfile */\n"
"    SLANG_API SlangProfileID spFindProfile(\n"
"        SlangSession*   session,\n"
"        char const*     name);\n"
"\n"
"    /*! @see slang::IGlobalSession::findCapability */\n"
"    SLANG_API SlangCapabilityID spFindCapability(\n"
"        SlangSession*   session,\n"
"        char const*     name);\n"
"\n"
"    /*! @see slang::ICompileRequest::addEntryPoint */\n"
"    SLANG_API int spAddEntryPoint(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             name,\n"
"        SlangStage              stage);\n"
"\n"
"    /*! @see slang::ICompileRequest::addEntryPointEx */\n"
"    SLANG_API int spAddEntryPointEx(\n"
"        SlangCompileRequest*    request,\n"
"        int                     translationUnitIndex,\n"
"        char const*             name,\n"
"        SlangStage              stage,\n"
"        int                     genericArgCount,\n"
"        char const**            genericArgs);\n"
"\n"
"    /*! @see slang::ICompileRequest::setGlobalGenericArgs */\n"
"    SLANG_API SlangResult spSetGlobalGenericArgs(\n"
"        SlangCompileRequest*    request,\n"
"        int                     genericArgCount,\n"
"        char const**            genericArgs);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTypeNameForGlobalExistentialTypeParam */\n"
"    SLANG_API SlangResult spSetTypeNameForGlobalExistentialTypeParam(\n"
"        SlangCompileRequest*    request,\n"
"        int                     slotIndex,\n"
"        char const*             typeName);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTypeNameForEntryPointExistentialTypeParam */\n"
"    SLANG_API SlangResult spSetTypeNameForEntryPointExistentialTypeParam(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex,\n"
"        int                     slotIndex,\n"
"        char const*             typeName);\n"
"\n"
"    /*! @see slang::ICompileRequest::compile */\n"
"    SLANG_API SlangResult spCompile(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::getDiagnosticOutput */\n"
"    SLANG_API char const* spGetDiagnosticOutput(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getDiagnosticOutputBlob */\n"
"    SLANG_API SlangResult spGetDiagnosticOutputBlob(\n"
"        SlangCompileRequest*    request,\n"
"        ISlangBlob**            outBlob);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::getDependencyFileCount */\n"
"    SLANG_API int\n"
"    spGetDependencyFileCount(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getDependencyFilePath */\n"
"    SLANG_API char const*\n"
"    spGetDependencyFilePath(\n"
"        SlangCompileRequest*    request,\n"
"        int                     index);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTranslationUnitCount */\n"
"    SLANG_API int\n"
"    spGetTranslationUnitCount(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointSource */\n"
"    SLANG_API char const* spGetEntryPointSource(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointCode */\n"
"    SLANG_API void const* spGetEntryPointCode(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex,\n"
"        size_t*                 outSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointCodeBlob */\n"
"    SLANG_API SlangResult spGetEntryPointCodeBlob(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex,\n"
"        int                     targetIndex,\n"
"        ISlangBlob**            outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointHostCallable */\n"
"    SLANG_API SlangResult spGetEntryPointHostCallable(\n"
"        SlangCompileRequest*    request,\n"
"        int                     entryPointIndex,\n"
"        int                     targetIndex,\n"
"        ISlangSharedLibrary**   outSharedLibrary);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTargetCodeBlob */\n"
"    SLANG_API SlangResult spGetTargetCodeBlob(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        ISlangBlob**            outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTargetHostCallable */\n"
"    SLANG_API SlangResult spGetTargetHostCallable(\n"
"        SlangCompileRequest*    request,\n"
"        int                     targetIndex,\n"
"        ISlangSharedLibrary**   outSharedLibrary);\n"
"\n"
"    /*! @see slang::ICompileRequest::getCompileRequestCode */\n"
"    SLANG_API void const* spGetCompileRequestCode(\n"
"        SlangCompileRequest*    request,\n"
"        size_t*                 outSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::getContainerCode */\n"
"    SLANG_API SlangResult spGetContainerCode(\n"
"        SlangCompileRequest*    request,\n"
"        ISlangBlob**            outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::loadRepro */\n"
"    SLANG_API SlangResult spLoadRepro(\n"
"        SlangCompileRequest* request,\n"
"        ISlangFileSystem* fileSystem,\n"
"        const void* data,\n"
"        size_t size);\n"
"\n"
"    /*! @see slang::ICompileRequest::saveRepro */\n"
"    SLANG_API SlangResult spSaveRepro(\n"
"        SlangCompileRequest* request,\n"
"        ISlangBlob** outBlob\n"
"    );\n"
"\n"
"    /*! @see slang::ICompileRequest::enableReproCapture */\n"
"    SLANG_API SlangResult spEnableReproCapture(\n"
"        SlangCompileRequest* request);\n"
"\n"
"\n"
"    /** Extract contents of a repro.\n"
"\n"
"    Writes the contained files and manifest with their 'unique' names into fileSystem. For more details read the\n"
"    docs/repro.md documentation. \n"
"\n"
"    @param session          The slang session\n"
"    @param reproData        Holds the repro data\n"
"    @param reproDataSize    The size of the repro data\n"
"    @param fileSystem       File system that the contents of the repro will be written to\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    SLANG_API SlangResult spExtractRepro(\n"
"        SlangSession* session,\n"
"        const void* reproData,\n"
"        size_t reproDataSize,\n"
"        ISlangMutableFileSystem* fileSystem);\n"
"\n"
"    /* Turns a repro into a file system.\n"
"\n"
"    Makes the contents of the repro available as a file system - that is able to access the files with the same\n"
"    paths as were used on the original repro file system. \n"
"\n"
"    @param session          The slang session\n"
"    @param reproData        The repro data\n"
"    @param reproDataSize    The size of the repro data\n"
"    @param replaceFileSystem  Will attempt to load by unique names from this file system before using contents of the repro. Optional.\n"
"    @param outFileSystem    The file system that can be used to access contents\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    SLANG_API SlangResult spLoadReproAsFileSystem(\n"
"        SlangSession* session,\n"
"        const void* reproData,\n"
"        size_t reproDataSize,\n"
"        ISlangFileSystem* replaceFileSystem,\n"
"        ISlangFileSystemExt** outFileSystem);\n"
"    \n"
"    /*\n"
"    Forward declarations of types used in the reflection interface;\n"
"    */\n"
"\n"
"    typedef struct SlangProgramLayout SlangProgramLayout;\n"
"    typedef struct SlangEntryPoint SlangEntryPoint;\n"
"    typedef struct SlangEntryPointLayout SlangEntryPointLayout;\n"
"\n"
"    typedef struct SlangReflectionModifier          SlangReflectionModifier;\n"
"    typedef struct SlangReflectionType              SlangReflectionType;\n"
"    typedef struct SlangReflectionTypeLayout        SlangReflectionTypeLayout;\n"
"    typedef struct SlangReflectionVariable          SlangReflectionVariable;\n"
"    typedef struct SlangReflectionVariableLayout    SlangReflectionVariableLayout;\n"
"    typedef struct SlangReflectionTypeParameter     SlangReflectionTypeParameter;\n"
"    typedef struct SlangReflectionUserAttribute     SlangReflectionUserAttribute;\n"
"\n"
"    /*\n"
"    Type aliases to maintain backward compatibility.\n"
"    */\n"
"    typedef SlangProgramLayout SlangReflection;\n"
"    typedef SlangEntryPointLayout SlangReflectionEntryPoint;\n"
"\n"
"    // get reflection data from a compilation request\n"
"    SLANG_API SlangReflection* spGetReflection(\n"
"        SlangCompileRequest*    request);\n"
"\n"
"    // type reflection\n"
"\n"
"    typedef unsigned int SlangTypeKind;\n"
"    enum\n"
"    {\n"
"        SLANG_TYPE_KIND_NONE,\n"
"        SLANG_TYPE_KIND_STRUCT,\n"
"        SLANG_TYPE_KIND_ARRAY,\n"
"        SLANG_TYPE_KIND_MATRIX,\n"
"        SLANG_TYPE_KIND_VECTOR,\n"
"        SLANG_TYPE_KIND_SCALAR,\n"
"        SLANG_TYPE_KIND_CONSTANT_BUFFER,\n"
"        SLANG_TYPE_KIND_RESOURCE,\n"
"        SLANG_TYPE_KIND_SAMPLER_STATE,\n"
"        SLANG_TYPE_KIND_TEXTURE_BUFFER,\n"
"        SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER,\n"
"        SLANG_TYPE_KIND_PARAMETER_BLOCK,\n"
"        SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER,\n"
"        SLANG_TYPE_KIND_INTERFACE,\n"
"        SLANG_TYPE_KIND_OUTPUT_STREAM,\n"
"        SLANG_TYPE_KIND_SPECIALIZED,\n"
"        SLANG_TYPE_KIND_FEEDBACK,\n"
"        SLANG_TYPE_KIND_COUNT,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangScalarType;\n"
"    enum\n"
"    {\n"
"        SLANG_SCALAR_TYPE_NONE,\n"
"        SLANG_SCALAR_TYPE_VOID,\n"
"        SLANG_SCALAR_TYPE_BOOL,\n"
"        SLANG_SCALAR_TYPE_INT32,\n"
"        SLANG_SCALAR_TYPE_UINT32,\n"
"        SLANG_SCALAR_TYPE_INT64,\n"
"        SLANG_SCALAR_TYPE_UINT64,\n"
"        SLANG_SCALAR_TYPE_FLOAT16,\n"
"        SLANG_SCALAR_TYPE_FLOAT32,\n"
;
sb << 
"        SLANG_SCALAR_TYPE_FLOAT64,\n"
"        SLANG_SCALAR_TYPE_INT8,\n"
"        SLANG_SCALAR_TYPE_UINT8,\n"
"        SLANG_SCALAR_TYPE_INT16,\n"
"        SLANG_SCALAR_TYPE_UINT16,\n"
"    };\n"
"\n"
"#ifndef SLANG_RESOURCE_SHAPE\n"
"#    define SLANG_RESOURCE_SHAPE\n"
"    typedef unsigned int SlangResourceShape;\n"
"    enum\n"
"    {\n"
"        SLANG_RESOURCE_BASE_SHAPE_MASK      = 0x0F,\n"
"\n"
"        SLANG_RESOURCE_NONE                 = 0x00,\n"
"\n"
"        SLANG_TEXTURE_1D                    = 0x01,\n"
"        SLANG_TEXTURE_2D                    = 0x02,\n"
"        SLANG_TEXTURE_3D                    = 0x03,\n"
"        SLANG_TEXTURE_CUBE                  = 0x04,\n"
"        SLANG_TEXTURE_BUFFER                = 0x05,\n"
"\n"
"        SLANG_STRUCTURED_BUFFER             = 0x06,\n"
"        SLANG_BYTE_ADDRESS_BUFFER           = 0x07,\n"
"        SLANG_RESOURCE_UNKNOWN              = 0x08,\n"
"        SLANG_ACCELERATION_STRUCTURE        = 0x09,\n"
"\n"
"        SLANG_RESOURCE_EXT_SHAPE_MASK       = 0xF0,\n"
"\n"
"        SLANG_TEXTURE_FEEDBACK_FLAG         = 0x10,\n"
"        SLANG_TEXTURE_ARRAY_FLAG            = 0x40,\n"
"        SLANG_TEXTURE_MULTISAMPLE_FLAG      = 0x80,\n"
"\n"
"        SLANG_TEXTURE_1D_ARRAY              = SLANG_TEXTURE_1D   | SLANG_TEXTURE_ARRAY_FLAG,\n"
"        SLANG_TEXTURE_2D_ARRAY              = SLANG_TEXTURE_2D   | SLANG_TEXTURE_ARRAY_FLAG,\n"
"        SLANG_TEXTURE_CUBE_ARRAY            = SLANG_TEXTURE_CUBE | SLANG_TEXTURE_ARRAY_FLAG,\n"
"\n"
"        SLANG_TEXTURE_2D_MULTISAMPLE        = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"        SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY  = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    };\n"
"#endif\n"
"    typedef unsigned int SlangResourceAccess;\n"
"    enum\n"
"    {\n"
"        SLANG_RESOURCE_ACCESS_NONE,\n"
"        SLANG_RESOURCE_ACCESS_READ,\n"
"        SLANG_RESOURCE_ACCESS_READ_WRITE,\n"
"        SLANG_RESOURCE_ACCESS_RASTER_ORDERED,\n"
"        SLANG_RESOURCE_ACCESS_APPEND,\n"
"        SLANG_RESOURCE_ACCESS_CONSUME,\n"
"        SLANG_RESOURCE_ACCESS_WRITE,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangParameterCategory;\n"
"    enum\n"
"    {\n"
"        SLANG_PARAMETER_CATEGORY_NONE,\n"
"        SLANG_PARAMETER_CATEGORY_MIXED,\n"
"        SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER,\n"
"        SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE,\n"
"        SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS,\n"
"        SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"        SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"        SLANG_PARAMETER_CATEGORY_SAMPLER_STATE,\n"
"        SLANG_PARAMETER_CATEGORY_UNIFORM,\n"
"        SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT,\n"
"        SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT,\n"
"        SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER,\n"
"\n"
"        // HLSL register `space`, Vulkan GLSL `set`\n"
"        SLANG_PARAMETER_CATEGORY_REGISTER_SPACE,\n"
"\n"
"        // A parameter whose type is to be specialized by a global generic type argument\n"
"        SLANG_PARAMETER_CATEGORY_GENERIC,\n"
"\n"
"        SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD,\n"
"        SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES,\n"
"        SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD,\n"
"        SLANG_PARAMETER_CATEGORY_SHADER_RECORD,\n"
"\n"
"        // An existential type parameter represents a \"hole\" that\n"
"        // needs to be filled with a concrete type to enable\n"
"        // generation of specialized code.\n"
"        //\n"
"        // Consider this example:\n"
"        //\n"
"        //      struct MyParams\n"
"        //      {\n"
"        //          IMaterial material;\n"
"        //          ILight lights[3];\n"
"        //      };\n"
"        //\n"
"        // This `MyParams` type introduces two existential type parameters:\n"
"        // one for `material` and one for `lights`. Even though `lights`\n"
"        // is an array, it only introduces one type parameter, because\n"
"        // we need to hae a *single* concrete type for all the array\n"
"        // elements to be able to generate specialized code.\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM,\n"
"\n"
"        // An existential object parameter represents a value\n"
"        // that needs to be passed in to provide data for some\n"
"        // interface-type shader paameter.\n"
"        //\n"
"        // Consider this example:\n"
"        //\n"
"        //      struct MyParams\n"
"        //      {\n"
"        //          IMaterial material;\n"
"        //          ILight lights[3];\n"
"        //      };\n"
"        //\n"
"        // This `MyParams` type introduces four existential object parameters:\n"
"        // one for `material` and three for `lights` (one for each array\n"
"        // element). This is consistent with the number of interface-type\n"
"        // \"objects\" that are being passed through to the shader.\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM,\n"
"\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_COUNT,\n"
"\n"
"\n"
"        // DEPRECATED:\n"
"        SLANG_PARAMETER_CATEGORY_VERTEX_INPUT = SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"        SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT = SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"    };\n"
"\n"
"    /** Types of API-managed bindings that a parameter might use.\n"
"    \n"
"    `SlangBindingType` represents the distinct types of binding ranges that might be\n"
"    understood by an underlying graphics API or cross-API abstraction layer.\n"
"    Several of the enumeration cases here correspond to cases of `VkDescriptorType`\n"
"    defined by the Vulkan API. Note however that the values of this enumeration\n"
"    are not the same as those of any particular API.\n"
"\n"
"    The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`\n"
"    because `SlangParameterCategory` differentiates the types of parameters for\n"
"    the purposes of layout, where the layout rules of some targets will treat\n"
"    parameters of different types as occupying the same binding space for layout\n"
"    (e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of\n"
"    `binding` indices, and are not allowed to overlap), while those same types\n"
"    map to different types of bindingsin the API (e.g., both textures and samplers\n"
"    use different `VkDescriptorType` values).\n"
"\n"
"    When you want to answer \"what register/binding did this parameter use?\" you\n"
"    should use `SlangParameterCategory`.\n"
"\n"
"    When you wnat to answer \"what type of descriptor range should this parameter use?\"\n"
"    you should use `SlangBindingType`.\n"
"    */\n"
"    typedef SlangUInt32 SlangBindingType;\n"
"    enum\n"
"    {\n"
"        SLANG_BINDING_TYPE_UNKNOWN = 0,\n"
"\n"
"        SLANG_BINDING_TYPE_SAMPLER,\n"
"        SLANG_BINDING_TYPE_TEXTURE,\n"
"        SLANG_BINDING_TYPE_CONSTANT_BUFFER,\n"
"        SLANG_BINDING_TYPE_PARAMETER_BLOCK,\n"
"        SLANG_BINDING_TYPE_TYPED_BUFFER,\n"
"        SLANG_BINDING_TYPE_RAW_BUFFER,\n"
"        SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER,\n"
"        SLANG_BINDING_TYPE_INPUT_RENDER_TARGET,\n"
"        SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA,\n"
"        SLANG_BINDING_TYPE_RAY_TRACTING_ACCELERATION_STRUCTURE,\n"
"\n"
"        SLANG_BINDING_TYPE_VARYING_INPUT,\n"
"        SLANG_BINDING_TYPE_VARYING_OUTPUT,\n"
"\n"
"        SLANG_BINDING_TYPE_EXISTENTIAL_VALUE,\n"
"        SLANG_BINDING_TYPE_PUSH_CONSTANT,\n"
"\n"
"        SLANG_BINDING_TYPE_MUTABLE_FLAG = 0x100,\n"
"\n"
"        SLANG_BINDING_TYPE_MUTABLE_TETURE = SLANG_BINDING_TYPE_TEXTURE | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"        SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER = SLANG_BINDING_TYPE_TYPED_BUFFER | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"        SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER = SLANG_BINDING_TYPE_RAW_BUFFER | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"\n"
"        SLANG_BINDING_TYPE_BASE_MASK = 0x00FF,\n"
"        SLANG_BINDING_TYPE_EXT_MASK  = 0xFF00,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangLayoutRules;\n"
"    enum\n"
"    {\n"
"        SLANG_LAYOUT_RULES_DEFAULT,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangModifierID;\n"
"    enum\n"
"    {\n"
"        SLANG_MODIFIER_SHARED,\n"
"    };\n"
"\n"
"    // User Attribute\n"
"    SLANG_API char const* spReflectionUserAttribute_GetName(SlangReflectionUserAttribute* attrib);\n"
"    SLANG_API unsigned int spReflectionUserAttribute_GetArgumentCount(SlangReflectionUserAttribute* attrib);\n"
"    SLANG_API SlangReflectionType* spReflectionUserAttribute_GetArgumentType(SlangReflectionUserAttribute* attrib, unsigned int index);\n"
"    SLANG_API SlangResult spReflectionUserAttribute_GetArgumentValueInt(SlangReflectionUserAttribute* attrib, unsigned int index, int * rs);\n"
"    SLANG_API SlangResult spReflectionUserAttribute_GetArgumentValueFloat(SlangReflectionUserAttribute* attrib, unsigned int index, float * rs);\n"
"\n"
"    /** Returns the string-typed value of a user attribute argument\n"
"        The string returned is not null-terminated. The length of the string is returned via `outSize`.\n"
"        If index of out of range, or if the specified argument is not a string, the function will return nullptr.\n"
"    */\n"
"    SLANG_API const char* spReflectionUserAttribute_GetArgumentValueString(SlangReflectionUserAttribute* attrib, unsigned int index, size_t * outSize);\n"
"\n"
"    // Type Reflection\n"
"\n"
"    SLANG_API SlangTypeKind spReflectionType_GetKind(SlangReflectionType* type);\n"
"    SLANG_API unsigned int spReflectionType_GetUserAttributeCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionType_GetUserAttribute(SlangReflectionType* type, unsigned int index);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionType_FindUserAttributeByName(SlangReflectionType* type, char const* name);\n"
"\n"
"    SLANG_API unsigned int spReflectionType_GetFieldCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionVariable* spReflectionType_GetFieldByIndex(SlangReflectionType* type, unsigned index);\n"
"\n"
"        /** Returns the number of elements in the given type.\n"
"\n"
"        This operation is valid for vector and array types. For other types it returns zero.\n"
"\n"
"        When invoked on an unbounded-size array it will return `SLANG_UNBOUNDED_SIZE`,\n"
"        which is defined to be `~size_t(0)`.\n"
"\n"
"        If the size of a type cannot be statically computed, perhaps because it depends on\n"
"        a generic parameter that has not been bound to a specific value, this function returns zero.\n"
"        */\n"
"    SLANG_API size_t spReflectionType_GetElementCount(SlangReflectionType* type);\n"
"\n"
"    #define SLANG_UNBOUNDED_SIZE (~size_t(0))\n"
"\n"
"    SLANG_API SlangReflectionType* spReflectionType_GetElementType(SlangReflectionType* type);\n"
"\n"
"    SLANG_API unsigned int spReflectionType_GetRowCount(SlangReflectionType* type);\n"
"    SLANG_API unsigned int spReflectionType_GetColumnCount(SlangReflectionType* type);\n"
"    SLANG_API SlangScalarType spReflectionType_GetScalarType(SlangReflectionType* type);\n"
"\n"
"    SLANG_API SlangResourceShape spReflectionType_GetResourceShape(SlangReflectionType* type);\n"
"    SLANG_API SlangResourceAccess spReflectionType_GetResourceAccess(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionType* spReflectionType_GetResourceResultType(SlangReflectionType* type);\n"
"\n"
"    SLANG_API char const* spReflectionType_GetName(SlangReflectionType* type);\n"
"\n"
"    // Type Layout Reflection\n"
"\n"
"    SLANG_API SlangReflectionType* spReflectionTypeLayout_GetType(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangTypeKind spReflectionTypeLayout_getKind(SlangReflectionTypeLayout* type);\n"
"    SLANG_API size_t spReflectionTypeLayout_GetSize(SlangReflectionTypeLayout* type, SlangParameterCategory category);\n"
"    SLANG_API size_t spReflectionTypeLayout_GetStride(SlangReflectionTypeLayout* type, SlangParameterCategory category);\n"
"    SLANG_API int32_t spReflectionTypeLayout_getAlignment(SlangReflectionTypeLayout* type, SlangParameterCategory category);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_GetFieldByIndex(SlangReflectionTypeLayout* type, unsigned index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_findFieldIndexByName(SlangReflectionTypeLayout* typeLayout, const char* nameBegin, const char* nameEnd);\n"
"\n"
"    SLANG_API size_t spReflectionTypeLayout_GetElementStride(SlangReflectionTypeLayout* type, SlangParameterCategory category);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_GetElementTypeLayout(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_GetElementVarLayout(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_getContainerVarLayout(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangParameterCategory spReflectionTypeLayout_GetParameterCategory(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API unsigned spReflectionTypeLayout_GetCategoryCount(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangParameterCategory spReflectionTypeLayout_GetCategoryByIndex(SlangReflectionTypeLayout* type, unsigned index);\n"
"\n"
"    SLANG_API SlangMatrixLayoutMode spReflectionTypeLayout_GetMatrixLayoutMode(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API int spReflectionTypeLayout_getGenericParamIndex(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getPendingDataTypeLayout(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangInt spReflectionType_getSpecializedTypeArgCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionType* spReflectionType_getSpecializedTypeArgType(SlangReflectionType* type, SlangInt index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangBindingType spReflectionTypeLayout_getBindingRangeType(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeBindingCount(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getBindingRangeLeafTypeLayout(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangReflectionVariable* spReflectionTypeLayout_getBindingRangeLeafVariable(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getFieldBindingRangeOffset(SlangReflectionTypeLayout* typeLayout, SlangInt fieldIndex);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeDescriptorSetIndex(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeDescriptorRangeCount(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetSpaceOffset(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex, SlangInt rangeIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex, SlangInt rangeIndex);\n"
"    SLANG_API SlangBindingType spReflectionTypeLayout_getDescriptorSetDescriptorRangeType(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex, SlangInt rangeIndex);\n"
"    SLANG_API SlangParameterCategory spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory(SlangReflectionTypeLayout* typeLayout, SlangInt setIndex, SlangInt rangeIndex);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeSpaceOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_getSubObjectRangeOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
"\n"
"#if 0\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeObjectCount(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getSubObjectRangeTypeLayout(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeCount(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
;
sb << 
"    SLANG_API SlangBindingType spReflectionTypeLayout_getSubObjectRangeDescriptorRangeBindingType(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeBindingCount(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeIndexOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeSpaceOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"#endif\n"
"\n"
"    // Variable Reflection\n"
"\n"
"    SLANG_API char const* spReflectionVariable_GetName(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionType* spReflectionVariable_GetType(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionModifier* spReflectionVariable_FindModifier(SlangReflectionVariable* var, SlangModifierID modifierID);\n"
"    SLANG_API unsigned int spReflectionVariable_GetUserAttributeCount(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionVariable_GetUserAttribute(SlangReflectionVariable* var, unsigned int index);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionVariable_FindUserAttributeByName(SlangReflectionVariable* var, SlangSession * session, char const* name);\n"
"\n"
"    // Variable Layout Reflection\n"
"\n"
"    SLANG_API SlangReflectionVariable* spReflectionVariableLayout_GetVariable(SlangReflectionVariableLayout* var);\n"
"\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionVariableLayout_GetTypeLayout(SlangReflectionVariableLayout* var);\n"
"\n"
"    SLANG_API size_t spReflectionVariableLayout_GetOffset(SlangReflectionVariableLayout* var, SlangParameterCategory category);\n"
"    SLANG_API size_t spReflectionVariableLayout_GetSpace(SlangReflectionVariableLayout* var, SlangParameterCategory category);\n"
"\n"
"    SLANG_API char const* spReflectionVariableLayout_GetSemanticName(SlangReflectionVariableLayout* var);\n"
"    SLANG_API size_t spReflectionVariableLayout_GetSemanticIndex(SlangReflectionVariableLayout* var);\n"
"\n"
"    /** Get the stage that a variable belongs to (if any).\n"
"\n"
"    A variable \"belongs\" to a specific stage when it is a varying input/output\n"
"    parameter either defined as part of the parameter list for an entry\n"
"    point *or* at the global scope of a stage-specific GLSL code file (e.g.,\n"
"    an `in` parameter in a GLSL `.vs` file belongs to the vertex stage).\n"
"    */\n"
"    SLANG_API SlangStage spReflectionVariableLayout_getStage(\n"
"        SlangReflectionVariableLayout* var);\n"
"\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionVariableLayout_getPendingDataLayout(SlangReflectionVariableLayout* var);\n"
"\n"
"    // Shader Parameter Reflection\n"
"\n"
"    typedef SlangReflectionVariableLayout SlangReflectionParameter;\n"
"\n"
"    SLANG_API unsigned spReflectionParameter_GetBindingIndex(SlangReflectionParameter* parameter);\n"
"    SLANG_API unsigned spReflectionParameter_GetBindingSpace(SlangReflectionParameter* parameter);\n"
"\n"
"    // Entry Point Reflection\n"
"\n"
"    SLANG_API char const* spReflectionEntryPoint_getName(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API char const* spReflectionEntryPoint_getNameOverride(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API unsigned spReflectionEntryPoint_getParameterCount(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getParameterByIndex(\n"
"        SlangReflectionEntryPoint*  entryPoint,\n"
"        unsigned                    index);\n"
"\n"
"    SLANG_API SlangStage spReflectionEntryPoint_getStage(SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API void spReflectionEntryPoint_getComputeThreadGroupSize(\n"
"        SlangReflectionEntryPoint*  entryPoint,\n"
"        SlangUInt                   axisCount,\n"
"        SlangUInt*                  outSizeAlongAxis);\n"
"\n"
"    SLANG_API int spReflectionEntryPoint_usesAnySampleRateInput(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getVarLayout(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getResultVarLayout(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API int spReflectionEntryPoint_hasDefaultConstantBuffer(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    // SlangReflectionTypeParameter\n"
"    SLANG_API char const* spReflectionTypeParameter_GetName(SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API unsigned spReflectionTypeParameter_GetIndex(SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API unsigned spReflectionTypeParameter_GetConstraintCount(SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API SlangReflectionType* spReflectionTypeParameter_GetConstraintByIndex(SlangReflectionTypeParameter* typeParam, unsigned int index);\n"
"\n"
"    // Shader Reflection\n"
"\n"
"    SLANG_API unsigned spReflection_GetParameterCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionParameter* spReflection_GetParameterByIndex(SlangReflection* reflection, unsigned index);\n"
"\n"
"    SLANG_API unsigned int spReflection_GetTypeParameterCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionTypeParameter* spReflection_GetTypeParameterByIndex(SlangReflection* reflection, unsigned int index);\n"
"    SLANG_API SlangReflectionTypeParameter* spReflection_FindTypeParameter(SlangReflection* reflection, char const* name);\n"
"\n"
"    SLANG_API SlangReflectionType* spReflection_FindTypeByName(SlangReflection* reflection, char const* name);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflection_GetTypeLayout(SlangReflection* reflection, SlangReflectionType* reflectionType, SlangLayoutRules rules);\n"
"\n"
"    SLANG_API SlangUInt spReflection_getEntryPointCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionEntryPoint* spReflection_getEntryPointByIndex(SlangReflection* reflection, SlangUInt index);\n"
"    SLANG_API SlangReflectionEntryPoint* spReflection_findEntryPointByName(SlangReflection* reflection, char const* name);\n"
"\n"
"    SLANG_API SlangUInt spReflection_getGlobalConstantBufferBinding(SlangReflection* reflection);\n"
"    SLANG_API size_t spReflection_getGlobalConstantBufferSize(SlangReflection* reflection);\n"
"\n"
"    SLANG_API  SlangReflectionType* spReflection_specializeType(\n"
"        SlangReflection*            reflection,\n"
"        SlangReflectionType*        type,\n"
"        SlangInt                    specializationArgCount,\n"
"        SlangReflectionType* const* specializationArgs,\n"
"        ISlangBlob**                outDiagnostics);\n"
"\n"
"        /// Get the number of hashed strings\n"
"    SLANG_API SlangUInt spReflection_getHashedStringCount(\n"
"        SlangReflection*  reflection);\n"
"\n"
"        /// Get a hashed string. The number of chars is written in outCount.\n"
"        /// The count does *NOT* including terminating 0. The returned string will be 0 terminated. \n"
"    SLANG_API const char* spReflection_getHashedString(\n"
"        SlangReflection*  reflection,\n"
"        SlangUInt index,\n"
"        size_t* outCount);\n"
"\n"
"        /// Compute a string hash.\n"
"        /// Count should *NOT* include terminating zero.\n"
"    SLANG_API int spComputeStringHash(const char* chars, size_t count);\n"
"\n"
"        /// Get a type layout representing reflection information for the global-scope prameters.\n"
"    SLANG_API SlangReflectionTypeLayout* spReflection_getGlobalParamsTypeLayout(\n"
"        SlangReflection* reflection);\n"
"\n"
"        /// Get a variable layout representing reflection information for the global-scope prameters.\n"
"    SLANG_API SlangReflectionVariableLayout* spReflection_getGlobalParamsVarLayout(\n"
"        SlangReflection* reflection);\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"\n"
"/* Helper interfaces for C++ users */\n"
"namespace slang\n"
"{\n"
"    struct BufferReflection;\n"
"    struct TypeLayoutReflection;\n"
"    struct TypeReflection;\n"
"    struct VariableLayoutReflection;\n"
"    struct VariableReflection;\n"
"    \n"
"    struct UserAttribute\n"
"    {\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionUserAttribute_GetName((SlangReflectionUserAttribute*)this);\n"
"        }\n"
"        uint32_t getArgumentCount()\n"
"        {\n"
"            return (uint32_t)spReflectionUserAttribute_GetArgumentCount((SlangReflectionUserAttribute*)this);\n"
"        }\n"
"        TypeReflection* getArgumentType(uint32_t index)\n"
"        {\n"
"            return (TypeReflection*)spReflectionUserAttribute_GetArgumentType((SlangReflectionUserAttribute*)this, index);\n"
"        }\n"
"        SlangResult getArgumentValueInt(uint32_t index, int * value)\n"
"        {\n"
"            return spReflectionUserAttribute_GetArgumentValueInt((SlangReflectionUserAttribute*)this, index, value);\n"
"        }\n"
"        SlangResult getArgumentValueFloat(uint32_t index, float * value)\n"
"        {\n"
"            return spReflectionUserAttribute_GetArgumentValueFloat((SlangReflectionUserAttribute*)this, index, value);\n"
"        }\n"
"        const char* getArgumentValueString(uint32_t index, size_t * outSize)\n"
"        {\n"
"            return spReflectionUserAttribute_GetArgumentValueString((SlangReflectionUserAttribute*)this, index, outSize);\n"
"        }\n"
"    };\n"
"\n"
"    struct TypeReflection\n"
"    {\n"
"        enum class Kind\n"
"        {\n"
"            None    = SLANG_TYPE_KIND_NONE,\n"
"            Struct  = SLANG_TYPE_KIND_STRUCT,\n"
"            Array   = SLANG_TYPE_KIND_ARRAY,\n"
"            Matrix  = SLANG_TYPE_KIND_MATRIX,\n"
"            Vector  = SLANG_TYPE_KIND_VECTOR,\n"
"            Scalar  = SLANG_TYPE_KIND_SCALAR,\n"
"            ConstantBuffer = SLANG_TYPE_KIND_CONSTANT_BUFFER,\n"
"            Resource = SLANG_TYPE_KIND_RESOURCE,\n"
"            SamplerState = SLANG_TYPE_KIND_SAMPLER_STATE,\n"
"            TextureBuffer = SLANG_TYPE_KIND_TEXTURE_BUFFER,\n"
"            ShaderStorageBuffer = SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER,\n"
"            ParameterBlock = SLANG_TYPE_KIND_PARAMETER_BLOCK,\n"
"            GenericTypeParameter = SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER,\n"
"            Interface = SLANG_TYPE_KIND_INTERFACE,\n"
"            OutputStream = SLANG_TYPE_KIND_OUTPUT_STREAM,\n"
"            Specialized = SLANG_TYPE_KIND_SPECIALIZED,\n"
"            Feedback = SLANG_TYPE_KIND_FEEDBACK,\n"
"        };\n"
"\n"
"        enum ScalarType : SlangScalarType\n"
"        {\n"
"            None    = SLANG_SCALAR_TYPE_NONE,\n"
"            Void    = SLANG_SCALAR_TYPE_VOID,\n"
"            Bool    = SLANG_SCALAR_TYPE_BOOL,\n"
"            Int32   = SLANG_SCALAR_TYPE_INT32,\n"
"            UInt32  = SLANG_SCALAR_TYPE_UINT32,\n"
"            Int64   = SLANG_SCALAR_TYPE_INT64,\n"
"            UInt64  = SLANG_SCALAR_TYPE_UINT64,\n"
"            Float16 = SLANG_SCALAR_TYPE_FLOAT16,\n"
"            Float32 = SLANG_SCALAR_TYPE_FLOAT32,\n"
"            Float64 = SLANG_SCALAR_TYPE_FLOAT64,\n"
"            Int8    = SLANG_SCALAR_TYPE_INT8,\n"
"            UInt8   = SLANG_SCALAR_TYPE_UINT8,\n"
"            Int16   = SLANG_SCALAR_TYPE_INT16,\n"
"            UInt16  = SLANG_SCALAR_TYPE_UINT16,\n"
"        };\n"
"\n"
"        Kind getKind()\n"
"        {\n"
"            return (Kind) spReflectionType_GetKind((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        // only useful if `getKind() == Kind::Struct`\n"
"        unsigned int getFieldCount()\n"
"        {\n"
"            return spReflectionType_GetFieldCount((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        VariableReflection* getFieldByIndex(unsigned int index)\n"
"        {\n"
"            return (VariableReflection*) spReflectionType_GetFieldByIndex((SlangReflectionType*) this, index);\n"
"        }\n"
"\n"
"        bool isArray() { return getKind() == TypeReflection::Kind::Array; }\n"
"\n"
"        TypeReflection* unwrapArray()\n"
"        {\n"
"            TypeReflection* type = this;\n"
"            while( type->isArray() )\n"
"            {\n"
"                type = type->getElementType();\n"
"            }\n"
"            return type;\n"
"        }\n"
"\n"
"        // only useful if `getKind() == Kind::Array`\n"
"        size_t getElementCount()\n"
"        {\n"
"            return spReflectionType_GetElementCount((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        size_t getTotalArrayElementCount()\n"
"        {\n"
"            if(!isArray()) return 0;\n"
"            size_t result = 1;\n"
"            TypeReflection* type = this;\n"
"            for(;;)\n"
"            {\n"
"                if(!type->isArray())\n"
"                    return result;\n"
"\n"
"                result *= type->getElementCount();\n"
"                type = type->getElementType();\n"
"            }\n"
"        }\n"
"\n"
"        TypeReflection* getElementType()\n"
"        {\n"
"            return (TypeReflection*) spReflectionType_GetElementType((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        unsigned getRowCount()\n"
"        {\n"
"            return spReflectionType_GetRowCount((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        unsigned getColumnCount()\n"
"        {\n"
"            return spReflectionType_GetColumnCount((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        ScalarType getScalarType()\n"
"        {\n"
"            return (ScalarType) spReflectionType_GetScalarType((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        TypeReflection* getResourceResultType()\n"
"        {\n"
"            return (TypeReflection*) spReflectionType_GetResourceResultType((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        SlangResourceShape getResourceShape()\n"
"        {\n"
"            return spReflectionType_GetResourceShape((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        SlangResourceAccess getResourceAccess()\n"
"        {\n"
"            return spReflectionType_GetResourceAccess((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionType_GetName((SlangReflectionType*) this);\n"
"        }\n"
"\n"
"        unsigned int getUserAttributeCount()\n"
"        {\n"
"            return spReflectionType_GetUserAttributeCount((SlangReflectionType*)this);\n"
"        }\n"
"        UserAttribute* getUserAttributeByIndex(unsigned int index)\n"
"        {\n"
"            return (UserAttribute*)spReflectionType_GetUserAttribute((SlangReflectionType*)this, index);\n"
"        }\n"
"        UserAttribute* findUserAttributeByName(char const* name)\n"
"        {\n"
"            return (UserAttribute*)spReflectionType_FindUserAttributeByName((SlangReflectionType*)this, name);\n"
"        }\n"
"    };\n"
"\n"
"    enum ParameterCategory : SlangParameterCategory\n"
"    {\n"
"        // TODO: these aren't scoped...\n"
"        None = SLANG_PARAMETER_CATEGORY_NONE,\n"
"        Mixed = SLANG_PARAMETER_CATEGORY_MIXED,\n"
"        ConstantBuffer = SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER,\n"
"        ShaderResource = SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE,\n"
"        UnorderedAccess = SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS,\n"
"        VaryingInput = SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"        VaryingOutput = SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"        SamplerState = SLANG_PARAMETER_CATEGORY_SAMPLER_STATE,\n"
"        Uniform = SLANG_PARAMETER_CATEGORY_UNIFORM,\n"
"        DescriptorTableSlot = SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT,\n"
"        SpecializationConstant = SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT,\n"
"        PushConstantBuffer = SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER,\n"
"        RegisterSpace = SLANG_PARAMETER_CATEGORY_REGISTER_SPACE,\n"
"        GenericResource = SLANG_PARAMETER_CATEGORY_GENERIC,\n"
"\n"
"        RayPayload = SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD,\n"
"        HitAttributes = SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES,\n"
"        CallablePayload = SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD,\n"
"\n"
"        ShaderRecord = SLANG_PARAMETER_CATEGORY_SHADER_RECORD,\n"
"\n"
"        ExistentialTypeParam = SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM,\n"
"        ExistentialObjectParam = SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM,\n"
"\n"
"        // DEPRECATED:\n"
"        VertexInput = SLANG_PARAMETER_CATEGORY_VERTEX_INPUT,\n"
"        FragmentOutput = SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT,\n"
"    };\n"
"\n"
"    enum class BindingType : SlangBindingType\n"
"    {\n"
"        Unknown                             = SLANG_BINDING_TYPE_UNKNOWN,\n"
"\n"
"        Sampler                             = SLANG_BINDING_TYPE_SAMPLER,\n"
"        Texture                             = SLANG_BINDING_TYPE_TEXTURE,\n"
"        ConstantBuffer                      = SLANG_BINDING_TYPE_CONSTANT_BUFFER,\n"
"        ParameterBlock                      = SLANG_BINDING_TYPE_PARAMETER_BLOCK,\n"
"        TypedBuffer                         = SLANG_BINDING_TYPE_TYPED_BUFFER,\n"
"        RawBuffer                           = SLANG_BINDING_TYPE_RAW_BUFFER,\n"
"        CombinedTextureSampler              = SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER,\n"
"        InputRenderTarget                   = SLANG_BINDING_TYPE_INPUT_RENDER_TARGET,\n"
"        InlineUniformData                   = SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA,\n"
"        RayTracingAccelerationStructure     = SLANG_BINDING_TYPE_RAY_TRACTING_ACCELERATION_STRUCTURE,\n"
"        VaryingInput                        = SLANG_BINDING_TYPE_VARYING_INPUT,\n"
;
sb << 
"        VaryingOutput                       = SLANG_BINDING_TYPE_VARYING_OUTPUT,\n"
"        ExistentialValue                    = SLANG_BINDING_TYPE_EXISTENTIAL_VALUE,\n"
"        PushConstant                        = SLANG_BINDING_TYPE_PUSH_CONSTANT,\n"
"\n"
"        MutableFlag                         = SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"\n"
"        MutableTexture                      = SLANG_BINDING_TYPE_MUTABLE_TETURE,\n"
"        MutableTypedBuffer                  = SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER,\n"
"        MutableRawBuffer                    = SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER,\n"
"\n"
"        BaseMask                            = SLANG_BINDING_TYPE_BASE_MASK,\n"
"        ExtMask                             = SLANG_BINDING_TYPE_EXT_MASK,\n"
"    };\n"
"\n"
"    struct TypeLayoutReflection\n"
"    {\n"
"        TypeReflection* getType()\n"
"        {\n"
"            return (TypeReflection*) spReflectionTypeLayout_GetType((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        TypeReflection::Kind getKind()\n"
"        {\n"
"            return (TypeReflection::Kind) spReflectionTypeLayout_getKind((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        size_t getSize(SlangParameterCategory category = SLANG_PARAMETER_CATEGORY_UNIFORM)\n"
"        {\n"
"            return spReflectionTypeLayout_GetSize((SlangReflectionTypeLayout*) this, category);\n"
"        }\n"
"\n"
"        size_t getStride(SlangParameterCategory category = SLANG_PARAMETER_CATEGORY_UNIFORM)\n"
"        {\n"
"            return spReflectionTypeLayout_GetStride((SlangReflectionTypeLayout*) this, category);\n"
"        }\n"
"\n"
"        int32_t getAlignment(SlangParameterCategory category = SLANG_PARAMETER_CATEGORY_UNIFORM)\n"
"        {\n"
"            return spReflectionTypeLayout_getAlignment((SlangReflectionTypeLayout*) this, category);\n"
"        }\n"
"\n"
"        unsigned int getFieldCount()\n"
"        {\n"
"            return getType()->getFieldCount();\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getFieldByIndex(unsigned int index)\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionTypeLayout_GetFieldByIndex((SlangReflectionTypeLayout*) this, index);\n"
"        }\n"
"\n"
"        SlangInt findFieldIndexByName(char const* nameBegin, char const* nameEnd = nullptr)\n"
"        {\n"
"            return spReflectionTypeLayout_findFieldIndexByName((SlangReflectionTypeLayout*) this, nameBegin, nameEnd);\n"
"        }\n"
"\n"
"        bool isArray() { return getType()->isArray(); }\n"
"\n"
"        TypeLayoutReflection* unwrapArray()\n"
"        {\n"
"            TypeLayoutReflection* typeLayout = this;\n"
"            while( typeLayout->isArray() )\n"
"            {\n"
"                typeLayout = typeLayout->getElementTypeLayout();\n"
"            }\n"
"            return typeLayout;\n"
"        }\n"
"\n"
"        // only useful if `getKind() == Kind::Array`\n"
"        size_t getElementCount()\n"
"        {\n"
"            return getType()->getElementCount();\n"
"        }\n"
"\n"
"        size_t getTotalArrayElementCount()\n"
"        {\n"
"            return getType()->getTotalArrayElementCount();\n"
"        }\n"
"\n"
"        size_t getElementStride(SlangParameterCategory category)\n"
"        {\n"
"            return spReflectionTypeLayout_GetElementStride((SlangReflectionTypeLayout*) this, category);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getElementTypeLayout()\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflectionTypeLayout_GetElementTypeLayout((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getElementVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*)spReflectionTypeLayout_GetElementVarLayout((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getContainerVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*)spReflectionTypeLayout_getContainerVarLayout((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        // How is this type supposed to be bound?\n"
"        ParameterCategory getParameterCategory()\n"
"        {\n"
"            return (ParameterCategory) spReflectionTypeLayout_GetParameterCategory((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        unsigned int getCategoryCount()\n"
"        {\n"
"            return spReflectionTypeLayout_GetCategoryCount((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        ParameterCategory getCategoryByIndex(unsigned int index)\n"
"        {\n"
"            return (ParameterCategory) spReflectionTypeLayout_GetCategoryByIndex((SlangReflectionTypeLayout*) this, index);\n"
"        }\n"
"\n"
"        unsigned getRowCount()\n"
"        {\n"
"            return getType()->getRowCount();\n"
"        }\n"
"\n"
"        unsigned getColumnCount()\n"
"        {\n"
"            return getType()->getColumnCount();\n"
"        }\n"
"\n"
"        TypeReflection::ScalarType getScalarType()\n"
"        {\n"
"            return getType()->getScalarType();\n"
"        }\n"
"\n"
"        TypeReflection* getResourceResultType()\n"
"        {\n"
"            return getType()->getResourceResultType();\n"
"        }\n"
"\n"
"        SlangResourceShape getResourceShape()\n"
"        {\n"
"            return getType()->getResourceShape();\n"
"        }\n"
"\n"
"        SlangResourceAccess getResourceAccess()\n"
"        {\n"
"            return getType()->getResourceAccess();\n"
"        }\n"
"\n"
"        char const* getName()\n"
"        {\n"
"            return getType()->getName();\n"
"        }\n"
"\n"
"        SlangMatrixLayoutMode getMatrixLayoutMode()\n"
"        {\n"
"            return spReflectionTypeLayout_GetMatrixLayoutMode((SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        int getGenericParamIndex()\n"
"        {\n"
"            return spReflectionTypeLayout_getGenericParamIndex(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getPendingDataTypeLayout()\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflectionTypeLayout_getPendingDataTypeLayout(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getSpecializedTypePendingDataVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeCount()\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeCount(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        BindingType getBindingRangeType(SlangInt index)\n"
"        {\n"
"            return (BindingType) spReflectionTypeLayout_getBindingRangeType(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeBindingCount(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeBindingCount(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        /*\n"
"        SlangInt getBindingRangeIndexOffset(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeIndexOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeSpaceOffset(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeSpaceOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"        */\n"
"\n"
"        SlangInt getFieldBindingRangeOffset(SlangInt fieldIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getFieldBindingRangeOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                fieldIndex);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getBindingRangeLeafTypeLayout(SlangInt index)\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflectionTypeLayout_getBindingRangeLeafTypeLayout(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        VariableReflection* getBindingRangeLeafVariable(SlangInt index)\n"
"        {\n"
"            return (VariableReflection*)spReflectionTypeLayout_getBindingRangeLeafVariable(\n"
"                (SlangReflectionTypeLayout*)this, index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeDescriptorSetIndex(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeDescriptorSetIndex(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeFirstDescriptorRangeIndex(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getBindingRangeDescriptorRangeCount(SlangInt index)\n"
"        {\n"
"            return spReflectionTypeLayout_getBindingRangeDescriptorRangeCount(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                index);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetCount()\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetCount(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetSpaceOffset(SlangInt setIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetSpaceOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetDescriptorRangeCount(SlangInt setIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetDescriptorRangeIndexOffset(SlangInt setIndex, SlangInt rangeIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex,\n"
"                rangeIndex);\n"
"        }\n"
"\n"
"        SlangInt getDescriptorSetDescriptorRangeDescriptorCount(SlangInt setIndex, SlangInt rangeIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex,\n"
"                rangeIndex);\n"
"        }\n"
"\n"
"        BindingType getDescriptorSetDescriptorRangeType(SlangInt setIndex, SlangInt rangeIndex)\n"
"        {\n"
"            return (BindingType) spReflectionTypeLayout_getDescriptorSetDescriptorRangeType(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex,\n"
"                rangeIndex);\n"
"        }\n"
"\n"
"        ParameterCategory getDescriptorSetDescriptorRangeCategory(SlangInt setIndex, SlangInt rangeIndex)\n"
"        {\n"
"            return (ParameterCategory) spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                setIndex,\n"
"                rangeIndex);\n"
"        }\n"
"\n"
"        SlangInt getSubObjectRangeCount()\n"
"        {\n"
"            return spReflectionTypeLayout_getSubObjectRangeCount(\n"
"                (SlangReflectionTypeLayout*) this);\n"
"        }\n"
"\n"
"        SlangInt getSubObjectRangeBindingRangeIndex(SlangInt subObjectRangeIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                subObjectRangeIndex);\n"
"        }\n"
"\n"
"        SlangInt getSubObjectRangeSpaceOffset(SlangInt subObjectRangeIndex)\n"
"        {\n"
"            return spReflectionTypeLayout_getSubObjectRangeSpaceOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                subObjectRangeIndex);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getSubObjectRangeOffset(SlangInt subObjectRangeIndex)\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionTypeLayout_getSubObjectRangeOffset(\n"
"                (SlangReflectionTypeLayout*) this,\n"
"                subObjectRangeIndex);\n"
"        }\n"
"    };\n"
"\n"
"    struct Modifier\n"
"    {\n"
"        enum ID : SlangModifierID\n"
"        {\n"
"            Shared = SLANG_MODIFIER_SHARED,\n"
"        };\n"
"    };\n"
"\n"
"    struct VariableReflection\n"
"    {\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionVariable_GetName((SlangReflectionVariable*) this);\n"
"        }\n"
"\n"
"        TypeReflection* getType()\n"
"        {\n"
"            return (TypeReflection*) spReflectionVariable_GetType((SlangReflectionVariable*) this);\n"
"        }\n"
"\n"
"        Modifier* findModifier(Modifier::ID id)\n"
"        {\n"
"            return (Modifier*) spReflectionVariable_FindModifier((SlangReflectionVariable*) this, (SlangModifierID) id);\n"
"        }\n"
"\n"
"        unsigned int getUserAttributeCount()\n"
"        {\n"
"            return spReflectionVariable_GetUserAttributeCount((SlangReflectionVariable*)this);\n"
"        }\n"
"        UserAttribute* getUserAttributeByIndex(unsigned int index)\n"
"        {\n"
"            return (UserAttribute*)spReflectionVariable_GetUserAttribute((SlangReflectionVariable*)this, index);\n"
"        }\n"
"        UserAttribute* findUserAttributeByName(SlangSession* session, char const* name)\n"
"        {\n"
"            return (UserAttribute*)spReflectionVariable_FindUserAttributeByName((SlangReflectionVariable*)this, session, name);\n"
"        }\n"
"    };\n"
"\n"
"    struct VariableLayoutReflection\n"
"    {\n"
"        VariableReflection* getVariable()\n"
"        {\n"
"            return (VariableReflection*) spReflectionVariableLayout_GetVariable((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        char const* getName()\n"
"        {\n"
"            return getVariable()->getName();\n"
"        }\n"
"\n"
"        Modifier* findModifier(Modifier::ID id)\n"
"        {\n"
"            return getVariable()->findModifier(id);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getTypeLayout()\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflectionVariableLayout_GetTypeLayout((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        ParameterCategory getCategory()\n"
"        {\n"
"            return getTypeLayout()->getParameterCategory();\n"
"        }\n"
"\n"
"        unsigned int getCategoryCount()\n"
"        {\n"
"            return getTypeLayout()->getCategoryCount();\n"
"        }\n"
"\n"
"        ParameterCategory getCategoryByIndex(unsigned int index)\n"
"        {\n"
"            return getTypeLayout()->getCategoryByIndex(index);\n"
"        }\n"
"\n"
"\n"
"        size_t getOffset(SlangParameterCategory category = SLANG_PARAMETER_CATEGORY_UNIFORM)\n"
"        {\n"
"            return spReflectionVariableLayout_GetOffset((SlangReflectionVariableLayout*) this, category);\n"
"        }\n"
"\n"
"        TypeReflection* getType()\n"
"        {\n"
"            return getVariable()->getType();\n"
"        }\n"
"\n"
"        unsigned getBindingIndex()\n"
"        {\n"
"            return spReflectionParameter_GetBindingIndex((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        unsigned getBindingSpace()\n"
"        {\n"
"            return spReflectionParameter_GetBindingSpace((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        size_t getBindingSpace(SlangParameterCategory category)\n"
"        {\n"
"            return spReflectionVariableLayout_GetSpace((SlangReflectionVariableLayout*) this, category);\n"
"        }\n"
"\n"
"        char const* getSemanticName()\n"
"        {\n"
"            return spReflectionVariableLayout_GetSemanticName((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        size_t getSemanticIndex()\n"
"        {\n"
"            return spReflectionVariableLayout_GetSemanticIndex((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        SlangStage getStage()\n"
"        {\n"
"            return spReflectionVariableLayout_getStage((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getPendingDataLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionVariableLayout_getPendingDataLayout((SlangReflectionVariableLayout*) this);\n"
"        }\n"
"    };\n"
"\n"
"    struct EntryPointReflection\n"
"    {\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionEntryPoint_getName((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        char const* getNameOverride()\n"
"        {\n"
"            return spReflectionEntryPoint_getNameOverride((SlangReflectionEntryPoint*)this);\n"
"        }\n"
"\n"
"        unsigned getParameterCount()\n"
"        {\n"
"            return spReflectionEntryPoint_getParameterCount((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getParameterByIndex(unsigned index)\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionEntryPoint_getParameterByIndex((SlangReflectionEntryPoint*) this, index);\n"
"        }\n"
"\n"
"        SlangStage getStage()\n"
"        {\n"
"            return spReflectionEntryPoint_getStage((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        void getComputeThreadGroupSize(\n"
"            SlangUInt   axisCount,\n"
"            SlangUInt*  outSizeAlongAxis)\n"
"        {\n"
"            return spReflectionEntryPoint_getComputeThreadGroupSize((SlangReflectionEntryPoint*) this, axisCount, outSizeAlongAxis);\n"
"        }\n"
"\n"
"        bool usesAnySampleRateInput()\n"
"        {\n"
"            return 0 != spReflectionEntryPoint_usesAnySampleRateInput((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflectionEntryPoint_getVarLayout((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getTypeLayout()\n"
"        {\n"
"            return getVarLayout()->getTypeLayout();\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getResultVarLayout()\n"
;
sb << 
"        {\n"
"            return (VariableLayoutReflection*) spReflectionEntryPoint_getResultVarLayout((SlangReflectionEntryPoint*) this);\n"
"        }\n"
"\n"
"        bool hasDefaultConstantBuffer()\n"
"        {\n"
"            return spReflectionEntryPoint_hasDefaultConstantBuffer((SlangReflectionEntryPoint*) this) != 0;\n"
"        }\n"
"    };\n"
"    typedef EntryPointReflection EntryPointLayout;\n"
"\n"
"    struct TypeParameterReflection\n"
"    {\n"
"        char const* getName()\n"
"        {\n"
"            return spReflectionTypeParameter_GetName((SlangReflectionTypeParameter*) this);\n"
"        }\n"
"        unsigned getIndex()\n"
"        {\n"
"            return spReflectionTypeParameter_GetIndex((SlangReflectionTypeParameter*) this);\n"
"        }\n"
"        unsigned getConstraintCount()\n"
"        {\n"
"            return spReflectionTypeParameter_GetConstraintCount((SlangReflectionTypeParameter*) this);\n"
"        }\n"
"        TypeReflection* getConstraintByIndex(int index)\n"
"        {\n"
"            return (TypeReflection*)spReflectionTypeParameter_GetConstraintByIndex((SlangReflectionTypeParameter*) this, index);\n"
"        }\n"
"    };\n"
"\n"
"    enum class LayoutRules : SlangLayoutRules\n"
"    {\n"
"        Default = SLANG_LAYOUT_RULES_DEFAULT,\n"
"    };\n"
"\n"
"    typedef struct ShaderReflection ProgramLayout;\n"
"\n"
"    struct ShaderReflection\n"
"    {\n"
"        unsigned getParameterCount()\n"
"        {\n"
"            return spReflection_GetParameterCount((SlangReflection*) this);\n"
"        }\n"
"\n"
"        unsigned getTypeParameterCount()\n"
"        {\n"
"            return spReflection_GetTypeParameterCount((SlangReflection*) this);\n"
"        }\n"
"\n"
"        TypeParameterReflection* getTypeParameterByIndex(unsigned index)\n"
"        {\n"
"            return (TypeParameterReflection*)spReflection_GetTypeParameterByIndex((SlangReflection*) this, index);\n"
"        }\n"
"\n"
"        TypeParameterReflection* findTypeParameter(char const* name)\n"
"        {\n"
"            return (TypeParameterReflection*)spReflection_FindTypeParameter((SlangReflection*)this, name);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getParameterByIndex(unsigned index)\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflection_GetParameterByIndex((SlangReflection*) this, index);\n"
"        }\n"
"\n"
"        static ProgramLayout* get(SlangCompileRequest* request)\n"
"        {\n"
"            return (ProgramLayout*) spGetReflection(request);\n"
"        }\n"
"\n"
"        SlangUInt getEntryPointCount()\n"
"        {\n"
"            return spReflection_getEntryPointCount((SlangReflection*) this);\n"
"        }\n"
"\n"
"        EntryPointReflection* getEntryPointByIndex(SlangUInt index)\n"
"        {\n"
"            return (EntryPointReflection*) spReflection_getEntryPointByIndex((SlangReflection*) this, index);\n"
"        }\n"
"\n"
"        SlangUInt getGlobalConstantBufferBinding()\n"
"        {\n"
"            return spReflection_getGlobalConstantBufferBinding((SlangReflection*)this);\n"
"        }\n"
"\n"
"        size_t getGlobalConstantBufferSize()\n"
"        {\n"
"            return spReflection_getGlobalConstantBufferSize((SlangReflection*)this);\n"
"        }\n"
"\n"
"        TypeReflection* findTypeByName(const char* name)\n"
"        {\n"
"            return (TypeReflection*)spReflection_FindTypeByName(\n"
"                (SlangReflection*) this,\n"
"                name);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getTypeLayout(\n"
"            TypeReflection* type,\n"
"            LayoutRules     rules = LayoutRules::Default)\n"
"        {\n"
"            return (TypeLayoutReflection*)spReflection_GetTypeLayout(\n"
"                (SlangReflection*) this,\n"
"                (SlangReflectionType*)type,\n"
"                SlangLayoutRules(rules));\n"
"        }\n"
"\n"
"        EntryPointReflection* findEntryPointByName(const char* name)\n"
"        {\n"
"            return (EntryPointReflection*)spReflection_findEntryPointByName(\n"
"                (SlangReflection*) this,\n"
"                name);\n"
"        }\n"
"\n"
"        TypeReflection* specializeType(\n"
"            TypeReflection*         type,\n"
"            SlangInt                specializationArgCount,\n"
"            TypeReflection* const*  specializationArgs,\n"
"            ISlangBlob**            outDiagnostics)\n"
"        {\n"
"            return (TypeReflection*) spReflection_specializeType(\n"
"                (SlangReflection*) this,\n"
"                (SlangReflectionType*) type,\n"
"                specializationArgCount,\n"
"                (SlangReflectionType* const*) specializationArgs,\n"
"                outDiagnostics);\n"
"        }\n"
"\n"
"        SlangUInt getHashedStringCount() const { return spReflection_getHashedStringCount((SlangReflection*)this); }\n"
"\n"
"        const char* getHashedString(SlangUInt index, size_t* outCount) const\n"
"        {\n"
"            return spReflection_getHashedString((SlangReflection*)this, index, outCount);\n"
"        }\n"
"\n"
"        TypeLayoutReflection* getGlobalParamsTypeLayout()\n"
"        {\n"
"            return (TypeLayoutReflection*) spReflection_getGlobalParamsTypeLayout((SlangReflection*) this);\n"
"        }\n"
"\n"
"        VariableLayoutReflection* getGlobalParamsVarLayout()\n"
"        {\n"
"            return (VariableLayoutReflection*) spReflection_getGlobalParamsVarLayout((SlangReflection*) this);\n"
"        }\n"
"    };\n"
"\n"
"    typedef uint32_t CompileStdLibFlags;\n"
"    struct CompileStdLibFlag\n"
"    {\n"
"        enum Enum : CompileStdLibFlags\n"
"        {\n"
"            WriteDocumentation = 0x1,\n"
"        };\n"
"    };\n"
"\n"
"    typedef ISlangBlob IBlob;\n"
"\n"
"    struct IComponentType;\n"
"    struct ITypeConformance;\n"
"    struct IGlobalSession;\n"
"    struct IModule;\n"
"    struct ISession;\n"
"\n"
"    struct SessionDesc;\n"
"    struct SpecializationArg;\n"
"    struct TargetDesc;\n"
"\n"
"        /** A global session for interaction with the Slang library.\n"
"\n"
"        An application may create and re-use a single global session across\n"
"        multiple sessions, in order to amortize startups costs (in current\n"
"        Slang this is mostly the cost of loading the Slang standard library).\n"
"\n"
"        The global session is currently *not* thread-safe and objects created from\n"
"        a single global session should only be used from a single thread at\n"
"        a time.\n"
"        */\n"
"    struct IGlobalSession : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0xc140b5fd, 0xc78, 0x452e, { 0xba, 0x7c, 0x1a, 0x1e, 0x70, 0xc7, 0xf7, 0x1c })\n"
"\n"
"            /** Create a new session for loading and compiling code.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createSession(\n"
"            SessionDesc const&  desc,\n"
"            ISession**          outSession) = 0;\n"
"\n"
"            /** Look up the internal ID of a profile by its `name`.\n"
"\n"
"            Profile IDs are *not* guaranteed to be stable across versions\n"
"            of the Slang library, so clients are expected to look up\n"
"            profiles by name at runtime.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangProfileID SLANG_MCALL findProfile(\n"
"            char const*     name) = 0;\n"
"\n"
"            /** Set the path that downstream compilers (aka back end compilers) will\n"
"            be looked from.\n"
"            @param passThrough Identifies the downstream compiler\n"
"            @param path The path to find the downstream compiler (shared library/dll/executable)\n"
"\n"
"            For back ends that are dlls/shared libraries, it will mean the path will\n"
"            be prefixed with the path when calls are made out to ISlangSharedLibraryLoader.\n"
"            For executables - it will look for executables along the path */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDownstreamCompilerPath(\n"
"            SlangPassThrough passThrough,\n"
"            char const* path) = 0;\n"
"\n"
"            /** DEPRECIATED: Use setLanguagePrelude\n"
"\n"
"            Set the 'prelude' for generated code for a 'downstream compiler'.\n"
"            @param passThrough The downstream compiler for generated code that will have the prelude applied to it. \n"
"            @param preludeText The text added pre-pended verbatim before the generated source\n"
"\n"
"            That for pass-through usage, prelude is not pre-pended, preludes are for code generation only. \n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDownstreamCompilerPrelude(\n"
"            SlangPassThrough passThrough,\n"
"            const char* preludeText) = 0;\n"
"\n"
"            /** DEPRECIATED: Use getLanguagePrelude\n"
"\n"
"            Get the 'prelude' for generated code for a 'downstream compiler'.\n"
"            @param passThrough The downstream compiler for generated code that will have the prelude applied to it. \n"
"            @param outPrelude  On exit holds a blob that holds the string of the prelude.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL getDownstreamCompilerPrelude(\n"
"            SlangPassThrough passThrough,\n"
"            ISlangBlob** outPrelude) = 0;\n"
"\n"
"            /** Get the build version 'tag' string. The string is the same as produced via `git describe --tags`\n"
"            for the project. If Slang is built separately from the automated build scripts\n"
"            the contents will by default be 'unknown'. Any string can be set by changing the\n"
"            contents of 'slang-tag-version.h' file and recompiling the project.\n"
"\n"
"            This method will return exactly the same result as the free function spGetBuildTagString.\n"
"\n"
"            @return The build tag string\n"
"            */\n"
"        virtual SLANG_NO_THROW const char* SLANG_MCALL getBuildTagString() = 0;\n"
"\n"
"            /* For a given source language set the default compiler.\n"
"            If a default cannot be chosen (for example the target cannot be achieved by the default),\n"
"            the default will not be used. \n"
"\n"
"            @param sourceLanguage the source language \n"
"            @param defaultCompiler the default compiler for that language\n"
"            @return \n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setDefaultDownstreamCompiler(\n"
"            SlangSourceLanguage sourceLanguage,\n"
"            SlangPassThrough defaultCompiler) = 0;\n"
"\n"
"            /* For a source type get the default compiler \n"
"\n"
"            @param sourceLanguage the source language \n"
"            @return The downstream compiler for that source language */\n"
"        virtual SlangPassThrough SLANG_MCALL getDefaultDownstreamCompiler(\n"
"            SlangSourceLanguage sourceLanguage) = 0;\n"
"\n"
"            /* Set the 'prelude' placed before generated code for a specific language type.\n"
"            \n"
"            @param sourceLanguage The language the prelude should be inserted on.\n"
"            @param preludeText The text added pre-pended verbatim before the generated source\n"
"\n"
"            Note! That for pass-through usage, prelude is not pre-pended, preludes are for code generation only. \n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setLanguagePrelude(\n"
"            SlangSourceLanguage sourceLanguage,\n"
"            const char* preludeText) = 0;\n"
"\n"
"            /** Get the 'prelude' associated with a specific source language. \n"
"            @param sourceLanguage The language the prelude should be inserted on.\n"
"            @param outPrelude  On exit holds a blob that holds the string of the prelude.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL getLanguagePrelude(\n"
"            SlangSourceLanguage sourceLanguage,\n"
"            ISlangBlob** outPrelude) = 0;\n"
"\n"
"            /** Create a compile request.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createCompileRequest(\n"
"            slang::ICompileRequest** outCompileRequest) = 0;\n"
"\n"
"            /** Add new builtin declarations to be used in subsequent compiles.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addBuiltins(\n"
"            char const*     sourcePath,\n"
"            char const*     sourceString) = 0;\n"
"\n"
"            /** Set the session shared library loader. If this changes the loader, it may cause shared libraries to be unloaded\n"
"            @param loader The loader to set. Setting nullptr sets the default loader. \n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setSharedLibraryLoader(\n"
"            ISlangSharedLibraryLoader* loader) = 0;\n"
"\n"
"            /** Gets the currently set shared library loader\n"
"            @return Gets the currently set loader. If returns nullptr, it's the default loader\n"
"            */\n"
"        virtual SLANG_NO_THROW ISlangSharedLibraryLoader* SLANG_MCALL getSharedLibraryLoader() = 0;\n"
"\n"
"            /** Returns SLANG_OK if a the compilation target is supported for this session\n"
"            \n"
"            @param target The compilation target to test\n"
"            @return SLANG_OK if the target is available\n"
"            SLANG_E_NOT_IMPLEMENTED if not implemented in this build\n"
"            SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work could not be found\n"
"            SLANG_FAIL other kinds of failures */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL checkCompileTargetSupport(\n"
"            SlangCompileTarget  target) = 0;\n"
"\n"
"            /** Returns SLANG_OK if a the pass through support is supported for this session\n"
"            @param session Session\n"
"            @param target The compilation target to test\n"
"            @return SLANG_OK if the target is available\n"
"            SLANG_E_NOT_IMPLEMENTED if not implemented in this build\n"
"            SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work could not be found\n"
"            SLANG_FAIL other kinds of failures */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL checkPassThroughSupport(\n"
"            SlangPassThrough    passThrough) = 0;\n"
"\n"
"            /** Compile from (embedded source) the StdLib on the session.\n"
"            Will return a failure if there is already a StdLib available\n"
"            NOTE! API is experimental and not ready for production code\n"
"            @param flags to control compilation\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL compileStdLib(CompileStdLibFlags flags) = 0;\n"
"\n"
"            /** Load the StdLib. Currently loads modules from the file system. \n"
"            @param stdLib Start address of the serialized stdlib\n"
"            @param stdLibSizeInBytes The size in bytes of the serialized stdlib\n"
"\n"
"            NOTE! API is experimental and not ready for production code\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadStdLib(const void* stdLib, size_t stdLibSizeInBytes) = 0;\n"
"\n"
"            /** Save the StdLib modules to the file system\n"
"            @param archiveType The type of archive used to hold the stdlib\n"
"            @param outBlob The serialized blob containing the standard library\n"
"\n"
"            NOTE! API is experimental and not ready for production code  */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveStdLib(SlangArchiveType archiveType, ISlangBlob** outBlob) = 0;\n"
"\n"
"            /** Look up the internal ID of a capability by its `name`.\n"
"\n"
"            Capability IDs are *not* guaranteed to be stable across versions\n"
"            of the Slang library, so clients are expected to look up\n"
"            capabilities by name at runtime.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangCapabilityID SLANG_MCALL findCapability(\n"
"            char const*     name) = 0;\n"
"\n"
"            /** Set the downstream/pass through compiler to be used for a transition from the source type to the target type\n"
"            @param source The source 'code gen target'\n"
"            @param target The target 'code gen target'\n"
"            @param compiler The compiler/pass through to use for the transition from source to target\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDownstreamCompilerForTransition(SlangCompileTarget source, SlangCompileTarget target, SlangPassThrough compiler) = 0;\n"
"\n"
"            /** Get the downstream/pass through compiler for a transition specified by source and target\n"
"            @param source The source 'code gen target'\n"
"            @param target The target 'code gen target'\n"
"            @return The compiler that is used for the transition. Returns SLANG_PASS_THROUGH_NONE it is not defined\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangPassThrough SLANG_MCALL getDownstreamCompilerForTransition(SlangCompileTarget source, SlangCompileTarget target) = 0;\n"
"\n"
"            /** Get the time in seconds spent in the downstream compiler.\n"
"            @return The time spent in the downstream compiler in the current global session.\n"
"            */\n"
"        virtual SLANG_NO_THROW double SLANG_MCALL getDownstreamCompilerElapsedTime() = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_IGlobalSession IGlobalSession::getTypeGuid()\n"
"\n"
"    /*!\n"
"    @brief A request for one or more compilation actions to be performed.\n"
"    */\n"
"    struct ICompileRequest : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE( 0x96d33993, 0x317c, 0x4db5, { 0xaf, 0xd8, 0x66, 0x6e, 0xe7, 0x72, 0x48, 0xe2 } )\n"
"   \n"
"            /** Set the filesystem hook to use for a compile request\n"
"\n"
"            The provided `fileSystem` will be used to load any files that\n"
"            need to be loaded during processing of the compile `request`.\n"
"            This includes:\n"
"\n"
;
sb << 
"              - Source files loaded via `spAddTranslationUnitSourceFile`\n"
"              - Files referenced via `#include`\n"
"              - Files loaded to resolve `#import` operations\n"
"                */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setFileSystem(\n"
"            ISlangFileSystem*       fileSystem) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set flags to be used for compilation.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setCompileFlags(\n"
"            SlangCompileFlags       flags) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set whether to dump intermediate results (for debugging) or not.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDumpIntermediates(\n"
"            int                     enable) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDumpIntermediatePrefix(\n"
"            const char* prefix) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set whether (and how) `#line` directives should be output.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setLineDirectiveMode(\n"
"            SlangLineDirectiveMode  mode) = 0;\n"
"\n"
"            /*!\n"
"            @brief Sets the target for code generation.\n"
"            @param target The code generation target. Possible values are:\n"
"            - SLANG_GLSL. Generates GLSL code.\n"
"            - SLANG_HLSL. Generates HLSL code.\n"
"            - SLANG_SPIRV. Generates SPIR-V code.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setCodeGenTarget(\n"
"            SlangCompileTarget target) = 0;\n"
"\n"
"            /*!\n"
"            @brief Add a code-generation target to be used.\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL addCodeGenTarget(\n"
"            SlangCompileTarget      target) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetProfile(\n"
"            int                     targetIndex,\n"
"            SlangProfileID          profile) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetFlags(\n"
"            int                     targetIndex,\n"
"            SlangTargetFlags        flags) = 0;\n"
"\n"
"\n"
"            /*!\n"
"            @brief Set the floating point mode (e.g., precise or fast) to use a target.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetFloatingPointMode(\n"
"            int                     targetIndex,\n"
"            SlangFloatingPointMode  mode) = 0;\n"
"\n"
"            /* DEPRECATED: use `spSetMatrixLayoutMode` instead. */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetMatrixLayoutMode(\n"
"            int                     targetIndex,\n"
"            SlangMatrixLayoutMode   mode) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setMatrixLayoutMode(\n"
"            SlangMatrixLayoutMode   mode) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set the level of debug information to produce.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDebugInfoLevel(\n"
"            SlangDebugInfoLevel     level) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set the level of optimization to perform.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setOptimizationLevel(\n"
"            SlangOptimizationLevel  level) = 0;\n"
"\n"
"\n"
"    \n"
"            /*!\n"
"            @brief Set the container format to be used for binary output.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setOutputContainerFormat(\n"
"            SlangContainerFormat    format) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setPassThrough(\n"
"            SlangPassThrough        passThrough) = 0;\n"
"\n"
"    \n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDiagnosticCallback(\n"
"            SlangDiagnosticCallback callback,\n"
"            void const*             userData) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setWriter(\n"
"            SlangWriterChannel      channel, \n"
"            ISlangWriter*           writer) = 0;\n"
"\n"
"        virtual SLANG_NO_THROW ISlangWriter* SLANG_MCALL getWriter(\n"
"            SlangWriterChannel      channel) = 0;\n"
"\n"
"            /*!\n"
"            @brief Add a path to use when searching for referenced files.\n"
"            This will be used for both `#include` directives and also for explicit `__import` declarations.\n"
"            @param ctx The compilation context.\n"
"            @param searchDir The additional search directory.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addSearchPath(\n"
"            const char*             searchDir) = 0;\n"
"\n"
"            /*!\n"
"            @brief Add a macro definition to be used during preprocessing.\n"
"            @param key The name of the macro to define.\n"
"            @param value The value of the macro to define.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addPreprocessorDefine(\n"
"            const char*             key,\n"
"            const char*             value) = 0;\n"
"\n"
"            /*!\n"
"            @brief Set options using arguments as if specified via command line.\n"
"            @return Returns SlangResult. On success SLANG_SUCCEEDED(result) is true.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL processCommandLineArguments(\n"
"            char const* const*      args,\n"
"            int                     argCount) = 0;\n"
"\n"
"            /** Add a distinct translation unit to the compilation request\n"
"\n"
"            `name` is optional. \n"
"            Returns the zero-based index of the translation unit created.\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL addTranslationUnit(\n"
"            SlangSourceLanguage     language,\n"
"            char const*             name) = 0;\n"
"\n"
"    \n"
"            /** Set a default module name. Translation units will default to this module name if one is not\n"
"            passed. If not set each translation unit will get a unique name. \n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setDefaultModuleName(\n"
"            const char* defaultModuleName) = 0;\n"
"\n"
"            /** Add a preprocessor definition that is scoped to a single translation unit.\n"
"\n"
"            @param translationUnitIndex The index of the translation unit to get the definition.\n"
"            @param key The name of the macro to define.\n"
"            @param value The value of the macro to define.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitPreprocessorDefine(\n"
"            int                     translationUnitIndex,\n"
"            const char*             key,\n"
"            const char*             value) = 0;\n"
"\n"
"\n"
"            /** Add a source file to the given translation unit.\n"
"\n"
"            If a user-defined file system has been specified via\n"
"            `spSetFileSystem`, then it will be used to load the\n"
"            file at `path`. Otherwise, Slang will use the OS\n"
"            file system.\n"
"\n"
"            This function does *not* search for a file using\n"
"            the registered search paths (`spAddSearchPath`),\n"
"            and instead using the given `path` as-is.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceFile(\n"
"            int                     translationUnitIndex,\n"
"            char const*             path) = 0;\n"
"\n"
"            /** Add a source string to the given translation unit.\n"
"\n"
"            @param translationUnitIndex The index of the translation unit to add source to.\n"
"            @param path The file-system path that should be assumed for the source code.\n"
"            @param source A null-terminated UTF-8 encoded string of source code.\n"
"\n"
"            The implementation will make a copy of the source code data.\n"
"            An application may free the buffer immediately after this call returns.\n"
"\n"
"            The `path` will be used in any diagnostic output, as well\n"
"            as to determine the base path when resolving relative\n"
"            `#include`s.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceString(\n"
"            int                     translationUnitIndex,\n"
"            char const*             path,\n"
"            char const*             source) = 0;\n"
"\n"
"\n"
"            /** Add a slang library - such that its contents can be referenced during linking.\n"
"            This is equivalent to the -r command line option.\n"
"\n"
"            @param libData The library data\n"
"            @param libDataSize The size of the library data\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL addLibraryReference(\n"
"            const void* libData,\n"
"            size_t libDataSize) = 0;\n"
"\n"
"            /** Add a source string to the given translation unit.\n"
"\n"
"            @param translationUnitIndex The index of the translation unit to add source to.\n"
"            @param path The file-system path that should be assumed for the source code.\n"
"            @param sourceBegin A pointer to a buffer of UTF-8 encoded source code.\n"
"            @param sourceEnd A pointer to to the end of the buffer specified in `sourceBegin`\n"
"\n"
"            The implementation will make a copy of the source code data.\n"
"            An application may free the buffer immediately after this call returns.\n"
"\n"
"            The `path` will be used in any diagnostic output, as well\n"
"            as to determine the base path when resolving relative\n"
"            `#include`s.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceStringSpan(\n"
"            int                     translationUnitIndex,\n"
"            char const*             path,\n"
"            char const*             sourceBegin,\n"
"            char const*             sourceEnd) = 0;\n"
"\n"
"            /** Add a blob of source code to the given translation unit.\n"
"\n"
"            @param translationUnitIndex The index of the translation unit to add source to.\n"
"            @param path The file-system path that should be assumed for the source code.\n"
"            @param sourceBlob A blob containing UTF-8 encoded source code.\n"
"            @param sourceEnd A pointer to to the end of the buffer specified in `sourceBegin`\n"
"\n"
"            The compile request will retain a reference to the blob.\n"
"\n"
"            The `path` will be used in any diagnostic output, as well\n"
"            as to determine the base path when resolving relative\n"
"            `#include`s.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceBlob(\n"
"            int                     translationUnitIndex,\n"
"            char const*             path,\n"
"            ISlangBlob*             sourceBlob) = 0;\n"
"\n"
"            /** Add an entry point in a particular translation unit\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL addEntryPoint(\n"
"            int                     translationUnitIndex,\n"
"            char const*             name,\n"
"            SlangStage              stage) = 0;\n"
"\n"
"            /** Add an entry point in a particular translation unit,\n"
"                with additional arguments that specify the concrete\n"
"                type names for entry-point generic type parameters.\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL addEntryPointEx(\n"
"            int                     translationUnitIndex,\n"
"            char const*             name,\n"
"            SlangStage              stage,\n"
"            int                     genericArgCount,\n"
"            char const**            genericArgs) = 0;\n"
"\n"
"            /** Specify the arguments to use for global generic parameters.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setGlobalGenericArgs(\n"
"            int                     genericArgCount,\n"
"            char const**            genericArgs) = 0;\n"
"\n"
"            /** Specify the concrete type to be used for a global \"existential slot.\"\n"
"\n"
"            Every shader parameter (or leaf field of a `struct`-type shader parameter)\n"
"            that has an interface or array-of-interface type introduces an existential\n"
"            slot. The number of slots consumed by a shader parameter, and the starting\n"
"            slot of each parameter can be queried via the reflection API using\n"
"            `SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM`.\n"
"\n"
"            In order to generate specialized code, a concrete type needs to be specified\n"
"            for each existential slot. This function specifies the name of the type\n"
"            (or in general a type *expression*) to use for a specific slot at the\n"
"            global scope.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setTypeNameForGlobalExistentialTypeParam(\n"
"            int                     slotIndex,\n"
"            char const*             typeName) = 0;\n"
"\n"
"            /** Specify the concrete type to be used for an entry-point \"existential slot.\"\n"
"\n"
"            Every shader parameter (or leaf field of a `struct`-type shader parameter)\n"
"            that has an interface or array-of-interface type introduces an existential\n"
"            slot. The number of slots consumed by a shader parameter, and the starting\n"
"            slot of each parameter can be queried via the reflection API using\n"
"            `SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM`.\n"
"\n"
"            In order to generate specialized code, a concrete type needs to be specified\n"
"            for each existential slot. This function specifies the name of the type\n"
"            (or in general a type *expression*) to use for a specific slot at the\n"
"            entry-point scope.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setTypeNameForEntryPointExistentialTypeParam(\n"
"            int                     entryPointIndex,\n"
"            int                     slotIndex,\n"
"            char const*             typeName) = 0;\n"
"\n"
"            /** Execute the compilation request.\n"
"\n"
"            @returns  SlangResult, SLANG_OK on success. Use SLANG_SUCCEEDED() and SLANG_FAILED() to test SlangResult.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL compile() = 0;\n"
"\n"
"\n"
"            /** Get any diagnostic messages reported by the compiler.\n"
"\n"
"            @returns A null-terminated UTF-8 encoded string of diagnostic messages.\n"
"\n"
"            The returned pointer is only guaranteed to be valid\n"
"            until `request` is destroyed. Applications that wish to\n"
"            hold on to the diagnostic output for longer should use\n"
"            `getDiagnosticOutputBlob`.\n"
"            */\n"
"        virtual SLANG_NO_THROW char const* SLANG_MCALL getDiagnosticOutput() = 0;\n"
"\n"
"            /** Get diagnostic messages reported by the compiler.\n"
"\n"
"            @param outBlob A pointer to receive a blob holding a nul-terminated UTF-8 encoded string of diagnostic messages.\n"
"            @returns A `SlangResult` indicating success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getDiagnosticOutputBlob(\n"
"            ISlangBlob**            outBlob) = 0;\n"
"\n"
"\n"
"            /** Get the number of files that this compilation depended on.\n"
"\n"
"            This includes both the explicit source files, as well as any\n"
"            additional files that were transitively referenced (e.g., via\n"
"            a `#include` directive).\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL getDependencyFileCount() = 0;\n"
"\n"
"            /** Get the path to a file this compilation depended on.\n"
"            */\n"
"        virtual SLANG_NO_THROW char const* SLANG_MCALL getDependencyFilePath(\n"
"            int                     index) = 0;\n"
"\n"
"            /** Get the number of translation units associated with the compilation request\n"
"            */\n"
"        virtual SLANG_NO_THROW int SLANG_MCALL getTranslationUnitCount() = 0;\n"
"\n"
"            /** Get the output source code associated with a specific entry point.\n"
"\n"
"            The lifetime of the output pointer is the same as `request`.\n"
"            */\n"
"        virtual SLANG_NO_THROW char const* SLANG_MCALL getEntryPointSource(\n"
"            int                     entryPointIndex) = 0;\n"
"\n"
"            /** Get the output bytecode associated with a specific entry point.\n"
"\n"
"            The lifetime of the output pointer is the same as `request`.\n"
"            */\n"
"        virtual SLANG_NO_THROW void const* SLANG_MCALL getEntryPointCode(\n"
"            int                     entryPointIndex,\n"
"            size_t*                 outSize) = 0;\n"
"\n"
"            /** Get the output code associated with a specific entry point.\n"
"\n"
"            @param entryPointIndex The index of the entry point to get code for.\n"
"            @param targetIndex The index of the target to get code for (default: zero).\n"
"            @param outBlob A pointer that will receive the blob of code\n"
"            @returns A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCodeBlob(\n"
"            int                     entryPointIndex,\n"
"            int                     targetIndex,\n"
"            ISlangBlob**            outBlob) = 0;\n"
"\n"
"            /** Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.\n"
"\n"
;
sb << 
"            That the functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"            NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"    \n"
"            @param entryPointIndex  The index of the entry point to get code for.\n"
"            @param targetIndex      The index of the target to get code for (default: zero).\n"
"            @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried on.\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n"
"            int                     entryPointIndex,\n"
"            int                     targetIndex,\n"
"            ISlangSharedLibrary**   outSharedLibrary) = 0;\n"
"\n"
"            /** Get the output code associated with a specific target.\n"
"\n"
"            @param targetIndex The index of the target to get code for (default: zero).\n"
"            @param outBlob A pointer that will receive the blob of code\n"
"            @returns A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCodeBlob(\n"
"            int                     targetIndex,\n"
"            ISlangBlob**            outBlob) = 0;\n"
"\n"
"            /** Get 'callable' functions for a target accessible through the ISlangSharedLibrary interface.\n"
"\n"
"            That the functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"            NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"    \n"
"            @param targetIndex      The index of the target to get code for (default: zero).\n"
"            @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried on.\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTargetHostCallable(\n"
"            int                     targetIndex,\n"
"            ISlangSharedLibrary**   outSharedLibrary) = 0;\n"
"\n"
"            /** Get the output bytecode associated with an entire compile request.\n"
"\n"
"            The lifetime of the output pointer is the same as `request` and the last spCompile.\n"
"\n"
"            @param outSize          The size of the containers contents in bytes. Will be zero if there is no code available.\n"
"            @returns                Pointer to start of the contained data, or nullptr if there is no code available.\n"
"            */\n"
"        virtual SLANG_NO_THROW void const* SLANG_MCALL getCompileRequestCode(\n"
"            size_t*                 outSize) = 0;\n"
"\n"
"            /** Return the container code as a blob. The container blob is created as part of a compilation (with spCompile),\n"
"            and a container is produced with a suitable ContainerFormat. \n"
"\n"
"            @param outSize          The blob containing the container data. \n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getContainerCode(\n"
"            ISlangBlob**            outBlob) = 0;\n"
"\n"
"            /** Load repro from memory specified.\n"
"\n"
"            Should only be performed on a newly created request.\n"
"\n"
"            NOTE! When using the fileSystem, files will be loaded via their `unique names` as if they are part of the flat file system. This\n"
"            mechanism is described more fully in docs/repro.md.\n"
"\n"
"            @param fileSystem       An (optional) filesystem. Pass nullptr to just use contents of repro held in data.\n"
"            @param data             The data to load from.\n"
"            @param size             The size of the data to load from. \n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadRepro(\n"
"            ISlangFileSystem* fileSystem,\n"
"            const void* data,\n"
"            size_t size) = 0;\n"
"\n"
"            /** Save repro state. Should *typically* be performed after spCompile, so that everything\n"
"            that is needed for a compilation is available. \n"
"\n"
"            @param outBlob          Blob that will hold the serialized state\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveRepro(\n"
"            ISlangBlob** outBlob) = 0;\n"
"\n"
"            /** Enable repro capture.\n"
"\n"
"            Should be set after any ISlangFileSystem has been set, but before any compilation. It ensures that everything\n"
"            that the ISlangFileSystem accesses will be correctly recorded.\n"
"            Note that if a ISlangFileSystem/ISlangFileSystemExt isn't explicitly set (ie the default is used), then the\n"
"            request will automatically be set up to record everything appropriate. \n"
"\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL enableReproCapture() = 0;\n"
"\n"
"            /** Get the (linked) program for a compile request.\n"
"\n"
"            The linked program will include all of the global-scope modules for the\n"
"            translation units in the program, plus any modules that they `import`\n"
"            (transitively), specialized to any global specialization arguments that\n"
"            were provided via the API.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getProgram(\n"
"            slang::IComponentType** outProgram) = 0;\n"
"\n"
"            /** Get the (partially linked) component type for an entry point.\n"
"\n"
"            The returned component type will include the entry point at the\n"
"            given index, and will be specialized using any specialization arguments\n"
"            that were provided for it via the API.\n"
"\n"
"            The returned component will *not* include the modules representing\n"
"            the global scope and its dependencies/specialization, so a client\n"
"            program will typically want to compose this component type with\n"
"            the one returned by `spCompileRequest_getProgram` to get a complete\n"
"            and usable component type from which kernel code can be requested.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPoint(\n"
"            SlangInt                entryPointIndex,\n"
"            slang::IComponentType** outEntryPoint) = 0;\n"
"\n"
"            /** Get the (un-linked) module for a translation unit.\n"
"\n"
"            The returned module will not be linked against any dependencies,\n"
"            nor against any entry points (even entry points declared inside\n"
"            the module). Similarly, the module will not be specialized\n"
"            to the arguments that might have been provided via the API.\n"
"\n"
"            This function provides an atomic unit of loaded code that\n"
"            is suitable for looking up types and entry points in the\n"
"            given module, and for linking together to produce a composite\n"
"            program that matches the needs of an application.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getModule(\n"
"            SlangInt                translationUnitIndex,\n"
"            slang::IModule**        outModule) = 0;\n"
"\n"
"            /** Get the `ISession` handle behind the `SlangCompileRequest`.\n"
"            TODO(JS): Arguably this should just return the session pointer.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getSession(\n"
"            slang::ISession** outSession) = 0;\n"
"\n"
"            /** get reflection data from a compilation request */\n"
"        virtual SLANG_NO_THROW SlangReflection* SLANG_MCALL getReflection() = 0;\n"
"\n"
"            /** Make output specially handled for command line output */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setCommandLineCompilerMode() = 0;\n"
"\n"
"            /** Add a defined capability that should be assumed available on the target */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL addTargetCapability(\n"
"            SlangInt            targetIndex,\n"
"            SlangCapabilityID   capability) = 0;\n"
"\n"
"            /** Get the (linked) program for a compile request, including all entry points.\n"
"\n"
"            The resulting program will include all of the global-scope modules for the\n"
"            translation units in the program, plus any modules that they `import`\n"
"            (transitively), specialized to any global specialization arguments that\n"
"            were provided via the API, as well as all entry points specified for compilation,\n"
"            specialized to their entry-point specialization arguments.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getProgramWithEntryPoints(\n"
"            slang::IComponentType** outProgram) = 0;\n"
"\n"
"            /** Set the line directive mode for a target.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetLineDirectiveMode(\n"
"            SlangInt targetIndex,\n"
"            SlangLineDirectiveMode mode) = 0;\n"
"\n"
"            /** Set whether to use scalar buffer layouts for GLSL/Vulkan targets.\n"
"                If true, the generated GLSL/Vulkan code will use `scalar` layout for storage buffers.\n"
"                If false, the resulting code will std430 for storage buffers.\n"
"            */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL setTargetForceGLSLScalarBufferLayout(int targetIndex, bool forceScalarLayout) = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_ICompileRequest ICompileRequest::getTypeGuid()\n"
"\n"
"        /** Description of a code generation target.\n"
"        */\n"
"    struct TargetDesc\n"
"    {\n"
"            /** The size of this structure, in bytes.\n"
"            */\n"
"        size_t structureSize = sizeof(TargetDesc);\n"
"\n"
"            /** The target format to generate code for (e.g., SPIR-V, DXIL, etc.)\n"
"            */\n"
"        SlangCompileTarget      format = SLANG_TARGET_UNKNOWN;\n"
"\n"
"            /** The compilation profile supported by the target (e.g., \"Shader Model 5.1\")\n"
"            */\n"
"        SlangProfileID          profile = SLANG_PROFILE_UNKNOWN;\n"
"\n"
"            /** Flags for the code generation target. Currently unused. */\n"
"        SlangTargetFlags        flags = 0;\n"
"\n"
"            /** Default mode to use for floating-point operations on the target.\n"
"            */\n"
"        SlangFloatingPointMode  floatingPointMode = SLANG_FLOATING_POINT_MODE_DEFAULT;\n"
"\n"
"            /** Optimization level to use for the target.\n"
"            */\n"
"        SlangOptimizationLevel optimizationLevel = SLANG_OPTIMIZATION_LEVEL_DEFAULT;\n"
"\n"
"            /** The line directive mode for output source code.\n"
"            */\n"
"        SlangLineDirectiveMode lineDirectiveMode = SLANG_LINE_DIRECTIVE_MODE_DEFAULT;\n"
"\n"
"            /** Whether to force `scalar` layout for glsl shader storage buffers.\n"
"            */\n"
"        bool forceGLSLScalarBufferLayout = false;\n"
"    };\n"
"\n"
"    typedef uint32_t SessionFlags;\n"
"    enum\n"
"    {\n"
"        kSessionFlags_None = 0,\n"
"\n"
"        /** Use application-specific policy for semantics of the `shared` keyword.\n"
"        \n"
"        This is a legacy/compatibility flag to help an existing Slang client\n"
"        migrate to new language features, and should *not* be used by other\n"
"        clients. This feature may be removed in a future release without a\n"
"        deprecation warning, and this bit may be re-used for another feature.\n"
"        You have been warned.\n"
"        */\n"
"        kSessionFlag_FalcorCustomSharedKeywordSemantics = 1 << 0,\n"
"    };\n"
"\n"
"    struct PreprocessorMacroDesc\n"
"    {\n"
"        const char* name;\n"
"        const char* value;\n"
"    };\n"
"\n"
"    struct SessionDesc\n"
"    {\n"
"            /** The size of this structure, in bytes.\n"
"             */\n"
"        size_t structureSize = sizeof(SessionDesc);\n"
"\n"
"            /** Code generation targets to include in the session.\n"
"            */\n"
"        TargetDesc const*   targets = nullptr;\n"
"        SlangInt            targetCount = 0;\n"
"\n"
"            /** Flags to configure the session.\n"
"            */\n"
"        SessionFlags flags = kSessionFlags_None;\n"
"\n"
"            /** Default layout to assume for variables with matrix types.\n"
"            */\n"
"        SlangMatrixLayoutMode defaultMatrixLayoutMode = SLANG_MATRIX_LAYOUT_ROW_MAJOR;\n"
"\n"
"            /** Paths to use when searching for `#include`d or `import`ed files.\n"
"            */\n"
"        char const* const*  searchPaths = nullptr;\n"
"        SlangInt            searchPathCount = 0;\n"
"\n"
"        PreprocessorMacroDesc const*    preprocessorMacros = nullptr;\n"
"        SlangInt                        preprocessorMacroCount = 0;\n"
"    };\n"
"\n"
"    enum class ContainerType\n"
"    {\n"
"        None, UnsizedArray, StructuredBuffer, ConstantBuffer, ParameterBlock\n"
"    };\n"
"\n"
"        /** A session provides a scope for code that is loaded.\n"
"\n"
"        A session can be used to load modules of Slang source code,\n"
"        and to request target-specific compiled binaries and layout\n"
"        information.\n"
"\n"
"        In order to be able to load code, the session owns a set\n"
"        of active \"search paths\" for resolving `#include` directives\n"
"        and `import` declrations, as well as a set of global\n"
"        preprocessor definitions that will be used for all code\n"
"        that gets `import`ed in the session.\n"
"\n"
"        If multiple user shaders are loaded in the same session,\n"
"        and import the same module (e.g., two source files do `import X`)\n"
"        then there will only be one copy of `X` loaded within the session.\n"
"\n"
"        In order to be able to generate target code, the session\n"
"        owns a list of available compilation targets, which specify\n"
"        code generation options.\n"
"\n"
"        Code loaded and compiled within a session is owned by the session\n"
"        and will remain resident in memory until the session is released.\n"
"        Applications wishing to control the memory usage for compiled\n"
"        and loaded code should use multiple sessions.\n"
"        */\n"
"    struct ISession : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE( 0x67618701, 0xd116, 0x468f, { 0xab, 0x3b, 0x47, 0x4b, 0xed, 0xce, 0xe, 0x3d } )\n"
"\n"
"            /** Get the global session thas was used to create this session.\n"
"            */\n"
"        virtual SLANG_NO_THROW IGlobalSession* SLANG_MCALL getGlobalSession() = 0;\n"
"\n"
"            /** Load a module as it would be by code using `import`.\n"
"            */\n"
"        virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModule(\n"
"            const char* moduleName,\n"
"            IBlob**     outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Load a module from Slang source code.\n"
"            */\n"
"        virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModuleFromSource(\n"
"            const char* moduleName,\n"
"            slang::IBlob* source,\n"
"            slang::IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Combine multiple component types to create a composite component type.\n"
"\n"
"            The `componentTypes` array must contain `componentTypeCount` pointers\n"
"            to component types that were loaded or created using the same session.\n"
"\n"
"            The shader parameters and specialization parameters of the composite will\n"
"            be the union of those in `componentTypes`. The relative order of child\n"
"            component types is significant, and will affect the order in which\n"
"            parameters are reflected and laid out.\n"
"\n"
"            The entry-point functions of the composite will be the union of those in\n"
"            `componentTypes`, and will follow the ordering of `componentTypes`.\n"
"\n"
"            The requirements of the composite component type will be a subset of\n"
"            those in `componentTypes`. If an entry in `componentTypes` has a requirement\n"
"            that can be satisfied by another entry, then the composition will\n"
"            satisfy the requirement and it will not appear as a requirement of\n"
"            the composite. If multiple entries in `componentTypes` have a requirement\n"
"            for the same type, then only the first such requirement will be retained\n"
"            on the composite. The relative ordering of requirements on the composite\n"
"            will otherwise match that of `componentTypes`.\n"
"\n"
"            If any diagnostics are generated during creation of the composite, they\n"
"            will be written to `outDiagnostics`. If an error is encountered, the\n"
"            function will return null.\n"
"\n"
"            It is an error to create a composite component type that recursively\n"
"            aggregates the a single module more than once.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createCompositeComponentType(\n"
"            IComponentType* const*  componentTypes,\n"
"            SlangInt                componentTypeCount,\n"
"            IComponentType**        outCompositeComponentType,\n"
"            ISlangBlob**            outDiagnostics = nullptr) = 0;\n"
"\n"
;
sb << 
"            /** Specialize a type based on type arguments.\n"
"            */\n"
"        virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL specializeType(\n"
"            TypeReflection*             type,\n"
"            SpecializationArg const*    specializationArgs,\n"
"            SlangInt                    specializationArgCount,\n"
"            ISlangBlob**                outDiagnostics = nullptr) = 0;\n"
"\n"
"\n"
"            /** Get the layout `type` on the chosen `target`.\n"
"            */\n"
"        virtual SLANG_NO_THROW TypeLayoutReflection* SLANG_MCALL getTypeLayout(\n"
"            TypeReflection* type,\n"
"            SlangInt        targetIndex = 0,\n"
"            LayoutRules     rules = LayoutRules::Default,\n"
"            ISlangBlob**    outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Get a container type from `elementType`. For example, given type `T`, returns\n"
"                a type that represents `StructuredBuffer<T>`.\n"
"\n"
"                @param `elementType`: the element type to wrap around.\n"
"                @param `containerType`: the type of the container to wrap `elementType` in.\n"
"                @param `outDiagnostics`: a blob to receive diagnostic messages.\n"
"            */\n"
"        virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL getContainerType(\n"
"            TypeReflection* elementType,\n"
"            ContainerType containerType,\n"
"            ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Return a `TypeReflection` that represents the `__Dynamic` type.\n"
"                This type can be used as a specialization argument to indicate using\n"
"                dynamic dispatch.\n"
"            */\n"
"        virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL getDynamicType() = 0;\n"
"\n"
"            /** Get the mangled name for a type RTTI object.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTypeRTTIMangledName(\n"
"            TypeReflection* type,\n"
"            ISlangBlob** outNameBlob) = 0;\n"
"\n"
"            /** Get the mangled name for a type witness.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTypeConformanceWitnessMangledName(\n"
"            TypeReflection* type,\n"
"            TypeReflection* interfaceType,\n"
"            ISlangBlob** outNameBlob) = 0;\n"
"\n"
"            /** Get the sequential ID used to identify a type witness in a dynamic object.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTypeConformanceWitnessSequentialID(\n"
"            slang::TypeReflection* type,\n"
"            slang::TypeReflection* interfaceType,\n"
"            uint32_t*              outId) = 0;\n"
"\n"
"            /** Create a request to load/compile front-end code.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createCompileRequest(\n"
"            SlangCompileRequest**   outCompileRequest) = 0;\n"
"\n"
"        \n"
"            /** Creates a `IComponentType` that represents a type's conformance to an interface.\n"
"                The retrieved `ITypeConformance` objects can be included in a composite `IComponentType`\n"
"                to explicitly specify which implementation types should be included in the final compiled\n"
"                code. For example, if an module defines `IMaterial` interface and `AMaterial`,\n"
"                `BMaterial`, `CMaterial` types that implements the interface, the user can exclude\n"
"                `CMaterial` implementation from the resulting shader code by explcitly adding\n"
"                `AMaterial:IMaterial` and `BMaterial:IMaterial` conformances to a composite\n"
"                `IComponentType` and get entry point code from it. The resulting code will not have\n"
"                anything related to `CMaterial` in the dynamic dispatch logic. If the user does not\n"
"                explicitly include any `TypeConformances` to an interface type, all implementations to\n"
"                that interface will be included by default. By linking a `ITypeConformance`, the user is\n"
"                also given the opportunity to specify the dispatch ID of the implementation type. If\n"
"                `conformanceIdOverride` is -1, there will be no override behavior and Slang will\n"
"                automatically assign IDs to implementation types. The automatically assigned IDs can be\n"
"                queried via `ISession::getTypeConformanceWitnessSequentialID`.\n"
"\n"
"                Returns SLANG_OK if succeeds, or SLANG_FAIL if `type` does not conform to `interfaceType`.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createTypeConformanceComponentType(\n"
"            slang::TypeReflection* type,\n"
"            slang::TypeReflection* interfaceType,\n"
"            ITypeConformance** outConformance,\n"
"            SlangInt conformanceIdOverride,\n"
"            ISlangBlob** outDiagnostics) = 0;\n"
"    };\n"
"\n"
"    #define SLANG_UUID_ISession ISession::getTypeGuid()\n"
"\n"
"        /** A component type is a unit of shader code layout, reflection, and linking.\n"
"\n"
"        A component type is a unit of shader code that can be included into\n"
"        a linked and compiled shader program. Each component type may have:\n"
"\n"
"        * Zero or more uniform shader parameters, representing textures,\n"
"          buffers, etc. that the code in the component depends on.\n"
"\n"
"        * Zero or more *specialization* parameters, which are type or\n"
"          value parameters that can be used to synthesize specialized\n"
"          versions of the component type.\n"
"\n"
"        * Zero or more entry points, which are the individually invocable\n"
"          kernels that can have final code generated.\n"
"\n"
"        * Zero or more *requirements*, which are other component\n"
"          types on which the component type depends.\n"
"\n"
"        One example of a component type is a module of Slang code:\n"
"\n"
"        * The global-scope shader parameters declared in the module are\n"
"          the parameters when considered as a component type.\n"
"\n"
"        * Any global-scope generic or interface type parameters introduce\n"
"          specialization parameters for the module.\n"
"\n"
"        * A module does not by default include any entry points when\n"
"          considered as a component type (although the code of the\n"
"          module might *declare* some entry points).\n"
"\n"
"        * Any other modules that are `import`ed in the source code\n"
"          become requirements of the module, when considered as a\n"
"          component type.\n"
"\n"
"        An entry point is another example of a component type:\n"
"\n"
"        * The `uniform` parameters of the entry point function are\n"
"          its shader parameters when considered as a component type.\n"
"\n"
"        * Any generic or interface-type parameters of the entry point\n"
"          introduce specialization parameters.\n"
"\n"
"        * An entry point component type exposes a single entry point (itself).\n"
"\n"
"        * An entry point has one requirement for the module in which\n"
"          it was defined.\n"
"\n"
"        Component types can be manipulated in a few ways:\n"
"\n"
"        * Multiple component types can be combined into a composite, which\n"
"          combines all of their code, parameters, etc.\n"
"\n"
"        * A component type can be specialized, by \"plugging in\" types and\n"
"          values for its specialization parameters.\n"
"\n"
"        * A component type can be laid out for a particular target, giving\n"
"          offsets/bindings to the shader parameters it contains.\n"
"\n"
"        * Generated kernel code can be requested for entry points.\n"
"\n"
"        */\n"
"    struct IComponentType : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x5bc42be8, 0x5c50, 0x4929, { 0x9e, 0x5e, 0xd1, 0x5e, 0x7c, 0x24, 0x1, 0x5f })\n"
"\n"
"            /** Get the runtime session that this component type belongs to.\n"
"            */\n"
"        virtual SLANG_NO_THROW ISession* SLANG_MCALL getSession() = 0;\n"
"\n"
"            /** Get the layout for this program for the chosen `targetIndex`.\n"
"\n"
"            The resulting layout will establish offsets/bindings for all\n"
"            of the global and entry-point shader parameters in the\n"
"            component type.\n"
"\n"
"            If this component type has specialization parameters (that is,\n"
"            it is not fully specialized), then the resulting layout may\n"
"            be incomplete, and plugging in arguments for generic specialization\n"
"            parameters may result in a component type that doesn't have\n"
"            a compatible layout. If the component type only uses\n"
"            interface-type specialization parameters, then the layout\n"
"            for a specialization should be compatible with an unspecialized\n"
"            layout (all parameters in the unspecialized layout will have\n"
"            the same offset/binding in the specialized layout).\n"
"\n"
"            If this component type is combined into a composite, then\n"
"            the absolute offsets/bindings of parameters may not stay the same.\n"
"            If the shader parameters in a component type don't make\n"
"            use of explicit binding annotations (e.g., `register(...)`),\n"
"            then the *relative* offset of shader parameters will stay\n"
"            the same when it is used in a composition.\n"
"            */\n"
"        virtual SLANG_NO_THROW ProgramLayout* SLANG_MCALL getLayout(\n"
"            SlangInt    targetIndex = 0,\n"
"            IBlob**     outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Get the number of (unspecialized) specialization parameters for the component type.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangInt SLANG_MCALL getSpecializationParamCount() = 0;\n"
"\n"
"            /** Get the compiled code for the entry point at `entryPointIndex` for the chosen `targetIndex`\n"
"\n"
"            Entry point code can only be computed for a component type that\n"
"            has no specialization parameters (it must be fully specialized)\n"
"            and that has no requirements (it must be fully linked).\n"
"\n"
"            If code has not already been generated for the given entry point and target,\n"
"            then a compilation error may be detected, in which case `outDiagnostics`\n"
"            (if non-null) will be filled in with a blob of messages diagnosing the error.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCode(\n"
"            SlangInt    entryPointIndex,\n"
"            SlangInt    targetIndex,\n"
"            IBlob**     outCode,\n"
"            IBlob**     outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Specialize the component by binding its specialization parameters to concrete arguments.\n"
"\n"
"            The `specializationArgs` array must have `specializationArgCount` entries, and\n"
"            this must match the number of specialization parameters on this component type.\n"
"\n"
"            If any diagnostics (error or warnings) are produced, they will be written to `outDiagnostics`.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL specialize(\n"
"            SpecializationArg const*    specializationArgs,\n"
"            SlangInt                    specializationArgCount,\n"
"            IComponentType**            outSpecializedComponentType,\n"
"            ISlangBlob**                outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Link this component type against all of its unsatisifed dependencies.\n"
"            \n"
"            A component type may have unsatisfied dependencies. For example, a module\n"
"            depends on any other modules it `import`s, and an entry point depends\n"
"            on the module that defined it.\n"
"\n"
"            A user can manually satisfy dependencies by creating a composite\n"
"            component type, and when doing so they retain full control over\n"
"            the relative ordering of shader parameters in the resulting layout.\n"
"\n"
"            It is an error to try to generate/access compiled kernel code for\n"
"            a component type with unresolved dependencies, so if dependencies\n"
"            remain after whatever manual composition steps an application\n"
"            cares to peform, the `link()` function can be used to automatically\n"
"            compose in any remaining dependencies. The order of parameters\n"
"            (and hence the global layout) that results will be deterministic,\n"
"            but is not currently documented.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL link(\n"
"            IComponentType**            outLinkedComponentType,\n"
"            ISlangBlob**                outDiagnostics = nullptr) = 0;\n"
"\n"
"            /** Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.\n"
"\n"
"            The functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"            NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"    \n"
"            @param entryPointIndex  The index of the entry point to get code for.\n"
"            @param targetIndex      The index of the target to get code for (default: zero).\n"
"            @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried on.\n"
"            @returns                A `SlangResult` to indicate success or failure.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n"
"            int                     entryPointIndex,\n"
"            int                     targetIndex,\n"
"            ISlangSharedLibrary**   outSharedLibrary,\n"
"            slang::IBlob**          outDiagnostics = 0) = 0;\n"
"\n"
"            /** Get a new ComponentType object that represents a renamed entry point.\n"
"\n"
"            The current object must be a single EntryPoint, or a CompositeComponentType or\n"
"            SpecializedComponentType that contains one EntryPoint component.\n"
"            */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL renameEntryPoint(\n"
"            const char* newName, IComponentType** outEntryPoint) = 0;\n"
"    };\n"
"    #define SLANG_UUID_IComponentType IComponentType::getTypeGuid()\n"
"\n"
"    struct IEntryPoint : public IComponentType\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x8f241361, 0xf5bd, 0x4ca0, { 0xa3, 0xac, 0x2, 0xf7, 0xfa, 0x24, 0x2, 0xb8 })\n"
"    };\n"
"\n"
"    #define SLANG_UUID_IEntryPoint IEntryPoint::getTypeGuid()\n"
"\n"
"    struct ITypeConformance : public IComponentType\n"
"    {\n"
"        SLANG_COM_INTERFACE(0x73eb3147, 0xe544, 0x41b5, { 0xb8, 0xf0, 0xa2, 0x44, 0xdf, 0x21, 0x94, 0xb })\n"
"    };\n"
"    #define SLANG_UUID_ITypeConformance ITypeConformance::getTypeGuid()\n"
"\n"
"        /** A module is the granularity of shader code compilation and loading.\n"
"\n"
"        In most cases a module corresponds to a single compile \"translation unit.\"\n"
"        This will often be a single `.slang` or `.hlsl` file and everything it\n"
"        `#include`s.\n"
"\n"
"        Notably, a module `M` does *not* include the things it `import`s, as these\n"
"        as distinct modules that `M` depends on. There is a directed graph of\n"
"        module dependencies, and all modules in the graph must belong to the\n"
"        same session (`ISession`).\n"
"\n"
"        A module establishes a namespace for looking up types, functions, etc.\n"
"        */\n"
"    struct IModule : public IComponentType\n"
"    {\n"
"        SLANG_COM_INTERFACE(0xc720e64, 0x8722, 0x4d31, { 0x89, 0x90, 0x63, 0x8a, 0x98, 0xb1, 0xc2, 0x79 })\n"
"\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL findEntryPointByName(\n"
"            char const*     name,\n"
"            IEntryPoint**   outEntryPoint) = 0;\n"
"    };\n"
"    \n"
"    #define SLANG_UUID_IModule IModule::getTypeGuid()\n"
"\n"
"        /** Argument used for specialization to types/values.\n"
"        */\n"
"    struct SpecializationArg\n"
"    {\n"
"        enum class Kind : int32_t\n"
"        {\n"
"            Unknown,    /**< An invalid specialization argument. */\n"
"            Type,       /**< Specialize to a type. */\n"
"        };\n"
"\n"
"        /** The kind of specialization argument. */\n"
"        Kind kind;\n"
"        union\n"
"        {\n"
"            /** A type specialization argument, used for `Kind::Type`. */\n"
"            TypeReflection* type;\n"
"        };\n"
"\n"
"        static SpecializationArg fromType(TypeReflection* inType)\n"
"        {\n"
"            SpecializationArg rs;\n"
"            rs.kind = Kind::Type;\n"
"            rs.type = inType;\n"
"            return rs;\n"
"        }\n"
"    };\n"
"}\n"
"\n"
"// Passed into functions to create globalSession to identify the API version client code is\n"
"// using. \n"
"#define SLANG_API_VERSION 0\n"
"\n"
"/* Create a global session, with built in StdLib.\n"
"\n"
"@param apiVersion Pass in SLANG_API_VERSION\n"
"@param outGlobalSession (out)The created global session. \n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult slang_createGlobalSession(\n"
"    SlangInt                apiVersion,\n"
"    slang::IGlobalSession** outGlobalSession);\n"
"\n"
"/* Create a global session, but do not set up the stdlib. The stdlib can\n"
"then be loaded via loadStdLib or compileStdLib\n"
"\n"
"@param apiVersion Pass in SLANG_API_VERSION\n"
"@param outGlobalSession (out)The created global session that doesn't have a StdLib setup.\n"
"\n"
"NOTE! API is experimental and not ready for production code \n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult slang_createGlobalSessionWithoutStdLib(\n"
"    SlangInt                apiVersion,\n"
"    slang::IGlobalSession** outGlobalSession);\n"
"\n"
;
sb << 
"/* Returns a blob that contains the serialized stdlib.\n"
"Returns nullptr if there isn't an embedded stdlib.\n"
"*/\n"
"SLANG_API ISlangBlob* slang_getEmbeddedStdLib();\n"
"\n"
"namespace slang\n"
"{\n"
"    inline SlangResult createGlobalSession(\n"
"        slang::IGlobalSession** outGlobalSession)\n"
"    {\n"
"        return slang_createGlobalSession(SLANG_API_VERSION, outGlobalSession);\n"
"    }\n"
"}\n"
"\n"
"/** @see slang::ICompileRequest::getProgram\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getProgram(\n"
"    SlangCompileRequest*    request,\n"
"    slang::IComponentType** outProgram);\n"
"\n"
"/** @see slang::ICompileRequest::getProgramWithEntryPoints\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getProgramWithEntryPoints(\n"
"    SlangCompileRequest*    request,\n"
"    slang::IComponentType** outProgram);\n"
"\n"
"/** @see slang::ICompileRequest::getEntryPoint\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getEntryPoint(\n"
"    SlangCompileRequest*    request,\n"
"    SlangInt                entryPointIndex,\n"
"    slang::IComponentType** outEntryPoint);\n"
"\n"
"/** @see slang::ICompileRequest::getModule\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getModule(\n"
"    SlangCompileRequest*    request,\n"
"    SlangInt                translationUnitIndex,\n"
"    slang::IModule**        outModule);\n"
"\n"
"/** @see slang::ICompileRequest::getSession\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult spCompileRequest_getSession(\n"
"    SlangCompileRequest* request,\n"
"    slang::ISession** outSession);\n"
"#endif\n"
"\n"
"/* DEPRECATED DEFINITIONS\n"
"\n"
"Everything below this point represents deprecated APIs/definition that are only\n"
"being kept around for source/binary compatibility with old client code. New\n"
"code should not use any of these declarations, and the Slang API will drop these\n"
"declarations over time.\n"
"*/\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\" {\n"
"#endif\n"
"\n"
"#define SLANG_ERROR_INSUFFICIENT_BUFFER SLANG_E_BUFFER_TOO_SMALL\n"
"#define SLANG_ERROR_INVALID_PARAMETER SLANG_E_INVALID_ARG\n"
"\n"
"SLANG_API char const* spGetTranslationUnitSource(\n"
"    SlangCompileRequest*    request,\n"
"    int                     translationUnitIndex);\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"\n"
"#include <assert.h>\n"
"\n"
"#include <stdint.h>\n"
"\n"
"#ifndef SLANG_CORE_SIGNAL_H\n"
"#define SLANG_CORE_SIGNAL_H\n"
"\n"
"\n"
"namespace Slang\n"
"{\n"
"\n"
"enum class SignalType\n"
"{\n"
"    Unexpected,\n"
"    Unimplemented,\n"
"    AssertFailure,\n"
"    Unreachable,\n"
"    InvalidOperation,\n"
"    AbortCompilation,\n"
"};\n"
"\n"
"\n"
"// Note that message can be passed as nullptr for no message.\n"
"SLANG_RETURN_NEVER void handleSignal(SignalType type, char const* message);\n"
"\n"
"#define SLANG_UNEXPECTED(reason) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::Unexpected, reason)\n"
"\n"
"#define SLANG_UNIMPLEMENTED_X(what) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::Unimplemented, what)\n"
"\n"
"#define SLANG_UNREACHABLE(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::Unreachable, msg)\n"
"\n"
"#define SLANG_ASSERT_FAILURE(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::AssertFailure, msg)\n"
"\n"
"#define SLANG_INVALID_OPERATION(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::InvalidOperation, msg)\n"
"\n"
"#define SLANG_ABORT_COMPILATION(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::AbortCompilation, msg)\n"
"\n"
"\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"#define VARIADIC_TEMPLATE\n"
"\n"
"namespace Slang\n"
"{\n"
"\ttypedef int32_t Int32;\n"
"\ttypedef uint32_t UInt32;\n"
"\n"
"\ttypedef int64_t Int64;\n"
"\ttypedef uint64_t UInt64;\n"
"\n"
"    // Define \n"
"    typedef SlangUInt UInt;\n"
"    typedef SlangInt Int;\n"
"\n"
"    static const UInt kMaxUInt = ~UInt(0);\n"
"    static const Int kMaxInt = Int(kMaxUInt >> 1);\n"
"\n"
"//\ttypedef unsigned short Word;\n"
"\n"
"\ttypedef intptr_t PtrInt;\n"
"\n"
"    // TODO(JS): It looks like Index is actually 64 bit on 64 bit targets(!)\n"
"    // Previous discussions landed on Index being int32_t.\n"
"\n"
"    // Type used for indexing, in arrays/views etc. Signed.\n"
"    typedef Int Index;\n"
"    typedef UInt UIndex;\n"
"    typedef Int Count;\n"
"    typedef UInt UCount;\n"
"\n"
"    static const Index kMaxIndex = kMaxInt;\n"
"\n"
"    typedef uint8_t Byte;\n"
"\n"
"    // TODO(JS):\n"
"    // Perhaps these should be named Utf8, Utf16 and UnicodePoint/Rune/etc? For now, just keep it simple\n"
"    //\n"
"    typedef char Char8;\n"
"    // 16 bit character. Note much like in utf8, a character may or may not represent a code point (it can be part of a code point).  \n"
"    typedef uint16_t Char16;\n"
"\n"
"    // Can always hold a unicode code point.\n"
"    typedef uint32_t Char32;\n"
"\n"
"\ttemplate <typename T>\n"
"\tinline T&& _Move(T & obj)\n"
"\t{\n"
"\t\treturn static_cast<T&&>(obj);\n"
"\t}\n"
"\n"
"\ttemplate <typename T>\n"
"\tinline void Swap(T & v0, T & v1)\n"
"\t{\n"
"\t\tT tmp = _Move(v0);\n"
"\t\tv0 = _Move(v1);\n"
"\t\tv1 = _Move(tmp);\n"
"\t}\n"
"\n"
"// TODO: Shouldn't these be SLANG_ prefixed?\n"
"#ifdef _MSC_VER\n"
"#define UNREACHABLE_RETURN(x)\n"
"#define UNREACHABLE(x)\n"
"#else\n"
"#define UNREACHABLE_RETURN(x) return x;\n"
"#define UNREACHABLE(x) x;\n"
"#endif\n"
"\n"
"}\n"
"\n"
"#ifdef _DEBUG\n"
"#define SLANG_EXPECT(VALUE, MSG) if(VALUE) {} else SLANG_ASSERT_FAILURE(MSG)\n"
"#define SLANG_ASSERT(VALUE) SLANG_EXPECT(VALUE, #VALUE)\n"
"#else\n"
"#define SLANG_EXPECT(VALUE, MSG) do {} while(0)\n"
"#define SLANG_ASSERT(VALUE) do {} while(0)\n"
"#endif\n"
"\n"
"#define SLANG_RELEASE_ASSERT(VALUE) if(VALUE) {} else SLANG_ASSERT_FAILURE(#VALUE)\n"
"#define SLANG_RELEASE_EXPECT(VALUE, WHAT) if(VALUE) {} else SLANG_UNEXPECTED(WHAT)\n"
"\n"
"template<typename T> void slang_use_obj(T&) {}\n"
"\n"
"#define SLANG_UNREFERENCED_PARAMETER(P) slang_use_obj(P)\n"
"#define SLANG_UNREFERENCED_VARIABLE(P) slang_use_obj(P)\n"
"#endif\n"
"\n"
"#if defined(SLANG_RT_DYNAMIC)\n"
"#if defined(_MSC_VER)\n"
"#    ifdef SLANG_RT_DYNAMIC_EXPORT\n"
"#        define SLANG_RT_API SLANG_DLL_EXPORT\n"
"#    else\n"
"#        define SLANG_RT_API __declspec(dllimport)\n"
"#    endif\n"
"#else\n"
"// TODO: need to consider compiler capabilities\n"
"//#     ifdef SLANG_RT_DYNAMIC_EXPORT\n"
"#    define SLANG_RT_API SLANG_DLL_EXPORT\n"
"//#     endif\n"
"#endif\n"
"#endif\n"
"\n"
"#ifndef SLANG_RT_API\n"
"#define SLANG_RT_API\n"
"#endif\n"
"\n"
"#ifndef SLANG_CORE_HASH_H\n"
"#define SLANG_CORE_HASH_H\n"
"\n"
"#ifndef SLANG_CORE_MATH_H\n"
"#define SLANG_CORE_MATH_H\n"
"\n"
"#include <cmath>\n"
"\n"
"namespace Slang\n"
"{\n"
"    // Some handy constants\n"
"\n"
"    // The largest positive (or negative) number \n"
"#   define SLANG_HALF_MAX 65504.0f\n"
"    // Smallest (denormalized) value. 1 / 2^24\n"
"#   define SLANG_HALF_SUB_NORMAL_MIN (1.0f / 16777216.0f)\n"
"\n"
"\tclass Math\n"
"\t{\n"
"\tpublic:\n"
"        // Use to fix type punning issues with strict aliasing\n"
"        union FloatIntUnion\n"
"        {\n"
"            float fvalue;\n"
"            int ivalue;\n"
"\n"
"            SLANG_FORCE_INLINE static FloatIntUnion makeFromInt(int i) { FloatIntUnion cast; cast.ivalue = i; return cast; }\n"
"            SLANG_FORCE_INLINE static FloatIntUnion makeFromFloat(float f) { FloatIntUnion cast; cast.fvalue = f; return cast; }\n"
"        };\n"
"        union DoubleInt64Union\n"
"        {\n"
"            double dvalue;\n"
"            int64_t ivalue;\n"
"            SLANG_FORCE_INLINE static DoubleInt64Union makeFromInt64(int64_t i) { DoubleInt64Union cast; cast.ivalue = i; return cast; }\n"
"            SLANG_FORCE_INLINE static DoubleInt64Union makeFromDouble(double d) { DoubleInt64Union cast; cast.dvalue = d; return cast; }\n"
"        };\n"
"        \n"
"\t\tstatic const float Pi;\n"
"\n"
"        template <typename T>\n"
"        static T Abs(T a)\n"
"        {\n"
"            return (a < 0) ? -a : a;\n"
"        }\n"
"\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Min(const T& v1, const T&v2)\n"
"\t\t{\n"
"\t\t\treturn v1<v2?v1:v2;\n"
"\t\t}\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Max(const T& v1, const T&v2)\n"
"\t\t{\n"
"\t\t\treturn v1>v2?v1:v2;\n"
"\t\t}\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Min(const T& v1, const T&v2, const T&v3)\n"
"\t\t{\n"
"\t\t\treturn Min(v1, Min(v2, v3));\n"
"\t\t}\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Max(const T& v1, const T&v2, const T&v3)\n"
"\t\t{\n"
"\t\t\treturn Max(v1, Max(v2, v3));\n"
"\t\t}\n"
"\t\ttemplate<typename T>\n"
"\t\tstatic T Clamp(const T& val, const T& vmin, const T&vmax)\n"
"\t\t{\n"
"\t\t\tif (val < vmin) return vmin;\n"
"\t\t\telse if (val > vmax) return vmax;\n"
"\t\t\telse return val;\n"
"\t\t}\n"
"\n"
"\t\tstatic inline int FastFloor(float x)\n"
"\t\t{\n"
"\t\t\tint i = (int)x;\n"
"\t\t\treturn i - (i > x);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline int FastFloor(double x)\n"
"\t\t{\n"
"\t\t\tint i = (int)x;\n"
"\t\t\treturn i - (i > x);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline int IsNaN(float x)\n"
"\t\t{\n"
"\t\t\treturn std::isnan(x);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline int IsInf(float x)\n"
"\t\t{\n"
"\t\t\treturn std::isinf(x);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline unsigned int Ones32(unsigned int x)\n"
"\t\t{\n"
"\t\t\t/* 32-bit recursive reduction using SWAR...\n"
"\t\t\t\tbut first step is mapping 2-bit values\n"
"\t\t\t\tinto sum of 2 1-bit values in sneaky way\n"
"\t\t\t*/\n"
"\t\t\tx -= ((x >> 1) & 0x55555555);\n"
"\t\t\tx = (((x >> 2) & 0x33333333) + (x & 0x33333333));\n"
"\t\t\tx = (((x >> 4) + x) & 0x0f0f0f0f);\n"
"\t\t\tx += (x >> 8);\n"
"\t\t\tx += (x >> 16);\n"
"\t\t\treturn(x & 0x0000003f);\n"
"\t\t}\n"
"\n"
"\t\tstatic inline unsigned int Log2Floor(unsigned int x)\n"
"\t\t{\n"
"\t\t\tx |= (x >> 1);\n"
"\t\t\tx |= (x >> 2);\n"
"\t\t\tx |= (x >> 4);\n"
"\t\t\tx |= (x >> 8);\n"
"\t\t\tx |= (x >> 16);\n"
"\t\t\treturn(Ones32(x >> 1));\n"
"\t\t}\n"
"\n"
"\t\tstatic inline unsigned int Log2Ceil(unsigned int x)\n"
"\t\t{\n"
"\t\t\tint y = (x & (x - 1));\n"
"\t\t\ty |= -y;\n"
"\t\t\ty >>= (32 - 1);\n"
"\t\t\tx |= (x >> 1);\n"
"\t\t\tx |= (x >> 2);\n"
"\t\t\tx |= (x >> 4);\n"
"\t\t\tx |= (x >> 8);\n"
"\t\t\tx |= (x >> 16);\n"
"\t\t\treturn(Ones32(x >> 1) - y);\n"
"\t\t}\n"
"\t\t/*\n"
"\t\tstatic inline int Log2(float x)\n"
"\t\t{\n"
"\t\t\tunsigned int ix = (unsigned int&)x;\n"
"\t\t\tunsigned int exp = (ix >> 23) & 0xFF;\n"
"\t\t\tint log2 = (unsigned int)(exp) - 127;\n"
"\n"
"\t\t\treturn log2;\n"
"\t\t}\n"
"\t\t*/\n"
"\n"
"        static bool AreNearlyEqual(double a, double b, double epsilon)\n"
"        {\n"
"            // If they are equal then we are done\n"
"            if (a == b)\n"
"            {\n"
"                return true;\n"
"            }\n"
"\n"
"            const double absA = Abs(a);\n"
"            const double absB = Abs(b);\n"
"            const double diff = Abs(a - b);\n"
"\n"
"            // https://en.wikipedia.org/wiki/Double_precision_floating-point_format\n"
"            const double minNormal = 2.2250738585072014e-308;\n"
"            // Either a or b are very close to being zero, so doing relative comparison isn't really appropriate\n"
"            if (a == 0.0 || b == 0.0 || (absA + absB < minNormal))\n"
"            {\n"
"                return diff < (epsilon * minNormal);\n"
"            }\n"
"            else\n"
"            {\n"
"                // Calculate a relative relative error\n"
"                return diff < epsilon * (absA + absB);\n"
"            }\n"
"        }\n"
"\n"
"        template <typename T>\n"
"        static T getLowestBit(T val)\n"
"        {\n"
"            return val & (-val);\n"
"        }\n"
"\t};\n"
"    inline int FloatAsInt(float val)\n"
"\t{\n"
"        return Math::FloatIntUnion::makeFromFloat(val).ivalue; \n"
"\t}\n"
"    inline float IntAsFloat(int val)\n"
"\t{\n"
"        return Math::FloatIntUnion::makeFromInt(val).fvalue; \n"
"\t}\n"
"\n"
"    SLANG_FORCE_INLINE int64_t DoubleAsInt64(double val)\n"
"    {\n"
"        return Math::DoubleInt64Union::makeFromDouble(val).ivalue;\n"
"    }\n"
"    SLANG_FORCE_INLINE double Int64AsDouble(int64_t value)\n"
"    {\n"
"        return Math::DoubleInt64Union::makeFromInt64(value).dvalue;\n"
"    }\n"
"\n"
"\tinline unsigned short FloatToHalf(float val)\n"
"\t{\n"
"        const auto x = FloatAsInt(val);\n"
"        \n"
"\t\tunsigned short bits = (x >> 16) & 0x8000;\n"
"\t\tunsigned short m = (x >> 12) & 0x07ff;\n"
"\t\tunsigned int e = (x >> 23) & 0xff;\n"
"\t\tif (e < 103)\n"
"\t\t\treturn bits;\n"
"\t\tif (e > 142)\n"
"\t\t{\n"
"\t\t\tbits |= 0x7c00u;\n"
"\t\t\tbits |= e == 255 && (x & 0x007fffffu);\n"
"\t\t\treturn bits;\n"
"\t\t}\n"
"\t\tif (e < 113)\n"
"\t\t{\n"
"\t\t\tm |= 0x0800u;\n"
"\t\t\tbits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n"
"\t\t\treturn bits;\n"
"\t\t}\n"
"\t\tbits |= ((e - 112) << 10) | (m >> 1);\n"
"\t\tbits += m & 1;\n"
"\t\treturn bits;\n"
"\t}\n"
"\n"
"\tinline float HalfToFloat(unsigned short input)\n"
"\t{\n"
"\t\tstatic const auto magic = Math::FloatIntUnion::makeFromInt((127 + (127 - 15)) << 23);\n"
"\t\tstatic const auto was_infnan = Math::FloatIntUnion::makeFromInt((127 + 16) << 23);\n"
"        Math::FloatIntUnion o;\n"
"\t\to.ivalue = (input & 0x7fff) << 13;     // exponent/mantissa bits\n"
"\t\to.fvalue *= magic.fvalue;                 // exponent adjust\n"
"\t\tif (o.fvalue >= was_infnan.fvalue)        // make sure Inf/NaN survive\n"
"\t\t\to.ivalue |= 255 << 23;\n"
"\t\to.ivalue |= (input & 0x8000) << 16;    // sign bit\n"
"\t\treturn o.fvalue;\n"
"\t}\n"
"\n"
"\tclass Random\n"
"\t{\n"
"\tprivate:\n"
"\t\tunsigned int seed;\n"
"\tpublic:\n"
"\t\tRandom(int seed)\n"
"\t\t{\n"
"\t\t\tthis->seed = seed;\n"
"\t\t}\n"
"\t\tint Next() // random between 0 and RandMax (currently 0x7fff)\n"
"\t\t{\n"
"\t\t\treturn ((seed = ((seed << 12) + 150889L) % 714025) & 0x7fff);\n"
"\t\t}\n"
"\t\tint Next(int min, int max) // inclusive min, exclusive max\n"
"\t\t{\n"
"\t\t\tunsigned int a = ((seed = ((seed << 12) + 150889L) % 714025) & 0xFFFF);\n"
"\t\t\tunsigned int b = ((seed = ((seed << 12) + 150889L) % 714025) & 0xFFFF);\n"
"\t\t\tunsigned int r = (a << 16) + b;\n"
"\t\t\treturn min + r % (max - min);\n"
"\t\t}\n"
"\t\tfloat NextFloat()\n"
"\t\t{\n"
"\t\t\treturn ((Next() << 15) + Next()) / ((float)(1 << 30));\n"
"\t\t}\n"
"\t\tfloat NextFloat(float valMin, float valMax)\n"
"\t\t{\n"
"\t\t\treturn valMin + (valMax - valMin) * NextFloat();\n"
"\t\t}\n"
"\t\tstatic int RandMax()\n"
"\t\t{\n"
"\t\t\treturn 0x7fff;\n"
"\t\t}\n"
"\t};\n"
"}\n"
"\n"
"#endif \n"
"\n"
"#include <string.h>\n"
"#include <type_traits>\n"
"\n"
"namespace Slang\n"
"{\n"
"    // Ideally Hash codes should be unsigned types - makes accumulation simpler (as overflow/underflow behavior are defined)\n"
"    // Only downside is around multiply, where unsigned multiply can be slightly slower on some targets.\n"
"\n"
"    // HashCode - size may vary by platform. Typically has 'best' combination of bits/performance. Should not be exposed externally as value from same input may change depending on compilation platform.\n"
"    typedef unsigned int HashCode;\n"
"\n"
"    // A fixed 64bit wide hash on all targets.\n"
"    typedef uint64_t HashCode64;\n"
"    // A fixed 32bit wide hash on all targets.\n"
"    typedef uint32_t HashCode32;\n"
"\n"
"    SLANG_FORCE_INLINE HashCode32 toHash32(HashCode value) { return (sizeof(HashCode) == sizeof(int64_t)) ? (HashCode32(uint64_t(value) >> 32) ^ HashCode(value)) : HashCode32(value); }\n"
"    SLANG_FORCE_INLINE HashCode64 toHash64(HashCode value) { return (sizeof(HashCode) == sizeof(int64_t)) ? HashCode(value) : ((HashCode64(value) << 32) | value); }\n"
"\n"
"    SLANG_FORCE_INLINE HashCode getHashCode(int64_t value)\n"
"    {\n"
"        return (sizeof(HashCode) == sizeof(int64_t)) ? HashCode(value) : (HashCode(uint64_t(value) >> 32) ^ HashCode(value));\n"
"    }\n"
"    SLANG_FORCE_INLINE HashCode getHashCode(uint64_t value)\n"
"    {\n"
"        return (sizeof(HashCode) == sizeof(uint64_t)) ? HashCode(value) : (HashCode(value >> 32) ^ HashCode(value));\n"
"    }\n"
"\n"
"\tinline HashCode getHashCode(double key)\n"
"\t{\n"
"\t\treturn getHashCode(DoubleAsInt64(key));\n"
"\t}\n"
"\tinline HashCode getHashCode(float key)\n"
"\t{\n"
"\t\treturn FloatAsInt(key);\n"
"\t} \n"
"\tinline HashCode getHashCode(const char* buffer)\n"
"\t{\n"
"\t\tif (!buffer)\n"
"\t\t\treturn 0;\n"
"\t\tHashCode hash = 0;\n"
"\t\tauto str = buffer;\n"
"\t\tHashCode c = HashCode(*str++);\n"
"\t\twhile (c)\n"
"\t\t{\n"
"\t\t\thash = c + (hash << 6) + (hash << 16) - hash;\n"
"\t\t\tc = HashCode(*str++);\n"
"\t\t}\n"
"\t\treturn hash;\n"
"\t} \n"
"\tinline HashCode getHashCode(char* buffer)\n"
"\t{\n"
"\t\treturn getHashCode(const_cast<const char *>(buffer));\n"
"\t}\n"
"    inline HashCode getHashCode(const char* buffer, size_t numChars)\n"
"    {\n"
"        HashCode hash = 0;\n"
"        for (size_t i = 0; i < numChars; ++i)\n"
"        {      \n"
"            hash = HashCode(buffer[i]) + (hash << 6) + (hash << 16) - hash;\n"
"        }\n"
"        return hash;\n"
"    }\n"
"\n"
"    /* The 'Stable' hash code functions produce hashes that must be\n"
"\n"
"    * The same result for the same inputs on all targets\n"
"    * Rarely change - as their values can change the output of the Slang API/Serialization\n"
"\n"
"    Hash value used from the 'Stable' functions can also be used as part of serialization -\n"
"    so it is in effect part of the API.\n"
"\n"
"    In effect this means changing a 'Stable' algorithm will typically require doing a new release. \n"
"    */\n"
"    inline HashCode32 getStableHashCode32(const char* buffer, size_t numChars)\n"
"    {\n"
"        HashCode32 hash = 0;\n"
"        for (size_t i = 0; i < numChars; ++i)\n"
"        {\n"
"            hash = HashCode32(buffer[i]) + (hash << 6) + (hash << 16) - hash;\n"
"        }\n"
"        return hash;\n"
"    }\n"
"\n"
"    inline HashCode64 getStableHashCode64(const char* buffer, size_t numChars)\n"
"    {\n"
"        // Use HashCode64 is assumed unsigned because hash requires wrap around behavior and int is undefined on over/underflows\n"
"        HashCode64 hash = 0;\n"
"        for (size_t i = 0; i < numChars; ++i)\n"
"        {\n"
"            hash = HashCode64(HashCode64(buffer[i])) + (hash << 6) + (hash << 16) - hash;\n"
"        }\n"
"        return hash;\n"
"    }\n"
"\n"
"    // Hash functions with specific sized results\n"
"    // TODO(JS): We might want to implement HashCode as just an alias a suitable Hash32/Hash32 based on target.\n"
"    // For now just use Stable for 64bit.\n"
"    SLANG_FORCE_INLINE HashCode64 getHashCode64(const char* buffer, size_t numChars) { return getStableHashCode64(buffer, numChars); }\n"
"    SLANG_FORCE_INLINE HashCode32 getHashCode32(const char* buffer, size_t numChars) { return toHash32(getHashCode(buffer, numChars)); }\n"
"\n"
"\ttemplate<int IsInt>\n"
"\tclass Hash\n"
"\t{\n"
"\tpublic:\n"
"\t};\n"
"\ttemplate<>\n"
"\tclass Hash<1>\n"
"\t{\n"
"\tpublic:\n"
"\t\ttemplate<typename TKey>\n"
"\t\tstatic HashCode getHashCode(TKey& key)\n"
"\t\t{\n"
"\t\t\treturn (HashCode)key;\n"
"\t\t}\n"
"\t};\n"
"\ttemplate<>\n"
"\tclass Hash<0>\n"
"\t{\n"
"\tpublic:\n"
"\t\ttemplate<typename TKey>\n"
"\t\tstatic HashCode getHashCode(TKey& key)\n"
"\t\t{\n"
"\t\t\treturn HashCode(key.getHashCode());\n"
"\t\t}\n"
"\t};\n"
"\ttemplate<int IsPointer>\n"
"\tclass PointerHash\n"
"\t{};\n"
"\ttemplate<>\n"
"\tclass PointerHash<1>\n"
"\t{\n"
"\tpublic:\n"
"\t\ttemplate<typename TKey>\n"
"\t\tstatic HashCode getHashCode(TKey const& key)\n"
"\t\t{\n"
"\t\t\treturn (HashCode)((PtrInt)key) / 16; // sizeof(typename std::remove_pointer<TKey>::type);\n"
"\t\t}\n"
"\t};\n"
"\ttemplate<>\n"
"\tclass PointerHash<0>\n"
"\t{\n"
"\tpublic:\n"
"\t\ttemplate<typename TKey>\n"
"\t\tstatic HashCode getHashCode(TKey& key)\n"
"\t\t{\n"
;
sb << 
"\t\t\treturn Hash<std::is_integral<TKey>::value || std::is_enum<TKey>::value>::getHashCode(key);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\ttemplate<typename TKey>\n"
"\tHashCode getHashCode(const TKey& key)\n"
"\t{\n"
"\t\treturn PointerHash<std::is_pointer<TKey>::value>::getHashCode(key);\n"
"\t}\n"
"\n"
"\ttemplate<typename TKey>\n"
"\tHashCode getHashCode(TKey& key)\n"
"\t{\n"
"\t\treturn PointerHash<std::is_pointer<TKey>::value>::getHashCode(key);\n"
"\t}\n"
"\n"
"    inline HashCode combineHash(HashCode left, HashCode right)\n"
"    {\n"
"        return (left * 16777619) ^ right;\n"
"    }\n"
"\n"
"    inline HashCode combineHash(HashCode hash0, HashCode hash1, HashCode hash2)\n"
"    {\n"
"        auto h = hash0;\n"
"        h = combineHash(h, hash1);\n"
"        h = combineHash(h, hash2);\n"
"        return h;\n"
"    }\n"
"\n"
"    struct Hasher\n"
"    {\n"
"    public:\n"
"        Hasher() {}\n"
"\n"
"            /// Hash the given `value` and combine it into this hash state\n"
"        template<typename T>\n"
"        void hashValue(T const& value)\n"
"        {\n"
"            // TODO: Eventually, we should replace `getHashCode`\n"
"            // with a \"hash into\" operation that takes the value\n"
"            // and a `Hasher`.\n"
"\n"
"            m_hashCode = combineHash(m_hashCode, getHashCode(value));\n"
"        }\n"
"\n"
"            /// Hash the given `object` and combine it into this hash state\n"
"        template<typename T>\n"
"        void hashObject(T const& object)\n"
"        {\n"
"            // TODO: Eventually, we should replace `getHashCode`\n"
"            // with a \"hash into\" operation that takes the value\n"
"            // and a `Hasher`.\n"
"\n"
"            m_hashCode = combineHash(m_hashCode, object->getHashCode());\n"
"        }\n"
"\n"
"            /// Combine the given `hash` code into the hash state.\n"
"            ///\n"
"            /// Note: users should prefer to use `hashValue` or `hashObject`\n"
"            /// when possible, as they may be able to ensure a higher-quality\n"
"            /// hash result (e.g., by using more bits to represent the state\n"
"            /// during hashing than are used for the final hash code).\n"
"            ///\n"
"        void addHash(HashCode hash)\n"
"        {\n"
"            m_hashCode = combineHash(m_hashCode, hash);\n"
"        }\n"
"\n"
"        HashCode getResult() const\n"
"        {\n"
"            return m_hashCode;\n"
"        }\n"
"\n"
"    private:\n"
"        HashCode m_hashCode = 0;\n"
"    };\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifndef SLANG_CORE_TYPE_TRAITS_H\n"
"#define SLANG_CORE_TYPE_TRAITS_H\n"
"\n"
"namespace Slang\n"
"{\n"
"\tstruct TraitResultYes\n"
"\t{\n"
"\t\tchar x;\n"
"\t};\n"
"\tstruct TraitResultNo\n"
"\t{\n"
"\t\tchar x[2];\n"
"\t};\n"
"\n"
"\ttemplate <typename B, typename D>\n"
"\tstruct IsBaseOfTraitHost\n"
"\t{\n"
"\t\toperator B*() const { return nullptr; }\n"
"\t\toperator D*() { return nullptr; }\n"
"\t};\n"
"\n"
"\ttemplate <typename B, typename D>\n"
"\tstruct IsBaseOf\n"
"\t{\n"
"\t\ttemplate <typename T>\n"
"\t\tstatic TraitResultYes Check(D*, T) { return TraitResultYes(); }\n"
"\t\tstatic TraitResultNo Check(B*, int) { return TraitResultNo(); }\n"
"\t\tenum { Value = sizeof(Check(IsBaseOfTraitHost<B, D>(), int())) == sizeof(TraitResultYes) };\n"
"\t};\n"
"\n"
"\ttemplate<bool B, class T = void>\n"
"\tstruct EnableIf {};\n"
"\n"
"\ttemplate<class T>\n"
"\tstruct EnableIf<true, T> { typedef T type; };\n"
"\n"
"\ttemplate <typename B, typename D>\n"
"\tstruct IsConvertible\n"
"\t{\n"
"\t\tstatic TraitResultYes Use(B) { return TraitResultYes(); };\n"
"\t\tstatic TraitResultNo Use(...) { return TraitResultNo(); };\n"
"\t\tenum { Value = sizeof(Use(*(D*)(nullptr))) == sizeof(TraitResultYes) };\n"
"\t};\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"namespace Slang\n"
"{\n"
"    // Base class for all reference-counted objects\n"
"    class SLANG_RT_API RefObject\n"
"    {\n"
"    private:\n"
"        UInt referenceCount;\n"
"\n"
"    public:\n"
"        RefObject()\n"
"            : referenceCount(0)\n"
"        {}\n"
"\n"
"        RefObject(const RefObject &)\n"
"            : referenceCount(0)\n"
"        {}\n"
"\n"
"        RefObject& operator=(const RefObject&) { return *this; }\n"
"\n"
"        virtual ~RefObject()\n"
"        {}\n"
"\n"
"        UInt addReference()\n"
"        {\n"
"            return ++referenceCount;\n"
"        }\n"
"\n"
"        UInt decreaseReference()\n"
"        {\n"
"            return --referenceCount;\n"
"        }\n"
"\n"
"        UInt releaseReference()\n"
"        {\n"
"            SLANG_ASSERT(referenceCount != 0);\n"
"            if(--referenceCount == 0)\n"
"            {\n"
"                delete this;\n"
"                return 0;\n"
"            }\n"
"            return referenceCount;\n"
"        }\n"
"\n"
"        bool isUniquelyReferenced()\n"
"        {\n"
"            SLANG_ASSERT(referenceCount != 0);\n"
"            return referenceCount == 1;\n"
"        }\n"
"\n"
"        UInt debugGetReferenceCount()\n"
"        {\n"
"            return referenceCount;\n"
"        }\n"
"    };\n"
"\n"
"    SLANG_FORCE_INLINE void addReference(RefObject* obj)\n"
"    {\n"
"        if(obj) obj->addReference();\n"
"    }\n"
"\n"
"    SLANG_FORCE_INLINE void releaseReference(RefObject* obj)\n"
"    {\n"
"        if(obj) obj->releaseReference();\n"
"    }\n"
"\n"
"    // For straight dynamic cast.\n"
"    // Use instead of dynamic_cast as it allows for replacement without using Rtti in the future\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE T* dynamicCast(RefObject* obj) { return dynamic_cast<T*>(obj); }\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE const T* dynamicCast(const RefObject* obj) { return dynamic_cast<const T*>(obj); }\n"
"\n"
"    // Like a dynamicCast, but allows a type to implement a specific implementation that is suitable for it\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE T* as(RefObject* obj) { return dynamicCast<T>(obj); }\n"
"    template <typename T>\n"
"    SLANG_FORCE_INLINE const T* as(const RefObject* obj) { return dynamicCast<T>(obj); }\n"
"\n"
"    // \"Smart\" pointer to a reference-counted object\n"
"    template<typename T> struct SLANG_RT_API RefPtr\n"
"    {\n"
"        RefPtr()\n"
"            : pointer(nullptr)\n"
"        {}\n"
"\n"
"        RefPtr(T* p)\n"
"            : pointer(p)\n"
"        {\n"
"            addReference(p);\n"
"        }\n"
"\n"
"        RefPtr(RefPtr<T> const& p)\n"
"            : pointer(p.pointer)\n"
"        {\n"
"            addReference(p.pointer);\n"
"        }\n"
"\n"
"        RefPtr(RefPtr<T>&& p)\n"
"            : pointer(p.pointer)\n"
"        {\n"
"            p.pointer = nullptr;\n"
"        }\n"
"\n"
"        template <typename U>\n"
"        RefPtr(RefPtr<U> const& p,\n"
"            typename EnableIf<IsConvertible<T*, U*>::Value, void>::type * = 0)\n"
"            : pointer(static_cast<U*>(p))\n"
"        {\n"
"            addReference(static_cast<U*>(p));\n"
"        }\n"
"\n"
"#if 0\n"
"        void operator=(T* p)\n"
"        {\n"
"            T* old = pointer;\n"
"            addReference(p);\n"
"            pointer = p;\n"
"            releaseReference(old);\n"
"        }\n"
"#endif\n"
"\n"
"        void operator=(RefPtr<T> const& p)\n"
"        {\n"
"            T* old = pointer;\n"
"            addReference(p.pointer);\n"
"            pointer = p.pointer;\n"
"            releaseReference(old);\n"
"        }\n"
"\n"
"        void operator=(RefPtr<T>&& p)\n"
"        {\n"
"            T* old = pointer;\n"
"            pointer = p.pointer;\n"
"            p.pointer = old;\n"
"        }\n"
"\n"
"        template <typename U>\n"
"        typename EnableIf<IsConvertible<T*, U*>::value, void>::type\n"
"            operator=(RefPtr<U> const& p)\n"
"        {\n"
"            T* old = pointer;\n"
"            addReference(p.pointer);\n"
"            pointer = p.pointer;\n"
"            releaseReference(old);\n"
"        }\n"
"\n"
"        HashCode getHashCode()\n"
"        {\n"
"            // Note: We need a `RefPtr<T>` to hash the same as a `T*`,\n"
"            // so that a `T*` can be used as a key in a dictionary with\n"
"            // `RefPtr<T>` keys, and vice versa.\n"
"            //\n"
"            return Slang::getHashCode(pointer);\n"
"        }\n"
"\n"
"        bool operator==(const T * ptr) const\n"
"        {\n"
"            return pointer == ptr;\n"
"        }\n"
"\n"
"        bool operator!=(const T * ptr) const\n"
"        {\n"
"            return pointer != ptr;\n"
"        }\n"
"\n"
"\t\tbool operator==(RefPtr<T> const& ptr) const\n"
"\t\t{\n"
"\t\t\treturn pointer == ptr.pointer;\n"
"\t\t}\n"
"\n"
"\t\tbool operator!=(RefPtr<T> const& ptr) const\n"
"\t\t{\n"
"\t\t\treturn pointer != ptr.pointer;\n"
"\t\t}\n"
"\n"
"        template<typename U>\n"
"        RefPtr<U> dynamicCast() const\n"
"        {\n"
"            return RefPtr<U>(Slang::dynamicCast<U>(pointer));\n"
"        }\n"
"\n"
"        template<typename U>\n"
"        RefPtr<U> as() const\n"
"        {\n"
"            return RefPtr<U>(Slang::as<U>(pointer));\n"
"        }\n"
"\n"
"        template <typename U>\n"
"        bool is() const { return Slang::as<U>(pointer) != nullptr; }\n"
"\n"
"        ~RefPtr()\n"
"        {\n"
"            releaseReference(static_cast<Slang::RefObject*>(pointer));\n"
"        }\n"
"\n"
"        T& operator*() const\n"
"        {\n"
"            return *pointer;\n"
"        }\n"
"\n"
"        T* operator->() const\n"
"        {\n"
"            return pointer;\n"
"        }\n"
"\n"
"\t\tT * Ptr() const\n"
"\t\t{\n"
"\t\t\treturn pointer;\n"
"\t\t}\n"
"\n"
"        operator T*() const\n"
"        {\n"
"            return pointer;\n"
"        }\n"
"\n"
"        void attach(T* p)\n"
"        {\n"
"            T* old = pointer;\n"
"            pointer = p;\n"
"            releaseReference(old);\n"
"        }\n"
"\n"
"        T* detach()\n"
"        {\n"
"            auto rs = pointer;\n"
"            pointer = nullptr;\n"
"            return rs;\n"
"        }\n"
"\n"
"        SLANG_FORCE_INLINE void setNull()\n"
"        {\n"
"            releaseReference(pointer);\n"
"            pointer = nullptr;\n"
"        }\n"
"\n"
"        /// Get ready for writing (nulls contents)\n"
"        SLANG_FORCE_INLINE T** writeRef() { *this = nullptr; return &pointer; }\n"
"\n"
"        /// Get for read access\n"
"        SLANG_FORCE_INLINE T*const* readRef() const { return &pointer; }\n"
"\n"
"    private:\n"
"        T* pointer;\n"
"\t};\n"
"\n"
"    // Helper type for implementing weak pointers. The object being pointed at weakly creates a WeakSink object\n"
"    // that other objects can reference and share. When the object is destroyed it detaches the sink\n"
"    // doing so will make other users call to 'get' return null. Thus any user of the WeakSink, must check if the weakly pointed to\n"
"    // things pointer is nullptr before using.\n"
"    template <typename T>\n"
"    class WeakSink : public RefObject\n"
"    {\n"
"    public:\n"
"        WeakSink(T* ptr):\n"
"            m_ptr(ptr)\n"
"        {\n"
"        }\n"
"\n"
"        SLANG_FORCE_INLINE T* get() const { return m_ptr; }\n"
"        SLANG_FORCE_INLINE void detach() { m_ptr = nullptr; }\n"
"\n"
"    private:\n"
"        T* m_ptr;\n"
"    };\n"
"\n"
"    // A pointer that can be transformed to hold either a weak reference or a strong reference.\n"
"    template<typename T>\n"
"    class TransformablePtr\n"
"    {\n"
"    private:\n"
"        T* m_weakPtr = nullptr;\n"
"        RefPtr<T> m_strongPtr;\n"
"\n"
"    public:\n"
"        TransformablePtr() = default;\n"
"        TransformablePtr(T* ptr) { *this = ptr; }\n"
"        TransformablePtr(RefPtr<T> ptr) { *this = ptr; }\n"
"        TransformablePtr(const TransformablePtr<T>& ptr) = default;\n"
"        TransformablePtr<T>& operator=(const TransformablePtr<T>& ptr) = default;\n"
"\n"
"        void promoteToStrongReference() { m_strongPtr = m_weakPtr; }\n"
"        void demoteToWeakReference() { m_strongPtr = nullptr; }\n"
"        bool isStrongReference() const { return m_strongPtr != nullptr; }\n"
"\n"
"        T& operator*() const { return *m_weakPtr; }\n"
"\n"
"        T* operator->() const { return m_weakPtr; }\n"
"\n"
"        T* Ptr() const { return m_weakPtr; }\n"
"        T* get() const { return m_weakPtr; }\n"
"\n"
"        operator T*() const { return m_weakPtr; }\n"
"        operator RefPtr<T>() const { return m_weakPtr; }\n"
"\n"
"\n"
"        TransformablePtr<T>& operator=(T* ptr)\n"
"        {\n"
"            m_weakPtr = ptr;\n"
"            m_strongPtr = ptr;\n"
"            return *this;\n"
"        }\n"
"        template<typename U>\n"
"        TransformablePtr<T>& operator=(const RefPtr<U>& ptr)\n"
"        {\n"
"            m_weakPtr = ptr.Ptr();\n"
"            m_strongPtr = ptr;\n"
"            return *this;\n"
"        }\n"
"        \n"
"        HashCode getHashCode() const\n"
"        {\n"
"            // Note: We need a `RefPtr<T>` to hash the same as a `T*`,\n"
"            // so that a `T*` can be used as a key in a dictionary with\n"
"            // `RefPtr<T>` keys, and vice versa.\n"
"            //\n"
"            return Slang::getHashCode(m_weakPtr);\n"
"        }\n"
"\n"
"        bool operator==(const T* ptr) const { return m_weakPtr == ptr; }\n"
"\n"
"        bool operator!=(const T* ptr) const { return m_weakPtr != ptr; }\n"
"\n"
"        bool operator==(RefPtr<T> const& ptr) const { return m_weakPtr == ptr.Ptr(); }\n"
"\n"
"        bool operator!=(RefPtr<T> const& ptr) const { return m_weakPtr != ptr.Ptr(); }\n"
"\n"
"        bool operator==(TransformablePtr<T> const& ptr) const { return m_weakPtr == ptr.m_weakPtr; }\n"
"\n"
"        bool operator!=(TransformablePtr<T> const& ptr) const { return m_weakPtr != ptr.m_weakPtr; }\n"
"    };\n"
"}\n"
"#endif\n"
"\n"
"#ifndef _MSC_VER\n"
"#ifndef SLANG_CORE_SECURE_CRT_H\n"
"#define SLANG_CORE_SECURE_CRT_H\n"
"#include <stdarg.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#include <strings.h>\n"
"\n"
"#include <wchar.h>\n"
"\n"
"inline void memcpy_s(void *dest, size_t numberOfElements, const void * src, size_t count)\n"
"{\n"
"\tmemcpy(dest, src, count);\n"
"}\n"
"\n"
"#define _TRUNCATE ((size_t)-1)\n"
"#define _stricmp strcasecmp\n"
"\n"
"inline void fopen_s(FILE**f, const char * fileName, const char * mode)\n"
"{\n"
"\t*f = fopen(fileName, mode);\n"
"}\n"
"\n"
"inline size_t fread_s(void * buffer, size_t bufferSize, size_t elementSize, size_t count, FILE * stream)\n"
"{\n"
"\treturn fread(buffer, elementSize, count, stream);\n"
"}\n"
"\n"
"inline size_t wcsnlen_s(const wchar_t * str, size_t /*numberofElements*/)\n"
"{\n"
"\treturn wcslen(str);\n"
"}\n"
"\n"
"inline size_t strnlen_s(const char * str, size_t numberOfElements)\n"
"{\n"
"#if defined( __CYGWIN__ )\n"
"    const char* cur = str;\n"
"    if (str)\n"
"    {\n"
"        const char*const end = str + numberOfElements;\n"
"        while (*cur && cur < end) cur++;\n"
"    }\n"
"    return size_t(cur - str);\n"
"#else\n"
"\treturn strnlen(str, numberOfElements);\n"
"#endif\n"
"}\n"
"\n"
"inline int sprintf_s(char * buffer, size_t sizeOfBuffer, const char * format, ...)\n"
"{\n"
"\tva_list argptr;\n"
"\tva_start(argptr, format);\n"
"\tint rs = vsnprintf(buffer, sizeOfBuffer, format, argptr);\n"
"\tva_end(argptr);\n"
"\treturn rs;\n"
"}\n"
"\n"
"inline int swprintf_s(wchar_t * buffer, size_t sizeOfBuffer, const wchar_t * format, ...)\n"
"{\n"
"\tva_list argptr;\n"
"\tva_start(argptr, format);\n"
"\tint rs = vswprintf(buffer, sizeOfBuffer, format, argptr);\n"
"\tva_end(argptr);\n"
"\treturn rs;\n"
"}\n"
"\n"
"inline void wcscpy_s(wchar_t * strDestination, size_t /*numberOfElements*/, const wchar_t * strSource)\n"
"{\n"
"\twcscpy(strDestination, strSource);\n"
"}\n"
"inline void strcpy_s(char * strDestination, size_t /*numberOfElements*/, const char * strSource)\n"
"{\n"
"\tstrcpy(strDestination, strSource);\n"
"}\n"
"\n"
"inline void wcsncpy_s(wchar_t * strDestination, size_t /*numberOfElements*/, const wchar_t * strSource, size_t count)\n"
"{\n"
"\twcscpy(strDestination, strSource);\n"
"\t//wcsncpy(strDestination, strSource, count);\n"
"}\n"
"inline void strncpy_s(char * strDestination, size_t /*numberOfElements*/, const char * strSource, size_t count)\n"
"{\n"
"\tstrncpy(strDestination, strSource, count);\n"
"\t//wcsncpy(strDestination, strSource, count);\n"
"}\n"
"#endif\n"
"#endif\n"
"\n"
"\n"
"#include <new>\n"
"\n"
"namespace Slang\n"
"{\n"
"    class _EndLine\n"
"    {};\n"
"    extern _EndLine EndLine;\n"
"\n"
"    // in-place reversion, works only for ascii string\n"
"    inline void ReverseInternalAscii(char * buffer, int length)\n"
"    {\n"
"        int i, j;\n"
"        char c;\n"
"        for (i = 0, j = length - 1; i<j; i++, j--)\n"
"        {\n"
"            c = buffer[i];\n"
"            buffer[i] = buffer[j];\n"
"            buffer[j] = c;\n"
"        }\n"
"    }\n"
"    template<typename IntType>\n"
"    inline int IntToAscii(char * buffer, IntType val, int radix)\n"
"    {\n"
"        int i = 0;\n"
"        IntType sign;\n"
"        sign = val;\n"
"        if (sign < 0)\n"
"            val = (IntType)(0 - val);\n"
"        do\n"
"        {\n"
"            int digit = (val % radix);\n"
"            if (digit <= 9)\n"
"                buffer[i++] = (char)(digit + '0');\n"
"            else\n"
"                buffer[i++] = (char)(digit - 10 + 'A');\n"
"        } while ((val /= radix) > 0);\n"
"        if (sign < 0)\n"
"            buffer[i++] = '-';\n"
"        buffer[i] = '\\0';\n"
"        return i;\n"
"    }\n"
"\n"
"    inline bool IsUtf8LeadingByte(char ch)\n"
"    {\n"
"        return (((unsigned char)ch) & 0xC0) == 0xC0;\n"
"    }\n"
"\n"
"    inline bool IsUtf8ContinuationByte(char ch)\n"
"    {\n"
"        return (((unsigned char)ch) & 0xC0) == 0x80;\n"
"    }\n"
"\n"
"    struct SLANG_RT_API UnownedStringSlice\n"
"    {\n"
"    public:\n"
"        typedef UnownedStringSlice ThisType;\n"
"\n"
"        UnownedStringSlice()\n"
"            : m_begin(nullptr)\n"
"            , m_end(nullptr)\n"
"        {}\n"
"\n"
"        explicit UnownedStringSlice(char const* a) :\n"
"            m_begin(a),\n"
"            m_end(a ? a + strlen(a) : nullptr)\n"
"        {}\n"
"        UnownedStringSlice(char const* b, char const* e)\n"
"            : m_begin(b)\n"
"            , m_end(e)\n"
"        {}\n"
"        UnownedStringSlice(char const* b, size_t len)\n"
"            : m_begin(b)\n"
"            , m_end(b + len)\n"
"        {}\n"
"\n"
"        char const* begin() const\n"
"        {\n"
"            return m_begin;\n"
"        }\n"
"\n"
"        char const* end() const\n"
"        {\n"
"            return m_end;\n"
"        }\n"
"\n"
"            /// True if slice is strictly contained in memory.\n"
"        bool isMemoryContained(const UnownedStringSlice& slice) const\n"
"        {\n"
"            return slice.m_begin >= m_begin && slice.m_end <= m_end; \n"
"        }\n"
"        bool isMemoryContained(const char* pos) const\n"
"        {\n"
"            return pos >= m_begin && pos <= m_end;\n"
"        }\n"
"\n"
"        Index getLength() const\n"
"        {\n"
"            return Index(m_end - m_begin);\n"
"        }\n"
"\n"
"            /// Finds first index of char 'c'. If not found returns -1.\n"
"        Index indexOf(char c) const;\n"
"            /// Find first index of slice. If not found returns -1\n"
"        Index indexOf(const UnownedStringSlice& slice) const;\n"
"\n"
"            /// Returns a substring. idx is the start index, and len\n"
"            /// is the amount of characters.\n"
"            /// The returned length might be truncated, if len extends beyond slice.\n"
;
sb << 
"        UnownedStringSlice subString(Index idx, Index len) const;\n"
"\n"
"            /// Return a head of the slice - everything up to the index\n"
"        SLANG_FORCE_INLINE UnownedStringSlice head(Index idx) const { SLANG_ASSERT(idx >= 0 && idx <= getLength()); return UnownedStringSlice(m_begin, idx); }\n"
"            /// Return a tail of the slice - everything from the index to the end of the slice\n"
"        SLANG_FORCE_INLINE UnownedStringSlice tail(Index idx) const { SLANG_ASSERT(idx >= 0 && idx <= getLength()); return UnownedStringSlice(m_begin + idx, m_end); }\n"
"\n"
"            /// True if rhs and this are equal without having to take into account case\n"
"            /// Note 'case' here is *not* locale specific - it is only A-Z and a-z\n"
"        bool caseInsensitiveEquals(const ThisType& rhs) const;\n"
"\n"
"        Index lastIndexOf(char c) const\n"
"        {\n"
"            const Index size = Index(m_end - m_begin);\n"
"            for (Index i = size - 1; i >= 0; --i)\n"
"            {\n"
"                if (m_begin[i] == c)\n"
"                {\n"
"                    return i;\n"
"                }\n"
"            }\n"
"            return -1;\n"
"        }\n"
"\n"
"        const char& operator[](Index i) const\n"
"        {\n"
"            assert(i >= 0 && i < Index(m_end - m_begin));\n"
"            return m_begin[i];\n"
"        }\n"
"\n"
"        bool operator==(ThisType const& other) const;\n"
"        bool operator!=(UnownedStringSlice const& other) const { return !(*this == other);  }\n"
"\n"
"        bool operator==(char const* str) const { return (*this) == UnownedStringSlice(str); }\n"
"        bool operator!=(char const* str) const { return !(*this == str); }\n"
"\n"
"            /// True if contents is a single char of c\n"
"        SLANG_FORCE_INLINE bool isChar(char c) const { return getLength() == 1 && m_begin[0] == c; }\n"
"\n"
"        bool startsWith(UnownedStringSlice const& other) const;\n"
"        bool startsWith(char const* str) const;\n"
"\n"
"        bool endsWith(UnownedStringSlice const& other) const;\n"
"        bool endsWith(char const* str) const;\n"
"\n"
"            /// Trims any horizontal whitespace from the start and end and returns as a substring \n"
"        UnownedStringSlice trim() const;\n"
"            /// Trims any 'c' from the start or the end, and returns as a substring\n"
"        UnownedStringSlice trim(char c) const;\n"
"\n"
"            /// Trims any horizonatl whitespace from start and returns as a substring\n"
"        UnownedStringSlice trimStart() const;\n"
"\n"
"        HashCode getHashCode() const\n"
"        {\n"
"            return Slang::getHashCode(m_begin, size_t(m_end - m_begin)); \n"
"        }\n"
"\n"
"        template <size_t SIZE> \n"
"        SLANG_FORCE_INLINE static UnownedStringSlice fromLiteral(const char (&in)[SIZE]) { return UnownedStringSlice(in, SIZE - 1); }\n"
"\n"
"    private:\n"
"        char const* m_begin;\n"
"        char const* m_end;\n"
"    };\n"
"\n"
"    // A more convenient way to make slices from *string literals*\n"
"    template <size_t SIZE>\n"
"    SLANG_FORCE_INLINE UnownedStringSlice toSlice(const char (&in)[SIZE]) { return UnownedStringSlice(in, SIZE - 1); }\n"
"\n"
"    // A `StringRepresentation` provides the backing storage for\n"
"    // all reference-counted string-related types.\n"
"    class SLANG_RT_API StringRepresentation : public RefObject\n"
"    {\n"
"    public:\n"
"        Index length;\n"
"        Index capacity;\n"
"\n"
"        SLANG_FORCE_INLINE Index getLength() const\n"
"        {\n"
"            return length;\n"
"        }\n"
"\n"
"        SLANG_FORCE_INLINE char* getData()\n"
"        {\n"
"            return (char*) (this + 1);\n"
"        }\n"
"        SLANG_FORCE_INLINE const char* getData() const\n"
"        {\n"
"            return (const char*)(this + 1);\n"
"        }\n"
"\n"
"            /// Set the contents to be the slice. Must be enough capacity to hold the slice. \n"
"        void setContents(const UnownedStringSlice& slice);\n"
"\n"
"        static const char* getData(const StringRepresentation* stringRep)\n"
"        {\n"
"            return stringRep ? stringRep->getData() : \"\";\n"
"        }\n"
"\n"
"        static UnownedStringSlice asSlice(const StringRepresentation* rep)\n"
"        {\n"
"            return rep ? UnownedStringSlice(rep->getData(), rep->getLength()) : UnownedStringSlice();\n"
"        }\n"
"\n"
"        static bool equal(const StringRepresentation* a, const StringRepresentation* b)\n"
"        {\n"
"            return (a == b) || asSlice(a) == asSlice(b);\n"
"        }\n"
"\n"
"        static StringRepresentation* createWithCapacityAndLength(Index capacity, Index length)\n"
"        {\n"
"            SLANG_ASSERT(capacity >= length);\n"
"            void* allocation = operator new(sizeof(StringRepresentation) + capacity + 1);\n"
"            StringRepresentation* obj = new(allocation) StringRepresentation();\n"
"            obj->capacity = capacity;\n"
"            obj->length = length;\n"
"            obj->getData()[length] = 0;\n"
"            return obj;\n"
"        }\n"
"\n"
"        static StringRepresentation* createWithCapacity(Index capacity)\n"
"        {\n"
"            return createWithCapacityAndLength(capacity, 0);\n"
"        }\n"
"\n"
"        static StringRepresentation* createWithLength(Index length)\n"
"        {\n"
"            return createWithCapacityAndLength(length, length);\n"
"        }\n"
"\n"
"            /// Create a representation from the slice. If slice is empty will return nullptr.\n"
"        static StringRepresentation* create(const UnownedStringSlice& slice);\n"
"            /// Same as create, but representation will have refcount of 1 (if not nullptr)\n"
"        static StringRepresentation* createWithReference(const UnownedStringSlice& slice);\n"
"\n"
"        StringRepresentation* cloneWithCapacity(Index newCapacity)\n"
"        {\n"
"            StringRepresentation* newObj = createWithCapacityAndLength(newCapacity, length);\n"
"            memcpy(getData(), newObj->getData(), length + 1);\n"
"            return newObj;\n"
"        }\n"
"\n"
"        StringRepresentation* clone()\n"
"        {\n"
"            return cloneWithCapacity(length);\n"
"        }\n"
"\n"
"        StringRepresentation* ensureCapacity(Index required)\n"
"        {\n"
"            if (capacity >= required) return this;\n"
"\n"
"            Index newCapacity = capacity;\n"
"            if (!newCapacity) newCapacity = 16; // TODO: figure out good value for minimum capacity\n"
"\n"
"            while (newCapacity < required)\n"
"            {\n"
"                newCapacity = 2 * newCapacity;\n"
"            }\n"
"\n"
"            return cloneWithCapacity(newCapacity);\n"
"        }\n"
"    };\n"
"\n"
"    class String;\n"
"\n"
"\n"
"\n"
"    struct SLANG_RT_API UnownedTerminatedStringSlice : public UnownedStringSlice\n"
"    {\n"
"    public:\n"
"        UnownedTerminatedStringSlice(char const* b)\n"
"            : UnownedStringSlice(b, b + (b?strlen(b):0))\n"
"        {}\n"
"    };\n"
"\n"
"    struct SLANG_RT_API StringSlice\n"
"    {\n"
"    public:\n"
"        StringSlice();\n"
"\n"
"        StringSlice(String const& str);\n"
"\n"
"        StringSlice(String const& str, UInt beginIndex, UInt endIndex);\n"
"\n"
"        UInt getLength() const\n"
"        {\n"
"            return endIndex - beginIndex;\n"
"        }\n"
"\n"
"        char const* begin() const\n"
"        {\n"
"            return representation ? representation->getData() + beginIndex : \"\";\n"
"        }\n"
"\n"
"        char const* end() const\n"
"        {\n"
"            return begin() + getLength();\n"
"        }\n"
"\n"
"    private:\n"
"        RefPtr<StringRepresentation> representation;\n"
"        UInt beginIndex;\n"
"        UInt endIndex;\n"
"\n"
"        friend class String;\n"
"\n"
"        StringSlice(RefPtr<StringRepresentation> const& representation, UInt beginIndex, UInt endIndex)\n"
"            : representation(representation)\n"
"            , beginIndex(beginIndex)\n"
"            , endIndex(endIndex)\n"
"        {}\n"
"    };\n"
"\n"
"    /// String as expected by underlying platform APIs\n"
"    class SLANG_RT_API OSString\n"
"    {\n"
"    public:\n"
"            /// Default\n"
"        OSString();\n"
"            /// NOTE! This assumes that begin is a new wchar_t[] buffer, and it will\n"
"            /// now be owned by the OSString\n"
"        OSString(wchar_t* begin, wchar_t* end);\n"
"            /// Move Ctor\n"
"        OSString(OSString&& rhs):\n"
"            m_begin(rhs.m_begin),\n"
"            m_end(rhs.m_end)\n"
"        {\n"
"            rhs.m_begin = nullptr;\n"
"            rhs.m_end = nullptr;\n"
"        }\n"
"            // Copy Ctor\n"
"        OSString(const OSString& rhs) :\n"
"            m_begin(nullptr),\n"
"            m_end(nullptr)\n"
"        {\n"
"            set(rhs.m_begin, rhs.m_end);\n"
"        }\n"
"\n"
"            /// =\n"
"        void operator=(const OSString& rhs) { set(rhs.m_begin, rhs.m_end); }\n"
"        void operator=(OSString&& rhs)\n"
"        {\n"
"            auto begin = m_begin;\n"
"            auto end = m_end;\n"
"            m_begin = rhs.m_begin;\n"
"            m_end = rhs.m_end;\n"
"            rhs.m_begin = begin;\n"
"            rhs.m_end = end;\n"
"        }\n"
"\n"
"        ~OSString() { _releaseBuffer(); }\n"
"\n"
"        size_t getLength() const { return (m_end - m_begin); }\n"
"        void set(const wchar_t* begin, const wchar_t* end);\n"
"\n"
"        operator wchar_t const*() const\n"
"        {\n"
"            return begin();\n"
"        }\n"
"\n"
"        wchar_t const* begin() const;\n"
"        wchar_t const* end() const;\n"
"\n"
"    private:\n"
"\n"
"        void _releaseBuffer();\n"
"\n"
"        wchar_t* m_begin;           ///< First character. This is a new wchar_t[] buffer\n"
"        wchar_t* m_end;             ///< Points to terminating 0\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Represents a UTF-8 encoded string.\n"
"    */\n"
"\n"
"    class SLANG_RT_API String\n"
"    {\n"
"        friend struct StringSlice;\n"
"        friend class StringBuilder;\n"
"    private:\n"
"\n"
"\n"
"        char* getData() const\n"
"        {\n"
"            return m_buffer ? m_buffer->getData() : (char*)\"\";\n"
"        }\n"
"\n"
"     \n"
"        void ensureUniqueStorageWithCapacity(Index capacity);\n"
"     \n"
"        RefPtr<StringRepresentation> m_buffer;\n"
"\n"
"    public:\n"
"\n"
"        explicit String(StringRepresentation* buffer)\n"
"            : m_buffer(buffer)\n"
"        {}\n"
"\n"
"        static String fromWString(const wchar_t * wstr);\n"
"        static String fromWString(const wchar_t * wstr, const wchar_t * wend);\n"
"        static String fromWChar(const wchar_t ch);\n"
"        static String fromUnicodePoint(Char32 codePoint);\n"
"        String()\n"
"        {\n"
"        }\n"
"\n"
"            /// Returns a buffer which can hold at least count chars\n"
"        char* prepareForAppend(Index count);\n"
"            /// Append data written to buffer output via 'prepareForAppend' directly written 'inplace'\n"
"        void appendInPlace(const char* chars, Index count);\n"
"\n"
"        SLANG_FORCE_INLINE StringRepresentation* getStringRepresentation() const { return m_buffer; }\n"
"\n"
"        const char * begin() const\n"
"        {\n"
"            return getData();\n"
"        }\n"
"        const char * end() const\n"
"        {\n"
"            return getData() + getLength();\n"
"        }\n"
"\n"
"        void append(int32_t value, int radix = 10);\n"
"        void append(uint32_t value, int radix = 10);\n"
"        void append(int64_t value, int radix = 10);\n"
"        void append(uint64_t value, int radix = 10);\n"
"        void append(float val, const char * format = \"%g\");\n"
"        void append(double val, const char * format = \"%g\");\n"
"\n"
"        void append(char const* str);\n"
"        void append(const char* textBegin, char const* textEnd);\n"
"        void append(char chr);\n"
"        void append(String const& str);\n"
"        void append(StringSlice const& slice);\n"
"        void append(UnownedStringSlice const& slice);\n"
"\n"
"            /// Append a character (to remove ambiguity with other integral types)\n"
"        void appendChar(char chr);\n"
"\n"
"            /// Append the specified char count times\n"
"        void appendRepeatedChar(char chr, Index count);\n"
"\n"
"        String(const char* str)\n"
"        {\n"
"            append(str);\n"
"#if 0\n"
"            if (str)\n"
"            {\n"
"                buffer = StringRepresentation::createWithLength(strlen(str));\n"
"                memcpy(buffer.Ptr(), str, getLength() + 1);\n"
"            }\n"
"#endif\n"
"        }\n"
"        String(const char* textBegin, char const* textEnd)\n"
"        {\n"
"            append(textBegin, textEnd);\n"
"#if 0\n"
"            if (textBegin != textEnd)\n"
"            {\n"
"                buffer = StringRepresentation::createWithLength(textEnd - textBegin);\n"
"                memcpy(buffer.Ptr(), textBegin, getLength());\n"
"                buffer->getData()[getLength()] = 0;\n"
"            }\n"
"#endif\n"
"        }\n"
"\n"
"        // Make all String ctors from a numeric explicit, to avoid unexpected/unnecessary conversions\n"
"        explicit String(int32_t val, int radix = 10)\n"
"        {\n"
"            append(val, radix);\n"
"        }\n"
"        explicit String(uint32_t val, int radix = 10)\n"
"        {\n"
"            append(val, radix);\n"
"        }\n"
"        explicit String(int64_t val, int radix = 10)\n"
"        {\n"
"            append(val, radix);\n"
"        }\n"
"        explicit String(uint64_t val, int radix = 10)\n"
"        {\n"
"            append(val, radix);\n"
"        }\n"
"        explicit String(float val, const char * format = \"%g\")\n"
"        {\n"
"            append(val, format);\n"
"        }\n"
"        explicit String(double val, const char * format = \"%g\")\n"
"        {\n"
"            append(val, format);\n"
"        }\n"
"\n"
"        explicit String(char chr)\n"
"        {\n"
"            append(chr);\n"
"#if 0\n"
"            if (chr)\n"
"            {\n"
"                buffer = StringRepresentation::createWithLength(1);\n"
"                buffer->getData()[0] = chr;\n"
"                buffer->getData()[1] = 0;\n"
"            }\n"
"#endif\n"
"        }\n"
"        String(String const& str)\n"
"        {\n"
"            m_buffer = str.m_buffer;\n"
"#if 0\n"
"            this->operator=(str);\n"
"#endif\n"
"        }\n"
"        String(String&& other)\n"
"        {\n"
"            m_buffer = _Move(other.m_buffer);\n"
"        }\n"
"\n"
"        String(StringSlice const& slice)\n"
"        {\n"
"            append(slice);\n"
"        }\n"
"\n"
"        String(UnownedStringSlice const& slice)\n"
"        {\n"
"            append(slice);\n"
"        }\n"
"\n"
"        ~String()\n"
"        {\n"
"            m_buffer.setNull(); \n"
"        }\n"
"\n"
"        String & operator=(const String & str)\n"
"        {\n"
"            m_buffer = str.m_buffer;\n"
"            return *this;\n"
"        }\n"
"        String & operator=(String&& other)\n"
"        {\n"
"            m_buffer = _Move(other.m_buffer);\n"
"            return *this;\n"
"        }\n"
"        char operator[](Index id) const\n"
"        {\n"
"            SLANG_ASSERT(id >= 0 && id < getLength());\n"
"            return begin()[id];\n"
"        }\n"
"\n"
"        Index getLength() const\n"
"        {\n"
"            return m_buffer ? m_buffer->getLength() : 0;\n"
"        }\n"
"            /// Make the length of the string the amount specified. Must be less than current size\n"
"        void reduceLength(Index length);\n"
"        \n"
"        friend String operator+(const char*op1, const String & op2);\n"
"        friend String operator+(const String & op1, const char * op2);\n"
"        friend String operator+(const String & op1, const String & op2);\n"
"\n"
"        StringSlice trimStart() const\n"
"        {\n"
"            if (!m_buffer)\n"
"                return StringSlice();\n"
"            Index startIndex = 0;\n"
"            const char*const data = getData();\n"
"            while (startIndex < getLength() &&\n"
"                (data[startIndex] == ' ' || data[startIndex] == '\\t' || data[startIndex] == '\\r' || data[startIndex] == '\\n'))\n"
"                startIndex++;\n"
"            return StringSlice(m_buffer, startIndex, getLength());\n"
"        }\n"
"\n"
"        StringSlice trimEnd() const\n"
"        {\n"
"            if (!m_buffer)\n"
"                return StringSlice();\n"
"\n"
"            Index endIndex = getLength();\n"
"            const char*const data = getData();\n"
"            while (endIndex > 0 &&\n"
"                (data[endIndex-1] == ' ' || data[endIndex-1] == '\\t' || data[endIndex-1] == '\\r' || data[endIndex-1] == '\\n'))\n"
"                endIndex--;\n"
"\n"
"            return StringSlice(m_buffer, 0, endIndex);\n"
"        }\n"
"\n"
"        StringSlice trim() const\n"
"        {\n"
"            if (!m_buffer)\n"
"                return StringSlice();\n"
"\n"
"            Index startIndex = 0;\n"
"            const char*const data = getData();\n"
"            while (startIndex < getLength() &&\n"
"                (data[startIndex] == ' ' || data[startIndex] == '\\t'))\n"
"                startIndex++;\n"
"            Index endIndex = getLength();\n"
"            while (endIndex > startIndex &&\n"
"                (data[endIndex-1] == ' ' || data[endIndex-1] == '\\t'))\n"
"                endIndex--;\n"
"\n"
"            return StringSlice(m_buffer, startIndex, endIndex);\n"
"        }\n"
"\n"
"        StringSlice subString(Index id, Index len) const\n"
"        {\n"
"            if (len == 0)\n"
"                return StringSlice();\n"
"\n"
"            if (id + len > getLength())\n"
"                len = getLength() - id;\n"
"#if _DEBUG\n"
"            if (id < 0 || id >= getLength() || (id + len) > getLength())\n"
"                SLANG_ASSERT_FAILURE(\"SubString: index out of range.\");\n"
"            if (len < 0)\n"
"                SLANG_ASSERT_FAILURE(\"SubString: length less than zero.\");\n"
"#endif\n"
"            return StringSlice(m_buffer, id, id + len);\n"
"        }\n"
"\n"
"        char const* getBuffer() const\n"
"        {\n"
"            return getData();\n"
"        }\n"
"\n"
"        OSString toWString(Index* len = 0) const;\n"
"\n"
"        bool equals(const String & str, bool caseSensitive = true)\n"
"        {\n"
"            if (caseSensitive)\n"
"                return (strcmp(begin(), str.begin()) == 0);\n"
"            else\n"
"            {\n"
"#ifdef _MSC_VER\n"
"                return (_stricmp(begin(), str.begin()) == 0);\n"
"#else\n"
"                return (strcasecmp(begin(), str.begin()) == 0);\n"
"#endif\n"
"            }\n"
"        }\n"
"        bool operator==(const char * strbuffer) const\n"
"        {\n"
;
sb << 
"            return (strcmp(begin(), strbuffer) == 0);\n"
"        }\n"
"\n"
"        bool operator==(const String & str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) == 0);\n"
"        }\n"
"        bool operator!=(const char * strbuffer) const\n"
"        {\n"
"            return (strcmp(begin(), strbuffer) != 0);\n"
"        }\n"
"        bool operator!=(const String & str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) != 0);\n"
"        }\n"
"        bool operator>(const String & str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) > 0);\n"
"        }\n"
"        bool operator<(const String & str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) < 0);\n"
"        }\n"
"        bool operator>=(const String & str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) >= 0);\n"
"        }\n"
"        bool operator<=(const String & str) const\n"
"        {\n"
"            return (strcmp(begin(), str.begin()) <= 0);\n"
"        }\n"
"\n"
"        SLANG_FORCE_INLINE bool operator==(const UnownedStringSlice& slice) const { return getUnownedSlice() == slice; }\n"
"        SLANG_FORCE_INLINE bool operator!=(const UnownedStringSlice& slice) const { return getUnownedSlice() != slice; }\n"
"\n"
"        String toUpper() const\n"
"        {\n"
"            String result;\n"
"            for (auto c : *this)\n"
"            {\n"
"                char d = (c >= 'a' && c <= 'z') ? (c - ('a' - 'A')) : c;\n"
"                result.append(d);\n"
"            }\n"
"            return result;\n"
"        }\n"
"\n"
"        String toLower() const\n"
"        {\n"
"            String result;\n"
"            for (auto c : *this)\n"
"            {\n"
"                char d = (c >= 'A' && c <= 'Z') ? (c - ('A' - 'a')) : c;\n"
"                result.append(d);\n"
"            }\n"
"            return result;\n"
"        }\n"
"\n"
"        Index indexOf(const char * str, Index id) const // String str\n"
"        {\n"
"            if (id >= getLength())\n"
"                return Index(-1);\n"
"            auto findRs = strstr(begin() + id, str);\n"
"            Index res = findRs ? findRs - begin() : Index(-1);\n"
"            return res;\n"
"        }\n"
"\n"
"        Index indexOf(const String & str, Index id) const\n"
"        {\n"
"            return indexOf(str.begin(), id);\n"
"        }\n"
"\n"
"        Index indexOf(const char * str) const\n"
"        {\n"
"            return indexOf(str, 0);\n"
"        }\n"
"\n"
"        Index indexOf(const String & str) const\n"
"        {\n"
"            return indexOf(str.begin(), 0);\n"
"        }\n"
"\n"
"        Index indexOf(char ch, Index id) const\n"
"        {\n"
"            const Index length = getLength();\n"
"            SLANG_ASSERT(id >= 0 && id <= length);\n"
"\n"
"            if (!m_buffer)\n"
"                return Index(-1);\n"
"\n"
"            const char* data = getData();\n"
"            for (Index i = id; i < length; i++)\n"
"                if (data[i] == ch)\n"
"                    return i;\n"
"            return Index(-1);\n"
"        }\n"
"\n"
"        Index indexOf(char ch) const\n"
"        {\n"
"            return indexOf(ch, 0);\n"
"        }\n"
"\n"
"        Index lastIndexOf(char ch) const\n"
"        {            \n"
"            const Index length = getLength();\n"
"            const char* data = getData();\n"
"\n"
"            // TODO(JS): If we know Index is signed we can do this a bit more simply\n"
"\n"
"            for (Index i = length; i > 0; i--)\n"
"                if (data[i - 1] == ch)\n"
"                    return i - 1;\n"
"            return Index(-1);\n"
"        }\n"
"\n"
"        bool startsWith(const char * str) const // String str\n"
"        {\n"
"            if (!m_buffer)\n"
"                return false;\n"
"            Index strLen = Index(::strlen(str));\n"
"            if (strLen > getLength())\n"
"                return false;\n"
"\n"
"            const char*const data = getData();\n"
"\n"
"            for (Index i = 0; i < strLen; i++)\n"
"                if (str[i] != data[i])\n"
"                    return false;\n"
"            return true;\n"
"        }\n"
"\n"
"        bool startsWith(const String& str) const\n"
"        {\n"
"            return startsWith(str.begin());\n"
"        }\n"
"\n"
"        bool endsWith(char const * str)  const // String str\n"
"        {\n"
"            if (!m_buffer)\n"
"                return false;\n"
"\n"
"            const Index strLen = Index(::strlen(str));\n"
"            const Index len = getLength();\n"
"\n"
"            if (strLen > len)\n"
"                return false;\n"
"            const char* data = getData();\n"
"            for (Index i = strLen; i > 0; i--)\n"
"                if (str[i-1] != data[len - strLen + i-1])\n"
"                    return false;\n"
"            return true;\n"
"        }\n"
"\n"
"        bool endsWith(const String & str) const\n"
"        {\n"
"            return endsWith(str.begin());\n"
"        }\n"
"\n"
"        bool contains(const char * str) const // String str\n"
"        {\n"
"            return m_buffer && indexOf(str) != Index(-1); \n"
"        }\n"
"\n"
"        bool contains(const String & str) const\n"
"        {\n"
"            return contains(str.begin());\n"
"        }\n"
"\n"
"        HashCode getHashCode() const\n"
"        {\n"
"            return Slang::getHashCode(StringRepresentation::asSlice(m_buffer));\n"
"        }\n"
"\n"
"        UnownedStringSlice getUnownedSlice() const\n"
"        {\n"
"            return StringRepresentation::asSlice(m_buffer);\n"
"        }\n"
"    };\n"
"\n"
"    class SLANG_RT_API StringBuilder : public String\n"
"    {\n"
"    private:\n"
"        enum { InitialSize = 1024 };\n"
"    public:\n"
"        explicit StringBuilder(UInt bufferSize = InitialSize)\n"
"        {\n"
"            ensureUniqueStorageWithCapacity(bufferSize);\n"
"        }\n"
"        void EnsureCapacity(UInt size)\n"
"        {\n"
"            ensureUniqueStorageWithCapacity(size);\n"
"        }\n"
"        StringBuilder & operator << (char ch)\n"
"        {\n"
"            Append(&ch, 1);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (Int32 val)\n"
"        {\n"
"            Append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (UInt32 val)\n"
"        {\n"
"            Append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (Int64 val)\n"
"        {\n"
"            Append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (UInt64 val)\n"
"        {\n"
"            Append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (float val)\n"
"        {\n"
"            Append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (double val)\n"
"        {\n"
"            Append(val);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (const char * str)\n"
"        {\n"
"            Append(str, strlen(str));\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (const String & str)\n"
"        {\n"
"            Append(str);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (UnownedStringSlice const& str)\n"
"        {\n"
"            append(str);\n"
"            return *this;\n"
"        }\n"
"        StringBuilder & operator << (const _EndLine)\n"
"        {\n"
"            Append('\\n');\n"
"            return *this;\n"
"        }\n"
"        void Append(char ch)\n"
"        {\n"
"            Append(&ch, 1);\n"
"        }\n"
"        void Append(float val)\n"
"        {\n"
"            char buf[128];\n"
"            sprintf_s(buf, 128, \"%g\", val);\n"
"            int len = (int)strnlen_s(buf, 128);\n"
"            Append(buf, len);\n"
"        }\n"
"        void Append(double val)\n"
"        {\n"
"            char buf[128];\n"
"            sprintf_s(buf, 128, \"%g\", val);\n"
"            int len = (int)strnlen_s(buf, 128);\n"
"            Append(buf, len);\n"
"        }\n"
"        void Append(Int32 value, int radix = 10)\n"
"        {\n"
"            char vBuffer[33];\n"
"            int len = IntToAscii(vBuffer, value, radix);\n"
"            ReverseInternalAscii(vBuffer, len);\n"
"            Append(vBuffer);\n"
"        }\n"
"        void Append(UInt32 value, int radix = 10)\n"
"        {\n"
"            char vBuffer[33];\n"
"            int len = IntToAscii(vBuffer, value, radix);\n"
"            ReverseInternalAscii(vBuffer, len);\n"
"            Append(vBuffer);\n"
"        }\n"
"        void Append(Int64 value, int radix = 10)\n"
"        {\n"
"            char vBuffer[65];\n"
"            int len = IntToAscii(vBuffer, value, radix);\n"
"            ReverseInternalAscii(vBuffer, len);\n"
"            Append(vBuffer);\n"
"        }\n"
"        void Append(UInt64 value, int radix = 10)\n"
"        {\n"
"            char vBuffer[65];\n"
"            int len = IntToAscii(vBuffer, value, radix);\n"
"            ReverseInternalAscii(vBuffer, len);\n"
"            Append(vBuffer);\n"
"        }\n"
"        void Append(const String & str)\n"
"        {\n"
"            Append(str.getBuffer(), str.getLength());\n"
"        }\n"
"        void Append(const char * str)\n"
"        {\n"
"            Append(str, strlen(str));\n"
"        }\n"
"        void Append(const char * str, UInt strLen)\n"
"        {\n"
"            append(str, str + strLen);\n"
"        }\n"
"\n"
"#if 0\n"
"        int Capacity()\n"
"        {\n"
"            return bufferSize;\n"
"        }\n"
"\n"
"        char * Buffer()\n"
"        {\n"
"            return buffer;\n"
"        }\n"
"\n"
"        int Length()\n"
"        {\n"
"            return length;\n"
"        }\n"
"#endif\n"
"\n"
"        String ToString()\n"
"        {\n"
"            return *this;\n"
"        }\n"
"\n"
"        String ProduceString()\n"
"        {\n"
"            return *this;\n"
"        }\n"
"\n"
"#if 0\n"
"        String GetSubString(int start, int count)\n"
"        {\n"
"            String rs;\n"
"            rs.buffer = new char[count + 1];\n"
"            rs.length = count;\n"
"            strncpy_s(rs.buffer.Ptr(), count + 1, buffer + start, count);\n"
"            rs.buffer[count] = 0;\n"
"            return rs;\n"
"        }\n"
"#endif\n"
"\n"
"#if 0\n"
"        void Remove(int id, int len)\n"
"        {\n"
"#if _DEBUG\n"
"            if (id >= length || id < 0)\n"
"                SLANG_ASSERT_FAILURE(\"Remove: Index out of range.\");\n"
"            if (len < 0)\n"
"                SLANG_ASSERT_FAILURE(\"Remove: remove length smaller than zero.\");\n"
"#endif\n"
"            int actualDelLength = ((id + len) >= length) ? (length - id) : len;\n"
"            for (int i = id + actualDelLength; i <= length; i++)\n"
"                buffer[i - actualDelLength] = buffer[i];\n"
"            length -= actualDelLength;\n"
"        }\n"
"#endif\n"
"\n"
"        void Clear()\n"
"        {\n"
"            m_buffer.setNull();\n"
"        }\n"
"    };\n"
"\n"
"    int StringToInt(const String & str, int radix = 10);\n"
"    unsigned int StringToUInt(const String & str, int radix = 10);\n"
"    double StringToDouble(const String & str);\n"
"    float StringToFloat(const String & str);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"#ifdef SLANG_RT_DYNAMIC_EXPORT\n"
"#    define SLANG_RT_API SLANG_DLL_EXPORT\n"
"#else\n"
"#    define SLANG_RT_API\n"
"#endif\n"
"\n"
"extern \"C\"\n"
"{\n"
"    SLANG_RT_API void SLANG_MCALL _slang_rt_abort(Slang::String errorMessage);\n"
"    SLANG_RT_API void* SLANG_MCALL _slang_rt_load_dll(Slang::String modulePath);\n"
"    SLANG_RT_API void* SLANG_MCALL\n"
"        _slang_rt_load_dll_func(void* moduleHandle, Slang::String modulePath);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"#ifndef SLANG_COM_PTR_H\n"
"#define SLANG_COM_PTR_H\n"
"\n"
"#ifndef SLANG_COM_HELPER_H\n"
"#define SLANG_COM_HELPER_H\n"
"\n"
"/** \\file slang-com-helper.h\n"
"*/\n"
"\n"
"#include <atomic>\n"
"\n"
"/* !!!!!!!!!!!!!!!!!!!!! Macros to help checking SlangResult !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n"
"\n"
"/*! Set SLANG_HANDLE_RESULT_FAIL(x) to code to be executed whenever an error occurs, and is detected by one of the macros */\n"
"#ifndef SLANG_HANDLE_RESULT_FAIL\n"
"#\tdefine SLANG_HANDLE_RESULT_FAIL(x)\n"
"#endif\n"
"\n"
"//! Helper macro, that makes it easy to add result checking to calls in functions/methods that themselves return Result. \n"
"#define SLANG_RETURN_ON_FAIL(x) { SlangResult _res = (x); if (SLANG_FAILED(_res)) { SLANG_HANDLE_RESULT_FAIL(_res); return _res; } }\n"
"//! Helper macro that can be used to test the return value from a call, and will return in a void method/function\n"
"#define SLANG_RETURN_VOID_ON_FAIL(x) { SlangResult _res = (x); if (SLANG_FAILED(_res)) { SLANG_HANDLE_RESULT_FAIL(_res); return; } }\n"
"//! Helper macro that will return false on failure.\n"
"#define SLANG_RETURN_FALSE_ON_FAIL(x) { SlangResult _res = (x); if (SLANG_FAILED(_res)) { SLANG_HANDLE_RESULT_FAIL(_res); return false; } }\n"
"//! Helper macro that will return nullptr on failure.\n"
"#define SLANG_RETURN_NULL_ON_FAIL(x) { SlangResult _res = (x); if (SLANG_FAILED(_res)) { SLANG_HANDLE_RESULT_FAIL(_res); return nullptr; } }\n"
"\n"
"//! Helper macro that will assert if the return code from a call is failure, also returns the failure.\n"
"#define SLANG_ASSERT_ON_FAIL(x) { SlangResult _res = (x); if (SLANG_FAILED(_res)) { assert(false); return _res; } }\n"
"//! Helper macro that will assert if the result from a call is a failure, also returns. \n"
"#define SLANG_ASSERT_VOID_ON_FAIL(x) { SlangResult _res = (x); if (SLANG_FAILED(_res)) { assert(false); return; } }\n"
"\n"
"/* !!!!!!!!!!!!!!!!!!!!!!! C++ helpers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/\n"
"\n"
"#if defined(__cplusplus)\n"
"namespace Slang {\n"
"\n"
"// Alias SlangResult to Slang::Result\n"
"typedef SlangResult Result;\n"
"// Alias SlangUUID to Slang::Guid\n"
"typedef SlangUUID Guid;\n"
"\n"
"} // namespace Slang\n"
"\n"
"// Operator == and != for Guid/SlangUUID\n"
"\n"
"SLANG_FORCE_INLINE bool operator==(const Slang::Guid& aIn, const Slang::Guid& bIn)\n"
"{\n"
"    using namespace Slang;\n"
"    // Use the largest type the honors the alignment of Guid\n"
"    typedef uint32_t CmpType;\n"
"    union GuidCompare\n"
"    {\n"
"        Guid guid;\n"
"        CmpType data[sizeof(Guid) / sizeof(CmpType)];\n"
"    };\n"
"    // Type pun - so compiler can 'see' the pun and not break aliasing rules\n"
"    const CmpType* a = reinterpret_cast<const GuidCompare&>(aIn).data;\n"
"    const CmpType* b = reinterpret_cast<const GuidCompare&>(bIn).data;\n"
"    // Make the guid comparison a single branch, by not using short circuit\n"
"    return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2]) | (a[3] ^ b[3])) == 0;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE bool operator!=(const Slang::Guid& a, const Slang::Guid& b)\n"
"{\n"
"    return !(a == b);\n"
"}\n"
"\n"
"/* !!!!!!!! Macros to simplify implementing COM interfaces !!!!!!!!!!!!!!!!!!!!!!!!!!!! */\n"
"\n"
"/* Assumes underlying implementation has a member m_refCount that is initialized to 0 and can have ++ and -- operate on it. \n"
"For SLANG_IUNKNOWN_QUERY_INTERFACE to work - must have a method 'getInterface' that returns valid pointers for the Guid, or nullptr \n"
"if not found. */\n"
"\n"
"#define SLANG_IUNKNOWN_QUERY_INTERFACE \\\n"
"SLANG_NO_THROW SlangResult SLANG_MCALL queryInterface(SlangUUID const& uuid, void** outObject) SLANG_OVERRIDE \\\n"
"{ \\\n"
"    ISlangUnknown* intf = getInterface(uuid); \\\n"
"    if (intf) \\\n"
"    { \\\n"
"        addRef(); \\\n"
"        *outObject = intf; \\\n"
"        return SLANG_OK;\\\n"
"    } \\\n"
"    return SLANG_E_NO_INTERFACE;\\\n"
"}\n"
"\n"
"#define SLANG_IUNKNOWN_ADD_REF \\\n"
"SLANG_NO_THROW uint32_t SLANG_MCALL addRef() \\\n"
"{ \\\n"
"    return ++m_refCount; \\\n"
"}\n"
"\n"
"#define SLANG_IUNKNOWN_RELEASE \\\n"
"SLANG_NO_THROW uint32_t SLANG_MCALL release() \\\n"
"{ \\\n"
"    --m_refCount; \\\n"
"    if (m_refCount == 0) \\\n"
"    { \\\n"
"        delete this; \\\n"
"        return 0; \\\n"
"    } \\\n"
"    return m_refCount; \\\n"
"} \n"
"\n"
"#define SLANG_IUNKNOWN_ALL \\\n"
"    SLANG_IUNKNOWN_QUERY_INTERFACE \\\n"
"    SLANG_IUNKNOWN_ADD_REF \\\n"
"    SLANG_IUNKNOWN_RELEASE \n"
"\n"
"// ------------------------ RefObject IUnknown -----------------------------\n"
"\n"
"#define SLANG_REF_OBJECT_IUNKNOWN_QUERY_INTERFACE \\\n"
"SLANG_NO_THROW SlangResult SLANG_MCALL queryInterface(SlangUUID const& uuid, void** outObject) SLANG_OVERRIDE \\\n"
"{ \\\n"
"    void* intf = getInterface(uuid); \\\n"
"    if (intf) \\\n"
"    { \\\n"
"        addReference(); \\\n"
"        *outObject = intf; \\\n"
"        return SLANG_OK;\\\n"
"    } \\\n"
"    return SLANG_E_NO_INTERFACE;\\\n"
"}\n"
"\n"
"#define SLANG_REF_OBJECT_IUNKNOWN_ADD_REF SLANG_NO_THROW uint32_t SLANG_MCALL addRef() SLANG_OVERRIDE { return (uint32_t)addReference(); }\n"
"#define SLANG_REF_OBJECT_IUNKNOWN_RELEASE SLANG_NO_THROW uint32_t SLANG_MCALL release() SLANG_OVERRIDE { return (uint32_t)releaseReference(); }\n"
"\n"
"#    define SLANG_REF_OBJECT_IUNKNOWN_ALL         \\\n"
"        SLANG_REF_OBJECT_IUNKNOWN_QUERY_INTERFACE \\\n"
"        SLANG_REF_OBJECT_IUNKNOWN_ADD_REF         \\\n"
"        SLANG_REF_OBJECT_IUNKNOWN_RELEASE\n"
"\n"
"#endif // defined(__cplusplus)\n"
"\n"
"#endif\n"
"\n"
"\n"
"#include <assert.h>\n"
"#include <cstddef>\n"
"\n"
"namespace Slang {\n"
"\n"
"/*! \\brief ComPtr is a simple smart pointer that manages types which implement COM based interfaces.\n"
"\\details A class that implements a COM, must derive from the IUnknown interface or a type that matches\n"
"it's layout exactly (such as ISlangUnknown). Trying to use this template with a class that doesn't follow\n"
"these rules, will lead to undefined behavior.\n"
"This is a 'strong' pointer type, and will AddRef when a non null pointer is set and Release when the pointer\n"
"leaves scope.\n"
"Using 'detach' allows a pointer to be removed from the management of the ComPtr.\n"
"To set the smart pointer to null, there is the method setNull, or alternatively just assign SLANG_NULL/nullptr.\n"
"\n"
"One edge case using the template is that sometimes you want access as a pointer to a pointer. Sometimes this\n"
"is to write into the smart pointer, other times to pass as an array. To handle these different behaviors\n"
"there are the methods readRef and writeRef, which are used instead of the & (ref) operator. For example\n"
"\n"
"\\code\n"
"Void doSomething(ID3D12Resource** resources, IndexT numResources);\n"
"// ...\n"
"ComPtr<ID3D12Resource> resources[3];\n"
"doSomething(resources[0].readRef(), SLANG_COUNT_OF(resource));\n"
"\\endcode\n"
"\n"
"A more common scenario writing to the pointer\n"
"\n"
"\\code\n"
"IUnknown* unk = ...;\n"
"\n"
"ComPtr<ID3D12Resource> resource;\n"
"Result res = unk->QueryInterface(resource.writeRef());\n"
"\\endcode\n"
"*/\n"
"\n"
"// Enum to force initializing as an attach (without adding a reference)\n"
"enum InitAttach\n"
"{\n"
"    INIT_ATTACH\n"
"};\n"
"\n"
;
sb << 
"template <class T>\n"
"class ComPtr\n"
"{\n"
"public:\n"
"\ttypedef T Type;\n"
"\ttypedef ComPtr ThisType;\n"
"\ttypedef ISlangUnknown* Ptr;\n"
"\n"
"\t\t/// Constructors\n"
"\t\t/// Default Ctor. Sets to nullptr\n"
"\tSLANG_FORCE_INLINE ComPtr() :m_ptr(nullptr) {}\n"
"    SLANG_FORCE_INLINE ComPtr(std::nullptr_t) : m_ptr(nullptr) {}\n"
"\t\t/// Sets, and ref counts.\n"
"\tSLANG_FORCE_INLINE explicit ComPtr(T* ptr) :m_ptr(ptr) { if (ptr) ((Ptr)ptr)->addRef(); }\n"
"\t\t/// The copy ctor\n"
"\tSLANG_FORCE_INLINE ComPtr(const ThisType& rhs) : m_ptr(rhs.m_ptr) { if (m_ptr) ((Ptr)m_ptr)->addRef(); }\n"
"\n"
"        /// Ctor without adding to ref count.\n"
"    SLANG_FORCE_INLINE explicit ComPtr(InitAttach, T* ptr) :m_ptr(ptr) { }\n"
"        /// Ctor without adding to ref count\n"
"    SLANG_FORCE_INLINE ComPtr(InitAttach, const ThisType& rhs) : m_ptr(rhs.m_ptr) { }\n"
"\n"
"#ifdef SLANG_HAS_MOVE_SEMANTICS\n"
"\t\t/// Move Ctor\n"
"\tSLANG_FORCE_INLINE ComPtr(ThisType&& rhs) : m_ptr(rhs.m_ptr) { rhs.m_ptr = nullptr; }\n"
"\t\t/// Move assign\n"
"\tSLANG_FORCE_INLINE ComPtr& operator=(ThisType&& rhs) { T* swap = m_ptr; m_ptr = rhs.m_ptr; rhs.m_ptr = swap; return *this; }\n"
"#endif\n"
"\n"
"\t/// Destructor releases the pointer, assuming it is set\n"
"\tSLANG_FORCE_INLINE ~ComPtr() { if (m_ptr) ((Ptr)m_ptr)->release(); }\n"
"\n"
"\t// !!! Operators !!!\n"
"\n"
"\t  /// Returns the dumb pointer\n"
"\tSLANG_FORCE_INLINE operator T *() const { return m_ptr; }\n"
"\n"
"\tSLANG_FORCE_INLINE T& operator*() { return *m_ptr; }\n"
"\t\t/// For making method invocations through the smart pointer work through the dumb pointer\n"
"\tSLANG_FORCE_INLINE T* operator->() const { return m_ptr; }\n"
"\n"
"\t\t/// Assign\n"
"\tSLANG_FORCE_INLINE const ThisType &operator=(const ThisType& rhs);\n"
"\t\t/// Assign from dumb ptr\n"
"\tSLANG_FORCE_INLINE T* operator=(T* in);\n"
"\n"
"\t\t/// Get the pointer and don't ref\n"
"\tSLANG_FORCE_INLINE T* get() const { return m_ptr; }\n"
"\t\t/// Release a contained nullptr pointer if set\n"
"\tSLANG_FORCE_INLINE void setNull();\n"
"\n"
"\t\t/// Detach\n"
"\tSLANG_FORCE_INLINE T* detach() { T* ptr = m_ptr; m_ptr = nullptr; return ptr; }\n"
"\t\t/// Set to a pointer without changing the ref count\n"
"\tSLANG_FORCE_INLINE void attach(T* in) { m_ptr = in; }\n"
"\n"
"\t\t/// Get ready for writing (nulls contents)\n"
"\tSLANG_FORCE_INLINE T** writeRef() { setNull(); return &m_ptr; }\n"
"\t\t/// Get for read access\n"
"\tSLANG_FORCE_INLINE T*const* readRef() const { return &m_ptr; }\n"
"\n"
"\t\t/// Swap\n"
"\tvoid swap(ThisType& rhs);\n"
"\n"
"protected:\n"
"\t/// Gets the address of the dumb pointer.\n"
"    // Disabled: use writeRef and readRef to get a reference based on usage.\n"
"\tSLANG_FORCE_INLINE T** operator&() = delete;\n"
"\n"
"\tT* m_ptr;\n"
"};\n"
"\n"
"//----------------------------------------------------------------------------\n"
"template <typename T>\n"
"void ComPtr<T>::setNull()\n"
"{\n"
"\tif (m_ptr)\n"
"\t{\n"
"\t\t((Ptr)m_ptr)->release();\n"
"\t\tm_ptr = nullptr;\n"
"\t}\n"
"}\n"
"//----------------------------------------------------------------------------\n"
"template <typename T>\n"
"const ComPtr<T>& ComPtr<T>::operator=(const ThisType& rhs)\n"
"{\n"
"\tif (rhs.m_ptr) ((Ptr)rhs.m_ptr)->addRef();\n"
"\tif (m_ptr) ((Ptr)m_ptr)->release();\n"
"\tm_ptr = rhs.m_ptr;\n"
"\treturn *this;\n"
"}\n"
"//----------------------------------------------------------------------------\n"
"template <typename T>\n"
"T* ComPtr<T>::operator=(T* ptr)\n"
"{\n"
"\tif (ptr) ((Ptr)ptr)->addRef();\n"
"\tif (m_ptr) ((Ptr)m_ptr)->release();\n"
"\tm_ptr = ptr;\n"
"\treturn m_ptr;\n"
"}\n"
"//----------------------------------------------------------------------------\n"
"template <typename T>\n"
"void ComPtr<T>::swap(ThisType& rhs)\n"
"{\n"
"\tT* tmp = m_ptr;\n"
"\tm_ptr = rhs.m_ptr;\n"
"\trhs.m_ptr = tmp;\n"
"}\n"
"\n"
"} // namespace Slang\n"
"\n"
"#endif // SLANG_COM_PTR_H\n"
"\n"
"#ifndef SLANG_PRELUDE_CPP_TYPES_H\n"
"#define SLANG_PRELUDE_CPP_TYPES_H\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#   ifdef _DEBUG\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) assert(VALUE)\n"
"#   else\n"
"#       define SLANG_PRELUDE_ASSERT(VALUE) \n"
"#   endif\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#    define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE {\n"
"#endif\n"
"\n"
"struct TypeInfo\n"
"{\n"
"    size_t typeSize;\n"
"};\n"
"\n"
"template <typename T, size_t SIZE>\n"
"struct FixedArray\n"
"{\n"
"    const T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < SIZE); return m_data[index]; }\n"
"    T& operator[](size_t index) { SLANG_PRELUDE_ASSERT(index < SIZE); return m_data[index]; }\n"
"\n"
"    T m_data[SIZE];\n"
"};\n"
"\n"
"// An array that has no specified size, becomes a 'Array'. This stores the size so it can potentially \n"
"// do bounds checking.  \n"
"template <typename T>\n"
"struct Array\n"
"{\n"
"    const T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    T& operator[](size_t index) { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"#if 0\n"
"template<size_t N>\n"
"struct AnyValue\n"
"{\n"
"    uint8_t data[N];\n"
"};\n"
"template<size_t N, typename T>\n"
"AnyValue<N> packAnyValue(const T& val)\n"
"{\n"
"    AnyValue<N> result;\n"
"    memcpy(&result, &val, sizeof(T));\n"
"    return result;\n"
"}\n"
"template<size_t N, typename T>\n"
"T unpackAnyValue(const AnyValue<N>& val)\n"
"{\n"
"    T result;\n"
"    memcpy(&result, &val, sizeof(T));\n"
"    return result;\n"
"}\n"
"#endif\n"
"\n"
"/* Constant buffers become a pointer to the contained type, so ConstantBuffer<T> becomes T* in C++ code.\n"
"*/\n"
"\n"
"template <typename T, int COUNT>\n"
"struct Vector;\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 1>\n"
"{\n"
"    T x;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 2>\n"
"{\n"
"    T x, y;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 3>\n"
"{\n"
"    T x, y, z;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Vector<T, 4>\n"
"{\n"
"    T x, y, z, w;\n"
"};\n"
"\n"
"\n"
"typedef Vector<float, 2> float2;\n"
"typedef Vector<float, 3> float3;\n"
"typedef Vector<float, 4> float4;\n"
"\n"
"typedef Vector<int32_t, 2> int2;\n"
"typedef Vector<int32_t, 3> int3;\n"
"typedef Vector<int32_t, 4> int4;\n"
"\n"
"typedef Vector<uint32_t, 2> uint2;\n"
"typedef Vector<uint32_t, 3> uint3;\n"
"typedef Vector<uint32_t, 4> uint4;\n"
"\n"
"template <typename T, int ROWS, int COLS>\n"
"struct Matrix\n"
"{\n"
"    Vector<T, COLS> rows[ROWS];\n"
"};\n"
"\n"
"// We can just map `NonUniformResourceIndex` type directly to the index type on CPU, as CPU does not require\n"
"// any special handling around such accesses.\n"
"typedef size_t NonUniformResourceIndex;\n"
"\n"
"// ----------------------------- ResourceType -----------------------------------------\n"
"\n"
"// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-structuredbuffer-getdimensions\n"
"// Missing  Load(_In_  int  Location, _Out_ uint Status);\n"
"\n"
"template <typename T>\n"
"struct RWStructuredBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }  \n"
"    void GetDimensions(uint32_t* outNumStructs, uint32_t* outStride) { *outNumStructs = uint32_t(count); *outStride = uint32_t(sizeof(T)); }\n"
"  \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct StructuredBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE const T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outNumStructs, uint32_t* outStride) { *outNumStructs = uint32_t(count); *outStride = uint32_t(sizeof(T)); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"\n"
"template <typename T>\n"
"struct RWBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outCount) { *outCount = uint32_t(count); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Buffer\n"
"{\n"
"    SLANG_FORCE_INLINE const T& operator[](size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    const T& Load(size_t index) const { SLANG_PRELUDE_ASSERT(index < count); return data[index]; }\n"
"    void GetDimensions(uint32_t* outCount) { *outCount = uint32_t(count); }\n"
"    \n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"// Missing  Load(_In_  int  Location, _Out_ uint Status);\n"
"struct ByteAddressBuffer\n"
"{\n"
"    void GetDimensions(uint32_t* outDim) const { *outDim = uint32_t(sizeInBytes); }\n"
"    uint32_t Load(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 4 <= sizeInBytes && (index & 3) == 0); \n"
"        return data[index >> 2]; \n"
"    }\n"
"    uint2 Load2(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 8 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint2{data[dataIdx], data[dataIdx + 1]}; \n"
"    }\n"
"    uint3 Load3(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 12 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint3{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2]}; \n"
"    }\n"
"    uint4 Load4(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 16 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint4{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2], data[dataIdx + 3]}; \n"
"    }\n"
"    template<typename T>\n"
"    T Load(size_t offset) const\n"
"    {\n"
"        SLANG_PRELUDE_ASSERT(offset + sizeof(T) <= sizeInBytes && (offset & (alignof(T)-1)) == 0); \n"
"        return *(T const*)((char*)data + offset);\n"
"    }\n"
"    \n"
"    const uint32_t* data;\n"
"    size_t sizeInBytes;  //< Must be multiple of 4\n"
"};\n"
"\n"
"// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-rwbyteaddressbuffer\n"
"// Missing support for Atomic operations \n"
"// Missing support for Load with status\n"
"struct RWByteAddressBuffer\n"
"{\n"
"    void GetDimensions(uint32_t* outDim) const { *outDim = uint32_t(sizeInBytes); }\n"
"    \n"
"    uint32_t Load(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 4 <= sizeInBytes && (index & 3) == 0); \n"
"        return data[index >> 2]; \n"
"    }\n"
"    uint2 Load2(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 8 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint2{data[dataIdx], data[dataIdx + 1]}; \n"
"    }\n"
"    uint3 Load3(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 12 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint3{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2]}; \n"
"    }\n"
"    uint4 Load4(size_t index) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 16 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        return uint4{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2], data[dataIdx + 3]}; \n"
"    }\n"
"    template<typename T>\n"
"    T Load(size_t offset) const\n"
"    {\n"
"        SLANG_PRELUDE_ASSERT(offset + sizeof(T) <= sizeInBytes && (offset & (alignof(T)-1)) == 0); \n"
"        return *(T const*)((char*)data + offset);\n"
"    }\n"
"\n"
"    void Store(size_t index, uint32_t v) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 4 <= sizeInBytes && (index & 3) == 0); \n"
"        data[index >> 2] = v; \n"
"    }\n"
"    void Store2(size_t index, uint2 v) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 8 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"    }\n"
"    void Store3(size_t index, uint3 v) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 12 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"        data[dataIdx + 2] = v.z;\n"
"    }\n"
"    void Store4(size_t index, uint4 v) const \n"
"    { \n"
"        SLANG_PRELUDE_ASSERT(index + 16 <= sizeInBytes && (index & 3) == 0); \n"
"        const size_t dataIdx = index >> 2; \n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"        data[dataIdx + 2] = v.z;\n"
"        data[dataIdx + 3] = v.w;\n"
"    }\n"
"    template<typename T>\n"
"    void Store(size_t offset, T const& value) const\n"
"    {\n"
"        SLANG_PRELUDE_ASSERT(offset + sizeof(T) <= sizeInBytes && (offset & (alignof(T)-1)) == 0); \n"
"        *(T*)((char*)data + offset) = value;\n"
"    }\n"
"\n"
"    uint32_t* data;\n"
"    size_t sizeInBytes; //< Must be multiple of 4 \n"
"};\n"
"\n"
"struct ISamplerState;\n"
"struct ISamplerComparisonState;\n"
"\n"
"struct SamplerState\n"
"{\n"
"    ISamplerState* state;\n"
"};\n"
"\n"
"struct SamplerComparisonState\n"
"{\n"
"    ISamplerComparisonState* state;\n"
"};\n"
"\n"
"#ifndef SLANG_RESOURCE_SHAPE\n"
"#    define SLANG_RESOURCE_SHAPE\n"
"typedef unsigned int SlangResourceShape;\n"
"enum\n"
"{\n"
"    SLANG_RESOURCE_BASE_SHAPE_MASK = 0x0F,\n"
"\n"
"    SLANG_RESOURCE_NONE = 0x00,\n"
"\n"
"    SLANG_TEXTURE_1D = 0x01,\n"
"    SLANG_TEXTURE_2D = 0x02,\n"
"    SLANG_TEXTURE_3D = 0x03,\n"
"    SLANG_TEXTURE_CUBE = 0x04,\n"
"    SLANG_TEXTURE_BUFFER = 0x05,\n"
"\n"
"    SLANG_STRUCTURED_BUFFER = 0x06,\n"
"    SLANG_BYTE_ADDRESS_BUFFER = 0x07,\n"
"    SLANG_RESOURCE_UNKNOWN = 0x08,\n"
"    SLANG_ACCELERATION_STRUCTURE = 0x09,\n"
"\n"
"    SLANG_RESOURCE_EXT_SHAPE_MASK = 0xF0,\n"
"\n"
"    SLANG_TEXTURE_FEEDBACK_FLAG = 0x10,\n"
"    SLANG_TEXTURE_ARRAY_FLAG = 0x40,\n"
"    SLANG_TEXTURE_MULTISAMPLE_FLAG = 0x80,\n"
"\n"
"    SLANG_TEXTURE_1D_ARRAY = SLANG_TEXTURE_1D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_2D_ARRAY = SLANG_TEXTURE_2D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_CUBE_ARRAY = SLANG_TEXTURE_CUBE | SLANG_TEXTURE_ARRAY_FLAG,\n"
"\n"
"    SLANG_TEXTURE_2D_MULTISAMPLE = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY =\n"
"        SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG | SLANG_TEXTURE_ARRAY_FLAG,\n"
"};\n"
"#endif\n"
"\n"
"// \n"
"struct TextureDimensions\n"
"{\n"
"    void reset()\n"
"    {\n"
"        shape = 0;\n"
"        width = height = depth = 0;\n"
"        numberOfLevels = 0;\n"
"        arrayElementCount = 0;\n"
"    }\n"
"    int getDimSizes(uint32_t outDims[4]) const\n"
"    {\n"
"        const auto baseShape = (shape & SLANG_RESOURCE_BASE_SHAPE_MASK);\n"
"        int count = 0;\n"
"        switch (baseShape)\n"
"        {\n"
"            case SLANG_TEXTURE_1D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_2D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_3D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = depth;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_CUBE:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = 6;\n"
"                break;\n"
"            }\n"
"        }\n"
"\n"
"        if (shape & SLANG_TEXTURE_ARRAY_FLAG)\n"
"        {\n"
"            outDims[count++] = arrayElementCount;\n"
"        }\n"
"        return count;\n"
"    }\n"
"    int getMIPDims(int outDims[3]) const\n"
"    {\n"
"        const auto baseShape = (shape & SLANG_RESOURCE_BASE_SHAPE_MASK);\n"
"        int count = 0;\n"
"        switch (baseShape)\n"
"        {\n"
"            case SLANG_TEXTURE_1D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_CUBE:\n"
"            case SLANG_TEXTURE_2D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                break;\n"
"            }\n"
"            case SLANG_TEXTURE_3D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = depth;\n"
"                break;\n"
"            }\n"
"        }\n"
"        return count;\n"
"    }\n"
"    int calcMaxMIPLevels() const\n"
"    {\n"
"        int dims[3];\n"
"        const int dimCount = getMIPDims(dims);\n"
"        for (int count = 1; true; count++)\n"
"        {\n"
"            bool allOne = true;\n"
"            for (int i = 0; i < dimCount; ++i)\n"
"            {\n"
"                if (dims[i] > 1)\n"
"                {\n"
"                    allOne = false;\n"
"                    dims[i] >>= 1;\n"
"                }\n"
"            }\n"
"            if (allOne)\n"
"            {\n"
"                return count;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    uint32_t shape;\n"
"    uint32_t width, height, depth;\n"
"    uint32_t numberOfLevels;\n"
"    uint32_t arrayElementCount;                  ///< For array types, 0 otherwise\n"
"};\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Texture\n"
"\n"
"struct ITexture\n"
"{\n"
"    virtual TextureDimensions GetDimensions(int mipLevel = -1) = 0;\n"
"    virtual void Load(const int32_t* v, void* outData, size_t dataSize) = 0;\n"
"    virtual void Sample(SamplerState samplerState, const float* loc, void* outData, size_t dataSize) = 0;\n"
"    virtual void SampleLevel(SamplerState samplerState, const float* loc, float level, void* outData, size_t dataSize) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture1D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outNumberOfLevels) \n"
"    { \n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels; \n"
"    }\n"
"    \n"
"    void GetDimensions(float* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outNumberOfLevels) \n"
"    { \n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
;
sb << 
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels; \n"
"    }\n"
"    \n"
"    T Load(const int2& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, float loc) const { T out; texture->Sample(samplerState, &loc, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, float loc, float level) { T out; texture->SampleLevel(samplerState, &loc, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float2& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float2& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture3D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outDepth, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int4& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct TextureCube\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture1DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outElements) { auto dims = texture->GetDimensions(); *outWidth = dims.width; *outElements = dims.arrayElementCount; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outElements, uint32_t* outNumberOfLevels) \n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }        \n"
"    void GetDimensions(float* outWidth, float* outElements) { auto dims = texture->GetDimensions(); *outWidth = dims.width; *outElements = dims.arrayElementCount; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outElements, float* outNumberOfLevels) \n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel); \n"
"        *outWidth = dims.width; \n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float2& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float2& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct Texture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    void GetDimensions(uint32_t* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int4& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T Sample(SamplerState samplerState, const float3& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct TextureCubeArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    void GetDimensions(uint32_t* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Sample(SamplerState samplerState, const float4& loc) const { T out; texture->Sample(samplerState, &loc.x, &out, sizeof(out)); return out; }\n"
"    T SampleLevel(SamplerState samplerState, const float4& loc, float level) { T out; texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out)); return out; }\n"
"    \n"
"    ITexture* texture;              \n"
"};\n"
"\n"
"/* !!!!!!!!!!!!!!!!!!!!!!!!!!! RWTexture !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */\n"
"\n"
"struct IRWTexture : ITexture\n"
"{\n"
"        /// Get the reference to the element at loc. \n"
"    virtual void* refAt(const uint32_t* loc) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture1D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outNumberOfLevels) { auto dims = texture->GetDimensions(mipLevel); *outWidth = dims.width; *outNumberOfLevels = dims.numberOfLevels; }\n"
"    \n"
"    void GetDimensions(float* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outNumberOfLevels) { auto dims = texture->GetDimensions(mipLevel); *outWidth = dims.width; *outNumberOfLevels = dims.numberOfLevels; }\n"
"    \n"
"    T Load(int32_t loc) const { T out; texture->Load(&loc, &out, sizeof(out)); return out; }\n"
"    T& operator[](uint32_t loc) { return *(T*)texture->refAt(&loc); }\n"
"    IRWTexture* texture;              \n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int2& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint2& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture3D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outDepth, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint3& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"\n"
"template <typename T>\n"
"struct RWTexture1DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outElements) \n"
"    { \n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outElements) \n"
"    { \n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(int2 loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](uint2 loc) { return *(T*)texture->refAt(&loc.x); }\n"
"\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct RWTexture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    T Load(const int3& loc) const { T out; texture->Load(&loc.x, &out, sizeof(out)); return out; }\n"
"    T& operator[](const uint3& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"// FeedbackTexture\n"
"\n"
"struct FeedbackType {};\n"
"struct SAMPLER_FEEDBACK_MIN_MIP : FeedbackType {};\n"
"struct SAMPLER_FEEDBACK_MIP_REGION_USED : FeedbackType {};\n"
"\n"
"struct IFeedbackTexture\n"
"{\n"
"    virtual TextureDimensions GetDimensions(int mipLevel = -1) = 0;\n"
"\n"
;
sb << 
"    // Note here we pass the optional clamp parameter as a pointer. Passing nullptr means no clamp. \n"
"    // This was preferred over having two function definitions, and having to differentiate their names\n"
"    virtual void WriteSamplerFeedback(ITexture* tex, SamplerState samp, const float* location, const float* clamp = nullptr) = 0;\n"
"    virtual void WriteSamplerFeedbackBias(ITexture* tex, SamplerState samp, const float* location, float bias, const float* clamp = nullptr) = 0;\n"
"    virtual void WriteSamplerFeedbackGrad(ITexture* tex, SamplerState samp, const float* location, const float* ddx, const float* ddy, const float* clamp = nullptr) = 0;\n"
"    \n"
"    virtual void WriteSamplerFeedbackLevel(ITexture* tex, SamplerState samp, const float* location, float lod) = 0;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct FeedbackTexture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight) \n"
"    { \n"
"        const auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2D<S> tex, SamplerState samp, float2 location, float clamp) { texture->WriteSamplerFeedback(tex.texture, samp, &location.x, &clamp); } \n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2D<S> tex, SamplerState samp, float2 location, float bias, float clamp) { texture->WriteSamplerFeedbackBias(tex.texture, samp, &location.x, bias, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2D<S> tex, SamplerState samp, float2 location, float2 ddx, float2 ddy, float clamp) { texture->WriteSamplerFeedbackGrad(tex.texture, samp, &location.x, &ddx.x, &ddy.x, &clamp); }\n"
"\n"
"    // Level\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackLevel(Texture2D<S> tex, SamplerState samp, float2 location, float lod) { texture->WriteSamplerFeedbackLevel(tex.texture, samp, &location.x, lod); }\n"
"    \n"
"    // Without Clamp\n"
"    template <typename S> \n"
"    void WriteSamplerFeedback(Texture2D<S> tex, SamplerState samp, float2 location) { texture->WriteSamplerFeedback(tex.texture, samp, &location.x); }\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackBias(Texture2D<S> tex, SamplerState samp, float2 location, float bias) { texture->WriteSamplerFeedbackBias(tex.texture, samp, &location.x, bias); }\n"
"\n"
"    template <typename S> \n"
"    void WriteSamplerFeedbackGrad(Texture2D<S> tex, SamplerState samp, float2 location, float2 ddx, float2 ddy) { texture->WriteSamplerFeedbackGrad(tex.texture, samp, &location.x, &ddx.x, &ddy.x); }\n"
"    \n"
"    IFeedbackTexture* texture;\n"
"};\n"
"\n"
"template <typename T>\n"
"struct FeedbackTexture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions(); \n"
"        *outWidth = dims.width; \n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount; \n"
"    }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outHeight, float* outElements, float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    \n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2DArray<S> texArray, SamplerState samp, float3 location, float clamp) { texture->WriteSamplerFeedback(texArray.texture, samp, &location.x, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2DArray<S> texArray, SamplerState samp, float3 location, float bias, float clamp) { texture->WriteSamplerFeedbackBias(texArray.texture, samp, &location.x, bias, &clamp); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2DArray<S> texArray, SamplerState samp, float3 location, float3 ddx, float3 ddy, float clamp) { texture->WriteSamplerFeedbackGrad(texArray.texture, samp, &location.x, &ddx.x, &ddy.x, &clamp); }\n"
"\n"
"    // Level\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackLevel(Texture2DArray<S> texArray, SamplerState samp, float3 location, float lod) { texture->WriteSamplerFeedbackLevel(texArray.texture, samp, &location.x, lod); }\n"
"\n"
"    // Without Clamp\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedback(Texture2DArray<S> texArray, SamplerState samp, float3 location) { texture->WriteSamplerFeedback(texArray.texture, samp, &location.x); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2DArray<S> texArray, SamplerState samp, float3 location, float bias) { texture->WriteSamplerFeedbackBias(texArray.texture, samp, &location.x, bias); }\n"
"\n"
"    template <typename S>\n"
"    void WriteSamplerFeedbackGrad(Texture2DArray<S> texArray, SamplerState samp, float3 location, float3 ddx, float3 ddy) { texture->WriteSamplerFeedbackGrad(texArray.texture, samp, &location.x, &ddx.x, &ddy.x); }\n"
"    \n"
"    IFeedbackTexture* texture;\n"
"};\n"
"\n"
"/* Varying input for Compute */\n"
"\n"
"/* Used when running a single thread */\n"
"struct ComputeThreadVaryingInput\n"
"{\n"
"    uint3 groupID;\n"
"    uint3 groupThreadID;\n"
"};\n"
"\n"
"struct ComputeVaryingInput\n"
"{\n"
"    uint3 startGroupID;     ///< start groupID\n"
"    uint3 endGroupID;       ///< Non inclusive end groupID\n"
"};\n"
"\n"
"// The uniformEntryPointParams and uniformState must be set to structures that match layout that the kernel expects.\n"
"// This can be determined via reflection for example.\n"
"\n"
"typedef void(*ComputeThreadFunc)(ComputeThreadVaryingInput* varyingInput, void* uniformEntryPointParams, void* uniformState);\n"
"typedef void(*ComputeFunc)(ComputeVaryingInput* varyingInput, void* uniformEntryPointParams, void* uniformState);\n"
"\n"
"template<typename TResult, typename TInput>\n"
"TResult slang_bit_cast(TInput val)\n"
"{\n"
"    return *(TResult*)(&val);\n"
"}\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"\n"
"using namespace Slang;\n"
"\n"
"template<typename TResult, typename... Args>\n"
"using Slang_FuncType = TResult(SLANG_MCALL *)(Args...);\n"
"\n"
"#endif\n"
"\n"
;
return sb.ProduceString();
}
